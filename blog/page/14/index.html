
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Artoirus</title>
	<meta name="author" content="Arthur Wang">

	
	<meta name="description" content="一次一次的收购，一次一次的谈判，一次一次的审判，终于熬出头，为了站在Google的对面以一样的水平进行对抗两家企业一个为了&#8221;壮大自己&#8221;，一个为了&#8221;保全自己&#8221;，总之都是费尽了心思。终于最后找到了契合点，就是&#8221;击败对手&#8221;， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Artoirus" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>

<body>
	<header id="header" class="inner"><h1><a href="/">Artoirus</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:artori.us">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:artori.us">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/microsoft-yahoo-annouced-cooperation/">
		
			Microsoft 和 Yahoo! 正式宣布合作</a>
	</h2>
	<div class="entry-content">
		<p>一次一次的收购，一次一次的谈判，一次一次的审判，终于熬出头，为了站在Google的对面以一样的水平进行对抗两家企业一个为了&#8221;壮大自己&#8221;，一个为了&#8221;保全自己&#8221;，总之都是费尽了心思。终于最后找到了契合点，就是&#8221;击败对手&#8221;，于是两家定出了非常复杂且苛刻的合作条款，简单的看看吧。</p>

<p><a href="/images/uploads/zb/2009-07-30_microsoft_yahoo_tweet.jpg"><img src="/images/uploads/zb/2009-07-30_microsoft_yahoo_tweet.jpg" alt="tweet" /></a></p>

<p>上图是twitter上的消息，第一时间re-tweet了，只是twitter被墙，这tweet有或没有都无所谓了。（点击放大，提醒RSS订阅的同志，本博客使用Lightbox，所以图片尺寸都弄得有点小，见谅）这条tweet里提到的链接点<a href="http://www.choicevalueinnovation.com/thedeal/Default.aspx">这里</a>。</p>

<blockquote><p><a href="/images/uploads/zb/microsoft-yahoo.png"><img src="/images/uploads/zb/microsoft-yahoo.png" alt="" /></a></p>

<p>合作的重点包括：</p>

<ol>
<li><p>合作期长达10年</p></li>
<li><p>微软将购买10年的雅虎核心搜索技术授权，并将其与自家的搜索平台（就是Bing）整合在一起</p></li>
<li><p>微软的Bing搜索引擎将成为雅虎网站独家搜索算法和点击付费搜索独家平台</p></li>
<li><p>雅虎也可以继续使用自己的技术和数据，以使自家业务更好的显示广告</p></li>
<li><p>雅虎将成为两家公司在全球广告业务的独家代理商</p></li>
<li><p>两家公司的自助广告业务都将在微软的AdCenter平台进行，所有搜索广告的价格由AdCenter自动拍卖流程决定</p></li>
<li><p>两家公司都可保留各自独立的显示广告业务和销售队伍</p></li>
<li><p>即便雅虎使用了微软的搜索技术，但将依然改进搜索的用户体验和创新</p></li>
<li><p>在前5年，微软需要为雅虎网络旗下品牌网站和由雅虎运营的网站为其Bing搜索带来的流量支付88%的流量费用</p></li>
<li><p>微软要补偿部分雅虎网络旗下品牌网站和由雅虎运营的网站搜索带来的收入</p></li>
<li><p>微软保证合作的前18个月里，雅虎网络旗下品牌网站和由雅虎运营的网站按点击搜索的广告收入在各个国家都保持合作前的水平</p></li>
</ol>
</blockquote>

<p>上面的文字摘自<a href="http://Google.org.cn">谷奥</a>的文章《<a href="http://google.org.cn/posts/microsoft-yahoo-search-deal.html">雅虎与微软达成搜索引擎合作协议</a>》</p>

<p>条件可谓复杂、苛刻、繁琐…… 但愿这是个好事情。BTW：其实114和电信之间的某协议（DNSclient 服务）似乎对bing十分有利啊。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-30T09:29:04+08:00" pubdate data-updated="true">Jul 30<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/internet/'>internet</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/most-expecting-file-the-storm-riders-2/">
		
			本人年度最期待电影 -《风云2》</a>
	</h2>
	<div class="entry-content">
		<p><strong>风云</strong> &#8212;- 一个对于动漫迷还是武侠迷还是电影迷还是游戏迷来说都是非常非常熟悉的词汇。和所有的港漫一样，马荣成用他狂野浓重的笔墨绘制了经久不息的经典。而之后无论是电脑上足以和仙剑奇侠传一较高下的风云游戏，还是前几年何润东主演的在各个电视台疯狂的播出的电视剧版，还是去年的动画电影风云决，都深深的留在了风云迷的心中。而最为经典难忘的，则是98年，古惑仔班底当年的票房冠军作品 &#8212;- 电影版风云。</p>

<p>郭富城的云 和 郑伊健的风，在当时为漫画的真人形象奠定了非常好的基础，得到了几乎所有风云迷的认可，而雄霸的形象更是让千叶真一塑造的活灵活现，而饰演孔慈的杨恭如更是足以惊艳每一个男性。而时隔十载，风云电影的续集又来了，这一次，我们看到了更加强大的风云。</p>

<p>本身我就是非常喜欢风云的，第一集的电影更是看了无数遍无数遍。标题说是本人年度最期待，一点不假，比起泰坦尼克导演出山，比起变形金刚2来说，风云2更加重要。电影的上映时间是12月17日，不知国内能否顺利审批引进，如果没问题，那么希望有爱的朋友们都能去剧院捧场啊。下面简单的讲讲收集来的情报。</p>

<p><strong>预告片</strong>：</p>

<p><strong>情节</strong>：并非接着第一步的剧情，而是截取了原作中的绝无神的一段，风云二人大战绝无神，十分期待！</p>

<p><strong>演员</strong>：而郭富城和郑伊健继续站在风云两个男主角的位置上，另外还有饰演第二梦的蔡卓妍（阿SA），饰演楚楚的唐嫣（刚好饰演了仙剑3），饰演绝心的谢霆锋，饰演无名的何家劲，饰演绝无神的任达华。</p>

<p><a href="/images/uploads/zb/fengyun2_01_bujingyun.jpg"><img src="/images/uploads/zb/fengyun2_01_bujingyun.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_02_niefeng.jpg"><img src="/images/uploads/zb/fengyun2_02_niefeng.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_03_diermeng.jpg"><img src="/images/uploads/zb/fengyun2_03_diermeng.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_04_chuchu.jpg"><img src="/images/uploads/zb/fengyun2_04_chuchu.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_05_wuming.jpg"><img src="/images/uploads/zb/fengyun2_05_wuming.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_06_juewushen.jpg"><img src="/images/uploads/zb/fengyun2_06_juewushen.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_07_juexin.jpg"><img src="/images/uploads/zb/fengyun2_07_juexin.jpg" alt="" /></a></p>

<p><strong>场景</strong>：这一集场景非常特殊，所有的镜头都是在泰国的摄影棚里完成的， 当然摄影棚里是没有布景的，而是整块整块的蓝幕，整部电影，都将由后期制作完成，所有的打斗特效，所有的场景，甚至人物。</p>

<p><a href="/images/uploads/zb/fengyun2_s01.jpg"><img src="/images/uploads/zb/fengyun2_s01.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_s02.jpg"><img src="/images/uploads/zb/fengyun2_s02.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_s03.jpg"><img src="/images/uploads/zb/fengyun2_s03.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_s04.jpg"><img src="/images/uploads/zb/fengyun2_s04.jpg" alt="" /></a></p>

<p><strong>海报</strong>：个人觉得海报都很漂亮，包括之前在嘎纳上出现和最近新出的等等，只是找不全。</p>

<p><a href="/images/uploads/zb/fengyun2_poster01.jpg"><img src="/images/uploads/zb/fengyun2_poster01.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_poster02.jpg"><img src="/images/uploads/zb/fengyun2_poster02.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_poster03.jpg"><img src="/images/uploads/zb/fengyun2_poster03.jpg" alt="" /></a></p>

<p><strong>设定画</strong>：</p>

<p><a href="/images/uploads/zb/fengyun2_original_01.jpg"><img src="/images/uploads/zb/fengyun2_original_01.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_original_02.jpg"><img src="/images/uploads/zb/fengyun2_original_02.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_original_03.jpg"><img src="/images/uploads/zb/fengyun2_original_03.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_original_04.jpg"><img src="/images/uploads/zb/fengyun2_original_04.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_original_05.jpg"><img src="/images/uploads/zb/fengyun2_original_05.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_original_06.jpg"><img src="/images/uploads/zb/fengyun2_original_06.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_original_07.jpg"><img src="/images/uploads/zb/fengyun2_original_07.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_original_08.jpg"><img src="/images/uploads/zb/fengyun2_original_08.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_original_09.jpg"><img src="/images/uploads/zb/fengyun2_original_09.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_original_10.jpg"><img src="/images/uploads/zb/fengyun2_original_10.jpg" alt="" /></a><a href="/images/uploads/zb/fengyun2_original_11.jpg"><img src="/images/uploads/zb/fengyun2_original_11.jpg" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-29T01:22:12+08:00" pubdate data-updated="true">Jul 29<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/movie/'>Movie</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/google-recursion-and-reader-ninja-easter-eggs/">
		
			Google Recursion 和 Reader Ninja 有趣的彩蛋</a>
	</h2>
	<div class="entry-content">
		<p>Google总是不小心冒出很多彩蛋，比如躲在doogle里的塞尔达的LOGO之类的。不过这次这个还真是很有意思。</p>

<p>我们知道一般来说我搜索gogle，那么他会提醒你说是不是google。</p>

<p><a href="/images/uploads/zb/2009-07-24_GoogleRecursion.jpg"><img src="/images/uploads/zb/2009-07-24_GoogleRecursion.jpg" alt="" /></a></p>

<p>但是现在的情况呢？相信很多Google fans的人都看到过了吧，就是如果你搜索recursion这个词，那么就会在纠错里问你 Did you mean: recursion。然后就陷入了永无止境的情况中。<a href="http://www.google.com/search?rlz=1C1_____enCN333CN333&amp;sourceid=chrome&amp;ie=UTF-8&amp;q=recursion">试试看</a></p>

<p><a href="/images/uploads/zb/2009-07-24_GoogleRecursion2.jpg"><img src="/images/uploads/zb/2009-07-24_GoogleRecursion2.jpg" alt="" /></a></p>

<p>那显然这个就是个bug了，我第一次看到消息的时候我也觉得挺无聊的，难免遇上bug么，不过今天在twitter上偶然有人提起，才发现自己忘了recursion这个单词的意思了吧，不就是递归、死循环吗？</p>

<p>看来这不是个bug，而是个彩蛋啊～</p>

<hr />

<p>另外还有一个彩蛋，是Google Reader的，在Reader界面中输入&#8221;上上下下左右左右BA&#8221;（不包括引号）。哈哈KONAMI的魂斗罗经典秘籍，之后被无数次的用在各种游戏中，想不到Google的developers也这么有心情，最近又是塞尔达又是KONAMI的好强大。</p>

<p>触发之后左侧会出现和Reader Shared Items主题一样的忍者背景图。这时使用like，会有一堆爱心，当然unlike就会心碎啦～</p>

<p><a href="/images/uploads/zb/2009-07-25_Reader.jpg"><img src="/images/uploads/zb/2009-07-25_Reader.jpg" alt="" /></a></p>

<p><a href="/images/uploads/zb/2009-07-25_Reader2.jpg"><img src="/images/uploads/zb/2009-07-25_Reader2.jpg" alt="" /></a></p>

<hr />

<p>话说博客换了个主题，很多地方都是半成品，大家见谅了。另外值得一提的是加上了IE6的升级提醒，不过因为我还是坚持使用Google Friend Connect 做一些必要的功能（而不是用Z-BLOG原生的），所以不得不告诉大家IE8的特殊性，留言本、回复、Google Account 的登录这些功能IE8都神奇的不兼容。Firefox3.5 要刷新一两下才有，最好就是用自家的Chrome了，自己不会扇自己耳光（虽然也有一段时间不行）。另外阅读区域的宽度差不多是接近600像素，据说好象是最适合阅读的宽度，看到长的文章不要疲劳啊～ 最后希望大家喜欢新主题～</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-25T07:12:19+08:00" pubdate data-updated="true">Jul 25<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/internet/'>internet</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/silverlight-3-and-gpu-acceleration/">
		
			Silverlight 3 和 GPU Acceleration</a>
	</h2>
	<div class="entry-content">
		<p>Silverlight3追加了很多新特性，其中不乏其特别重视的媒体支持，还有一些3D的小特性，以及这里写的GPU加速。我没有找到十足的佐证来证明打开关闭GPU加速之后究竟应用的效率发生了多少变化，事实上，这个变化也的确取决于CPU和GPU的性能，而在我有限的尝试中，没有找出非常有力的证据来证明打开GPU加速之后提高了多少效率。</p>

<p>结束掉XNA的教程，可以随便说说别的东西了，这样很有感觉。最近因为Google Reader的更新，通过新的Like功能follow了很多口味相似的朋友，更多的分享让我看到了更多感兴趣的东西。这次写Silverlight3里的GPU加速新特性，网上查了点资料想看看是怎样的，结果七零八落的，所以写一个吧。</p>

<p><strong>一、编码方法</strong></p>

<p>开启GPU加速的方法其实很简单，只需要在Object标签里设置一个属性就可以实现这一效果了，另外一些例子中提到了其他的一个辅助的属性，这里用最简单的例子讲一下。</p>

<p><strong>1、写UI</strong></p>

<p>UI元素我们简单一些，用MediaElement来播放一段视频。起初用了wmv，也可以顺利的说明这一问题，不过后来想到不如用H.264看看，也算是3的新特性了，放在一起用用，就找了个该编码的mp4视频，片子稍微有点老。</p>

<pre><code>&lt;Canvas x:Name="LayoutRoot" Background="White"&gt;
&lt;TextBlock Width="800" Height="25"
    Canvas.Top="10" Canvas.Left="10"
    Text="Arthraim.cn GPU Acceleration Demo"
    FontSize="14"/&gt;
&lt;MediaElement Width="640" Height="272"
    Canvas.Top="40" Canvas.Left="180"
    Source="http://localhost/H264_example.mp4"
    CacheMode="BitmapCache"&gt;
&lt;/MediaElement&gt;
&lt;Image Width="183" Height="272"
    Canvas.Top="40" Canvas.Left="10"
    Source="http://localhost/poster.jpg"
    Opacity="70"&gt;
    &lt;Image.Projection&gt;
        &lt;PlaneProjection RotationY="-30" GlobalOffsetX="0"/&gt;
    &lt;/Image.Projection&gt;
&lt;/Image&gt;
&lt;/Canvas&gt;
</code></pre>

<p>编译运行一下，可以看到截图如下，正常的播放着。背景是加上了白色属性的，默认的也是白色，不过不加上这个属性，背景的处理效果就不一样了，可以试试看。</p>

<p><a href="/images/uploads/zb/2009-07-20_GPUacceleration1.png"><img src="/images/uploads/zb/2009-07-20_GPUacceleration1.png" alt="" /></a></p>

<p><strong>2、修改客户端网页</strong></p>

<p>然后真正来看看如何使用GPU加速。要做的非常简单，找到使用silverlight的客户端页面，添加下面的变量。</p>

<pre><code>&lt;param name="EnableGPUAcceleration" value="true" /&gt;
</code></pre>

<p>这样还没完，光这样我们不知道究竟做了什么有价值的事情，在微软的帮助下，我们可以使用另一个属性 &#8212;- enableCacheVisualization，这名字就取得很好，意思很明了。至于编码上也是一样，加上了变量，设置为true：</p>

<pre><code>&lt;param name="EnableCacheVisualization" value="true" /&gt;
</code></pre>

<p>然后编译运行，哇，真是惨不忍睹，好好的视频怎么变成红色了，包括背景和左边的海报都一并红色了。其实这就是添加第二个属性的作用，红色的区域就是指没有应用GPU硬件加速的区域。</p>

<p><a href="/images/uploads/zb/2009-07-20_GPUacceleration2.png"><img src="/images/uploads/zb/2009-07-20_GPUacceleration2.png" alt="" /></a></p>

<p><strong>3、修改UI</strong></p>

<p>要使得硬件加速应用在对象上，那么最后还要修改UI的MediaElement。Silverlight3在UIElement中添加了一个public属性，名为CacheMode，以配合GPU加速的使用。而MediaElement 当然是可以华丽丽的使用CacheMode这个属性的。给刚才的代码修改一下。</p>

<pre><code>&lt;MediaElement Width="640" Height="272"
    Canvas.Top="40" Canvas.Left="180"
    Source="http://localhost/H264_example.mp4"
    CacheMode="BitmapCache"&gt;
</code></pre>

<p>编译运行。中间没有红色遮盖的部分，就是真正表示了被GPU加速处理的部分。</p>

<p><a href="/images/uploads/zb/2009-07-20_GPUacceleration3.png"><img src="/images/uploads/zb/2009-07-20_GPUacceleration3.png" alt="" /></a></p>

<p>值得一提的是旁边的图片（本来是做对比用的，结果恰好遇到了这种情况）变成了绿色（无论Image是否设置了CacheMode属性），我Google了会儿，在官方论坛上也没有人答出个所以然来，据说没有加速的会被tint a color，但是没说绿色和红色分别代表了什么。我是先看到这个帖子，才自己碰到这个情况的，很巧这个例子刚好可以碰到，究竟绿色是怎么回事，知道的朋友告诉我下～</p>

<hr />

<p><strong>二、简单性能测试</strong></p>

<p>我没有编写什么代码来做什么性能测试，这里只是简单的看看CPU占用率而已，想想GPU处理去了CPU总可以减负吧，但是结果应当说相当相当的不明显，不深究了。图左边的CPU使用情况那个数值是没什么作用的，那只是一个偶然的情况，我觉得看下来两者的确是有差异的，没加速的时候大部分时间看到的数字是50以上，而打开则在50左右跳动。旁边的波形图才是比较客观的反应的，放视频的几分钟监控到的情况。其中没有打开加速的时候出现一个大的波峰，是我尝试的切换最大化的IE窗口到VS08的窗口的时候发生的情况。在打开加速之后，我也切换了一次，也感到有一些卡，不过波形上表现并不十分明显。</p>

<p>另外，也不知这个所谓的GPU加速功能有没有用到CUBA技术。</p>

<p><a href="/images/uploads/zb/2009-07-20_GPUacceleration5.jpg"><img src="/images/uploads/zb/2009-07-20_GPUacceleration5.jpg" alt="" /></a></p>

<hr />

<p><strong>三、附加3D测试</strong></p>

<p>无聊试试看同一个例子下，把MediaElement 给3D处理后还能不能硬件加速，绕Y轴旋转了点角度。从红色分布的情况来看似乎是不能加速，希望有朋友能继续探究一下这个问题。</p>

<p><a href="/images/uploads/zb/2009-07-20_GPUacceleration4.png"><img src="/images/uploads/zb/2009-07-20_GPUacceleration4.png" alt="" /></a></p>

<p>简单的写到这里吧，还有很多值得深入下去，当然，关于硬件加速方面留给微软的工作恐怕也还有很多很多。这个例子很好，不但遇到了一些特殊情况，还包括了H.264和3D等新特性的应用。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-21T05:27:24+08:00" pubdate data-updated="true">Jul 21<span>st</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-index/">
		
			XNA教程-3D游戏-目录索引</a>
	</h2>
	<div class="entry-content">
		<p><a href="/images/uploads/zb/XNAGS3_1.png"><img src="/images/uploads/zb/XNAGS3_1.png" alt="" /></a></p>

<p><strong>2011-01-16更新：换了域名和URL，更新一下链接~</strong></p>

<p>XNA GameStudio 3.1，微软XNA Creators Club Online上3D游戏视频教程文字版索引。</p>

<p><strong>XNA游戏教程.3D</strong></p>

<ol>
<li><p><a href="/xna-tutorial-3d-ch1-introduction/">3D游戏教程简介</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch2-create-solution/">创建游戏工程</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch3-add-assets/">添加Asset</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch4-render-3d-titan/">绘制3D地表</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch5-render-gameobject/">绘制GameObject</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch6-finish-missile-launcher/">完成炮台</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch7-create-missiles/">添加导弹</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch9-add-audio/">添加声效</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch9-create-enemy-ufo/">添加敌方UFO</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch10-destroy-ufo/">摧毁UFO</a></p></li>
</ol>


<p><strong>相关知识点链接</strong>（在各个章节中涉及到的知识点，<em>基本上都在文章的末尾</em>）：</p>

<ol>
<li><p><a href="/xna-tutorial-3d-ch4-render-3d-titan/">2D游戏和3D游戏之间的区别</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch4-render-3d-titan/">创建一个模型绘制方法</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch5-render-gameobject/">构造世界变换</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch6-finish-missile-launcher/">欧拉旋转</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch7-create-missiles/">什么是上一步操作状态，为什么要记录它？</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch9-add-audio/">什么是XACT？</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch9-add-audio/">设计时和运行时的XACT对象</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch9-add-audio/">加载一个XACT工程</a></p></li>
</ol>


<p><strong>原视频教程链接</strong>：<a href="http://creators.xna.com/en-US/education/gettingstarted/bg3d/chapter1">这里</a></p>

<p><strong>系列2D教程目录索引</strong>：<a href="/xna-tutorial-2d-index/">这里</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-20T08:34:24+08:00" pubdate data-updated="true">Jul 20<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch10-destroy-ufo/">
		
			XNA教程-3D游戏-10-摧毁UFO</a>
	</h2>
	<div class="entry-content">
		<p>运行一下现在的样子，实在是已经相当满意了。一个terrain覆盖的世界，一个稳稳的launcher_base，一个可以在base上自由旋转的launcher_top，并且可以使用这个launcher发射无数的导弹，远处也会飞来无数的敌方UFO，看上去游戏已经非常完整了，唯独偏偏少了一点点&#8212;-导弹无法射落UFO。那么这次的教程显而易见，就是用到3D碰撞检测，来让missile和enemyship来个大碰撞。</p>

<p>这次的教程不是很复杂，所以今天心情好就赶快把他结束掉，可以让博客转入让我自由发挥的方向。那马上开始吧～</p>

<p><strong>1、修改UpdateMissiles()</strong></p>

<p>先要修改一下这个方法，在if (missile.position.Z &lt; -6000.0f) { missile.alive = false; } 后面加上一个else，然后调用一个莫须有的方法，代码如下：</p>

<pre><code>else
{
    TestCollision(missile);
}
</code></pre>

<p>当然这个方法还没有加上。</p>

<p><strong>2、写TestCollision()</strong></p>

<p>先把这个方法全部的代码贴上吧：</p>

<pre><code>void TestCollision(GameObject missile)
{
    BoundingSphere missilesphere =
        missile.model.Meshes[0].BoundingSphere;
    missilesphere.Center = missile.position;
    missilesphere.Radius *= missile.scale;
    foreach (GameObject ship in enemyShips)
    {
        if (ship.alive)
        {
            BoundingSphere shipsphere =
                ship.model.Meshes[0].BoundingSphere;
            shipsphere.Center = ship.position;
            shipsphere.Radius *= ship.scale;
            if (shipsphere.Intersects(missilesphere))
            {
                soundBank.PlayCue("explosion");
                missile.alive = false;
                ship.alive = false;
                break;
            }
        }
    }
}
</code></pre>

<p>解释一下，BoundingSphere类是记录的是一个球形，也就是3D模型最大的外轮廓。用这个类的intersects方法和其他模型的boundingsphere确定是否相交，虽然粗糙，但是基本上已经符合我们的要求了。（相信我，即便是这样，依然难度很高）要确定BoundingSphere的中心点为模型所在的position，而半径要记得乘上scale，不然就不对了。</p>

<p>那么实际检验的地方就很简单，拿到一个missile后，遍历每一个UFO（两层循环），然后检查是否相交，如果相交就杀掉双方，并且播放声音&#8212;-我们之前准备的爆炸的声音。</p>

<p>OK，编译运行，我们这个教程的最后一部分就完成了。（放效果图，不过放了也看不出碰撞）</p>

<p><a href="/images/uploads/zb/2009-07-20_Runtime.jpg"><img src="/images/uploads/zb/2009-07-20_Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=165"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-20T08:23:33+08:00" pubdate data-updated="true">Jul 20<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch9-create-enemy-ufo/">
		
			XNA教程-3D游戏-09-添加敌方UFO</a>
	</h2>
	<div class="entry-content">
		<p>应当说之前的Chapter08是插进来的一个部分，让我们的工程还没有变得非常巨大之前，在我们第一个需要声音的对象创建之后，插进如何制作音频的教程。而按照正常的逻辑，我们现在应该添加敌人，让我们的导弹&#8221;有的放矢&#8221;（有地方使）。和2D类似，UFO是我们的敌人，他从屏幕的最远端向我们靠近，而最终飞过我们的头顶后消失，其实就游戏逻辑来说和2D是一回事，只是所在空间和视角不同了。</p>

<p>惯例，在第一段之后说一些废话。最近更新的非常缓慢，不当心看了看最近博客的点击量发现这数字也是小的可怕至极。不过我不太关注那些东西的，只是自己也期待着快点把这个教程结束，然后继续我原来的博客路线。本来以为暑假可以用XNA做点东西，所以觉得写这个也挺有趣，不过最近做别的东西中，所以这个教程快快结束吧，希望能帮助到有需要的人就对了。说起来2D教程只用了一个星期啊……</p>

<p>言归正传，开始这一节的教程吧。</p>

<p><strong>第一步、初始化UFO</strong></p>

<p>和terrain以及missilelauncher的base或head一样，载入一个GameObject的典型方法也同样适用于UFO，只是不止一个UFO，所以我们还是类似2D的，使用了GameObject的数组。</p>

<p><strong>1、声明</strong></p>

<p>在Game类，你声明了一大串一大串的地方添加如下的声明。</p>

<pre><code>Random r = new Random();
const int numEnemyShips = 3;
GameObject[] enemyShips;
</code></pre>

<ul>
<li><p>r是一个Random对象，可以让我们用来随机确定UFO的初始位置及速度。</p></li>
<li><p>numEnemyShips看来是一个会被我恶搞的变量，指同屏（最大）出现的UFO数量。</p></li>
<li><p>enemyShips当然就是GameObject的数组，数量由上一个变量确定。</p></li>
</ul>


<p><strong>2、实例化</strong></p>

<p>找到LoadContent方法，在方法的最后加上实例化一个GameObject的代码。</p>

<pre><code>enemyShips = new GameObject[numEnemyShips];
for (int i = 0; i &lt; numEnemyShips; i++)
{
    enemyShips[i] = new GameObject();
    enemyShips[i].model = Content.Load&lt;Model&gt;(
        @"Modelsenemy");
    enemyShips[i].scale = 0.1f;
    enemyShips[i].rotation = new Vector3(
        0.0f, MathHelper.Pi, 0.0f);
}
</code></pre>

<p>实例化数组后，用一个 for 循环遍历这个数组。</p>

<p>每一次遍历，先实例化GameObject，然后确定模型以及缩放和旋转，还记得旋转吗？Pitch, Yaw, Roll，所以这里的初始化值是0,pi,0，yaw了180度，即朝向屏幕外的我们。</p>

<p>这里没有对其他的一些成员做初始化，它们被留到Update里面去处理。</p>

<hr />

<p><strong>第二步、更新UFO</strong></p>

<p>留了一部分工作放在Update里完成，所以Update的工作也比较大，和Missiles一样，我们写另外一个方法来处理。</p>

<p>方法命名为：UpdateEnemyShips()。把它的调用放在Game类中Update方法处理音频update的后面。</p>

<p>然后写UpdateEnemyShips方法的内容如下：</p>

<pre><code>void UpdateEnemyShips()
{
    foreach (GameObject ship in enemyShips)
    {
        if (ship.alive)
        {
            ship.position += ship.velocity;
            if (ship.position.Z &gt; 500.0f)
            {
                ship.alive = false;
            }
        }
        // next step...
    }
}
</code></pre>

<p>因为已经实例化，所以可以用foreach来遍历了。如果UFO存活，那么位置加上速度即更新为当前位置。但是也必须处理如何杀掉它，记得第一段说的，&#8221;飞过头顶的时候&#8221;杀掉，那么就是检查Z轴就可以了。</p>

<p>注释部分是留给下一步，完成第一步欠下的，UFO的一些初始化工作。</p>

<hr />

<p><strong>第三步、继续初始化UFO</strong></p>

<p>就像这一步的名字一样，继续初始化，这是第一步欠下的债。第一步没有个position和velocity初始化，因为所有的enemy的这两个属性不是一次性初始化就好了的，随着Update里的死亡，他们要重新被初始化，所以我们不把这个工作放在第一步的LoadContent方法里，而是放在Update方法里。</p>

<p><strong>1、声明</strong></p>

<p>同样的我们需要先声明几个变量，帮助我们使用随机数。在Game类内声明以下变量：</p>

<pre><code>Vector3 shipMinPosition = new Vector3(-2000.0f, 300.0f, -6000.0f);
Vector3 shipMaxPosition = new Vector3(2000.0f, 800.0f, -4000.0f);
const float shipMinVelocity = 5.0f;
const float shipMaxVelocity = 10.0f;
</code></pre>

<p>如果你看过2D教程，那么这四个变量的用意就一定知道。</p>

<p>两个Vector3把起始位置限定在了一个立方体内。X轴-2000～2000（屏幕的左右位置），Y轴300～800（屏幕的上下位置，即高度），Z轴-6000～-4000（屏幕的深度，即距离屏幕6000到4000这个距离）。</p>

<p>而velocity，即速度，因为我们的UFO走平行于Y轴的直线，所以只用float限定他在Z轴上的速率。5到10之间。</p>

<p><strong>2、继续更新UFO</strong></p>

<p>第二步的时候，我们处理了或者的UFO如何的更新，和如何杀死。现在要处理杀死的UFO，如何复活，包括游戏刚刚运行时所有的都在死掉状态的UFO如何初始化。在第二步的方法注释部分添加如下代码：</p>

<pre><code>else
{
    ship.alive = true;
    ship.position = new Vector3(
        MathHelper.Lerp(
            shipMinPosition.X,
            shipMaxPosition.X,
            (float)r.NextDouble()),
        MathHelper.Lerp(
            shipMinPosition.Y,
            shipMaxPosition.Y,
            (float)r.NextDouble()),
        MathHelper.Lerp(
            shipMinPosition.Z,
            shipMaxPosition.Z,
            (float)r.NextDouble()));
    ship.velocity = new Vector3(
        0.0f,
        0.0f,
        MathHelper.Lerp(
            shipMinVelocity,
            shipMaxVelocity,
            (float)r.NextDouble()));
}
</code></pre>

<p>代码看起来很长，但其实逻辑很简单，我们只修改了三个属性：alive、position、velocity。</p>

<p>只是我们用到了MathHelper.Lerp方法和Random.NextDouble方法嵌在代码里。Lerp限定r.NextDouble生成的一个随机的双精度浮点数的范围，分到X,Y,Z三个分量上而已。而velocity就像之前说的，只需要Z轴有速度，所以只在Z轴用了相应的方法。</p>

<p>那么处理完这些，最后一步就是绘制UFO了。</p>

<hr />

<p><strong>第四步、绘制UFO</strong></p>

<p>找到Draw方法，和missiles的画法一样，用一个foreach循环就搞定了。多亏了我们有写DrawGameObject这样的方法。</p>

<pre><code>foreach (GameObject enemyShip in enemyShips)
{
    if (enemyShip.alive)
    {
        DrawGameObject(enemyShip);
    }
}
</code></pre>

<p>好了好了，这样就没有问题了。编译、运行。（效果如图，点击放大）我承认我改了UFO数量。</p>

<p><a href="/images/uploads/zb/2009-07-19_Runtime.jpg"><img src="/images/uploads/zb/2009-07-19_Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=164"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-20T07:40:59+08:00" pubdate data-updated="true">Jul 20<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch9-add-audio/">
		
			XNA教程-3D游戏-08-添加声效</a>
	</h2>
	<div class="entry-content">
		<p>这个3D教程中，有一个对于2D也通用的，并且在之前的教程没有涉及到过的内容，就是音效，也就是这一次要完成的内容。用到了XACT来处理一些东西，那么教程就是音效的添加了，发射导弹之后的音效。当然作为XNA游戏，你也可以调用其他API来完成这个工作，不过这里讲的是标准的利用XNA的XACT来完成的步骤。</p>

<p>放假就是放假，感觉做正经事情的效率还真是很低，更不用说好好打理博客了。拖了几天，因为组织了一场初中同学会，可谓轰轰烈烈，难得可以请到那么多以前的老师，都很是感激和感动。言归正传，写程序吧。</p>

<p><strong>第一步、简介</strong></p>

<p>游戏很重要的一个因素是声音，在之前的2D教程中，却没有涉及到这个内容。在XNA中，我们使用的音效将是被包含在另一个声音工程当中的，这就要使用到XNA Game Studio中的一个工具 &#8212;- Microsoft Cross-Platform Audio Creation Tool 简称为XACT。在开始菜单中选择它，有v2或v3两个版本，这里我们和教程一样v3，大概的功能都是一样的。（参见文章后方的翻译1、什么是XACT？）</p>

<p><img src="/images/uploads/zb/2009-07-13_XACTs.jpg" alt="" /></p>

<p>打开后界面如下图所示，除了工具栏，左侧上方是一个树形视图，有一些项目已经存在。</p>

<p><a href="/images/uploads/zb/2009-07-13_XactUserInterface.jpg"><img src="/images/uploads/zb/2009-07-13_XactUserInterface.jpg" alt="" /></a></p>

<hr />

<p><strong>第二步、新建XACT工程</strong></p>

<p><strong>1、创建新工程</strong></p>

<p>类似Visual Studio的思路：选择File->New Project。</p>

<blockquote><p>&#8230;TChapter8ContentAudioTAudio.xap</p></blockquote>

<p>选择路径（比如我使用如上路径），保存为任意的名字，[确定]，这样创建就算成功了。</p>

<p><img src="/images/uploads/zb/2009-07-13_NewXactProject.jpg" alt="" /></p>

<p><strong>2、新建Wave Band</strong></p>

<p>然后在左边树形图上，WaveBand处右键->New Wave Band。新建一个Wave Band。</p>

<p><strong>3、新建Sound Band</strong></p>

<p>最后在左边树形图上，SoundBand处右键->New Sound Band。新建一个Sound Band。</p>

<p><a href="/images/uploads/zb/2009-07-13_NewWaveBand_NewSoundBand.jpg"><img src="/images/uploads/zb/2009-07-13_NewWaveBand_NewSoundBand.jpg" alt="" /></a></p>

<hr />

<p><strong>第三步、添加Wave并创建Sound</strong></p>

<p><strong>1、插入wav文件</strong></p>

<p>右键单击右侧Wave Band的子窗口空白处，选择Insert Wave Files。</p>

<p><a href="/images/uploads/zb/2009-07-13_AddWavesToWaveBand.jpg"><img src="/images/uploads/zb/2009-07-13_AddWavesToWaveBand.jpg" alt="" /></a></p>

<p>记得我们之前排除到GS游戏工程外面的那两个wav文件吗，现在把他们找到并且插入进来。一个是发射导弹的声音，一个是爆炸的声音。</p>

<p><a href="/images/uploads/zb/2009-07-13_Waves.jpg"><img src="/images/uploads/zb/2009-07-13_Waves.jpg" alt="" /></a></p>

<p>插入之后如下图所显示的，这样我们准备好了Wave了。</p>

<p><a href="/images/uploads/zb/2009-07-13_AfterAddedWaves.jpg"><img src="/images/uploads/zb/2009-07-13_AfterAddedWaves.jpg" alt="" /></a></p>

<p><strong>2、创建Sound</strong></p>

<p>这里利用一些XACT提供的便捷操作，我们很容易办到。简单的把Wave Band子窗体内的两个wav，拖拽到Sound Band子窗体的Cue区域内，这样会自动创建出我们需要的一切。</p>

<p><a href="/images/uploads/zb/2009-07-13_AddWavesToCue.jpg"><img src="/images/uploads/zb/2009-07-13_AddWavesToCue.jpg" alt="" /></a></p>

<p>Wave, Sound, Cue是XACT中涉及的重要的概念，如上图我们是这样的处理顺序，但是其实内部处理时不是这样的。（参见文章后方的翻译2、设计时与运行时的XACT对象）</p>

<p>准备就绪后，保存并且退出，之后的工作，就是在GS里完成了。</p>

<hr />

<p><strong>第四步、在GS工程中添加XACT工程</strong></p>

<p>完整的创建了一个XACT工程之后，我们就直接可以把它当作asset放进GS工程的Content中，并且在游戏中，直接可以从Content pipline去Load这些声音了。当然首先我们要把它添加进来。</p>

<p>右键单击Content下的Audio目录，选择Add->Existing Items。</p>

<p><a href="/images/uploads/zb/2009-07-13_AddXactProjectToGs.jpg"><img src="/images/uploads/zb/2009-07-13_AddXactProjectToGs.jpg" alt="" /></a></p>

<p>找到保存起来的xap工程文件，[确定]。（比如我刚才保存的是TAudio.xap，找到它）</p>

<p><img src="/images/uploads/zb/2009-07-13_AfterAddedXactProject.jpg" alt="" /></p>

<p>如上图，声音就添加成功了。</p>

<hr />

<p><strong>第五步、加载声音内容</strong></p>

<p>之前我们载入一些资源都是使用了Content.Load这个方法，那么这里载入Audio将会有些不同，我们需要一些其他的方法来调用它们。</p>

<p><strong>1、声明 </strong></p>

<p>首先在Game类声明一些需要用到的私有变量。</p>

<pre><code>AudioEngine audioEngine;
SoundBank soundBank;
WaveBank waveBank;
</code></pre>

<p>没错，这里用到了三个类，两个很熟悉，SoundBank和WaveBank，应该是和之前的对应起来的。AudioEngine顾名思义，是处理声音的引擎，究竟如何工作，看下去。</p>

<p><strong>2、加载</strong></p>

<p>加载Content中的声音文件，是一个非常特殊的步骤，代码只有三行，在LoadContent方法中，SpriteBatch那一行的下面加上这样三行代码。</p>

<pre><code>audioEngine = new AudioEngine(@"ContentAudioTAudio.xgs");
waveBank = new WaveBank(audioEngine, @"ContentAudioWave Band.xwb");
soundBank = new SoundBank(audioEngine, @"ContentAudioSound Band.xsb");
</code></pre>

<p>注意，这三行代码的特殊之处，就在于三个后缀。</p>

<p>audioEngine中，不是使用了TAudio.xap这个文件，而是使用了TAudio.xgs这样的方式。如果看过之前对Content Pipline的介绍，那么你就不会不知道，Content不是简单的一个文件夹把文件组织起来，而是会对输入asset做处理并且有相应的输出，而这里的xap作为输入，我们是无法直接获得相应的Wave Band和Sound Band的。&#8221;xgs&#8221;缩写自XACT Global Settings，它是一个告诉你XACT工程如何组织文件的文件，Content Pipline只有依靠他才能找到我们需要的各种资源。大致说来就是这样。</p>

<p>一样的WaveBand和SoundBand的构造方法中，传入的是Wave Band.xwb（代表XACT Wave Band）和Sound Band.xsb（代表XACT Sound Band），而文件名则是我们之前在XACT工程中保留默认命名的Wave Band和Sound Band，当然你可以取不一样的名字。xwb和xsb类似xgs，也是输出的结果，就像之前的texture和model我们根本不使用后缀一样。</p>

<p>如果你编译了你的工程之后，可以在Debug目录下相应的位置找到这三个文件。（参见文章后方的翻译3、加载一个XACT工程）</p>

<hr />

<p><strong>第六步、添加声音播放的代码</strong></p>

<p><strong>1、Update声音</strong></p>

<p>我们肯定要求声音跟着游戏循环播放，而不是在一帧里面放完就结束。</p>

<p>在Update方法中，找到UpdateMissiles();这行调用，在其下方插入一行。</p>

<pre><code>audioEngine.Update();
</code></pre>

<p>这个方法可以保证声音一帧一帧的更新并且播放，其实游戏中我们播放的既不是Sound也不是Wave，而只是Cue。</p>

<p><strong>2、 播放导弹发射声音</strong></p>

<p>在发射导弹的时刻播放一个missilelaunch的声音，下面来找到FireMissile()方法，在if (!missile.alive)之后插入这样一行代码。</p>

<pre><code>soundBank.PlayCue("missilelaunch");
</code></pre>

<p>编译运行，我们要的生效就出现了～</p>

<p>【官方代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=163"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>以下是一些XACT相关内容的翻译，总共有三个部分，分别对应第一步、第三步、和第五步的相关操作。</p>

<p>在翻译中涉及到了一些概念，其中经常被提到的有3个词，在原文中采用了小写，因此不是什么特有名字，但是却很难翻译成中文，这里特别提出一下。分别是wave,sound,cue这三个词。这是XACT涉及到的三个很重要的概念，它们环环相扣，所以翻译也许十分恼人。我把它们翻译成&#8221;波&#8221;、&#8221;声音&#8221;、&#8221;索引&#8221;，虽然不太贴切，但是可以保证在以下的文字中，只要出现这三个中文词，绝对就代表了这三个英文的原文单词。并且每一段文字中第一次出现这三个词的时候，都会在括号里写上相应的原文。另外设计到的一些首字母大写的专有名词都没有翻译。</p>

<p>（以下文字有本人翻译自XNA Creators Club官网，未经允许严禁转载；因本人水平有限，难免出错，望得到更正）</p>

<p><strong>1、什么是XACT？</strong></p>

<blockquote><p>教程的这一部分将介绍包含在XNA Game Sudio中的一个新的程序&#8212;-Microsoft Cross-Platform Audio Creation Tool，或者简称为XACT。</p>

<p>就像它的名字一样，XACT是一个跨平台的工具，制作音频输出用以Windows和Xbox360。XACT的设计允许音频独立于将要使用的平台来单独设计。</p>

<p>XACT由两个主要部分组成：音频设计器（在这章节教程开始时你用到的图形化工具）和音频API（教程结束部分你会用到的代码）。音频设计器旨在允许任何一个为游戏设计音频的设计者可以进行操作，即便其不熟悉音频代码。</p>

<p>音频设计者使用所有原生的波形音频文件（.wav文件，被称为波（wave））。然后设计者组织这些波到声音（sound）形式，可以被让一个或多个波在各种时间和各种设定下被播放。最后，音频设计者组织声音到索引（Cue）形式。索引代表了在代码阶段可以访问的对象，并且相比实际的音频文件，更加接近游戏事件。</p>

<p>索引是暴露给程序员的，在合适的游戏事件发生时，使用XACT API调用索引播放。音频设计者同时可以设计一些运行时的参数，来修改播放的声音的音量或说是波幅，传递这些参数给程序员，使其能转化这些参数为游戏代码中的变量。</p>

<p>虽然起初看起来似乎有些复杂，但其优势可以在音频设计者要替换波形音频文件的时候，调整音频如何播放的时候，修改索引如何播放一个声音的时候，或改变设定的参数如何修改播放的声音的时候。音频设计者可以做所有的这些工作，而不必接触游戏源代码。</p>

<p>XACT是一个快捷且灵活的工具，来添加健壮、饱满的音频到使用XNA Game Studio创建的游戏中。</p></blockquote>

<p><strong>2、设计时和运行时的XACT对象</strong></p>

<blockquote><p>XACT工程有很多的组成部分。虽然其中一些部分是可选的，但一个基本形式的XACT对象对于XACT工程组织音频到XACT API还是非常必要的。</p>

<p>每个XACT工程包含了一个或多个Wave Bank。一个Wave Bank是一些波形音频文件的集合，称为波（wave）。这些Wave Bank中的波不是由XACT API直接访问的。而是给音频设计者转换其成为声音（sound）的。</p>

<p>这些声音组织成为一个或多个Sound Bank。一个Sound Bank是一些声音的集合。声音是使用各种参数去播放一个或多个波的时候的须知（instruction），这些参数可以是控制循环，变换效果，波的随机选择，或者更多其它的。</p>

<p>Sound Bank也同样可以包含索引（cue）。索引是播放声音的须知（instruction to play sounds）。索引调用特定的声音，或随机选择声音，这取决于音频设计者如何设定这个索引。</p>

<p>当一个XACT工程已经建立，sound bank和wave bank就被编译到文件中了，一起的还有一个全局设定文件（global setting file）包含了一些工程特定的信息。这些文件在运行时使用XNA Framewrok来调用。</p>

<p>在sound bank、wave bank和全局设定文件被加载到游戏中后，程序员可以调用SoundBank.PlayCue，传入音频设计者已经定义好的索引的名字，来播放任意一个sound bank中索引。这样会按照音频设计者设计的默认方式播放这些索引，而没有任何程序员掌握的控制条件。</p>

<p>要得到播放的索引更多颗粒化的操作，包括暂停、回复和停止的功能，程序员可以调用SoundBank.GetCue并且得到一个Cue对象。然后程序员可以根据需要调用Cue.Play，Cue.Stop，CuePause，和Cue.Resume。然而，这样使用Cue对象仍然需要谨慎一些。如果你创建的一个Cue对象在声明的时候存在范围的限制（比方说只声明在一个方法中），就不要把Cue对象存储到静态化存储空间中，就像类的数组或List集合，这些Cue对象会在程序溢出这个范围之后停止并释放。</p>

<p>在一个索引被封播放之后，XACT音频引擎的任务就完成了。这取决于索引和其相关联的声音的关系，以及声音和其相关联的波的关系，然后按照音频设计者设计的那样来播放相应声音和波。</p></blockquote>

<p><strong>3、加载一个XACT工程</strong></p>

<blockquote><p>在XNA Game Studio游戏中播放音频需要加载XACT工程到XNA Framework内容管道（Content Pipline）中，编写加载XACT运行时输出文件所必要的代码，然后在游戏编译进程中XACT工程会被编译成为XACT输出文件。</p>

<p>音频内容和XNA Game Studio中大部分其他内容的形式不同。XACT处理生成的内容不像模型、贴图纹理或者字体那样在运行时使用ContentManager.Load方法加载。</p>

<p>取而代之的，是构造AudioEngine、SoundBank、和WaveBank这些XNA Framework中音频相关的类，用来加载编译后的音频文件。用正确的顺序加载这些文件，用名称和后缀定义它们都非常重要。否则，你可能会遇到错误。</p>

<p>要明白如何加载这些文件，那明白XACT工程编译后生成了什么文件就显得十分重要。</p>

<p>XACT生成的第一个文件就是XACT工程文件（.xap）。这个文件是音频设计者在用音频设计工具保存音频工程时创建的。这个文件应该放置到Solution Explorer中，即把它添加到XNA Framework内容管道（Content Pipeline）的文件列表中去编译。</p>

<p>在编译开始后，内容管道把XACT工程文件编译成为一系列XACT输出文件。第一个生成的文件是全局设定文件（Global Settings File），默认命名为XACT工程文件一样的名字，扩展名为.xgs。如果XACT工程文件的名字是MyGameAudio.xap，那全局设定文件的默认的名字就是MyGameAudio.xgs。</p>

<p>编译过程之后会生成一个或多个wave bank文件，数量取决于音频设计者在XACT工程中添加的wave bank的数量。这些wave bank文件有一个后缀.xwb，并且由音频设计者在之前命名。默认的一个wave bank的输出文件名为Wave Bank.xwb。</p>

<p>编译过程还会生成一些sound bank文件，同样取决于音频设计者在XACT工程中添加的sound bank的数量。这些Sound bank文件有一个后缀.xsb，并且由音频设计者在之前命名。默认的一个sound bank的输出文件名为Sound Bank.xsb。</p>

<p>加载这些文件是初始化当使用XNA Framework播放音频时需要的代码对象的重要部分。加载工作表现为一步一步构造所有相关联的这些代码对象。全局设定文件用来构造AudioEngine。AudioEngine对象和wave bank文件同时使用，可以初始化一个WaveBank对象，而和sound bank文件一起使用，可以初始化一个SoundBank对象。</p>

<p>下面的插图解释了文件的一些关系，从音频设计者在设计时的形式，到通过内容管道编译时的形式，最终成为运行时游戏开始后被载入的形式。</p>

<p><a href="/images/uploads/zb/BG_4.8.5.4pd.png"><img src="/images/uploads/zb/BG_4.8.5.4pd.png" alt="" /></a></p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-14T01:26:58+08:00" pubdate data-updated="true">Jul 14<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch7-create-missiles/">
		
			XNA教程-3D游戏-07-添加导弹</a>
	</h2>
	<div class="entry-content">
		<p>在3D的地表上添加了可以控制的炮塔，接下去要让他向整个3D空间里自由的发射导弹。这次我们真正的要接触到Update这个方法了，另外知道在游戏循环中处理一些按键的逻辑。和2D一样，发射出去的导弹也是GameObject，那么一样的我们还是要用到它，并且要用到它的集合，来管理多枚屏幕中的导弹。</p>

<p>这一部分官方把视频分为了6段之多，不过其实内容基本上和2D差不多，那么还是一步一步看下去，其实分的越细致，越容易理解的。</p>

<p><strong>第一步、扩展GameObject</strong></p>

<p>正如前面说到的，这一次要用GameObject来描述导弹，那么它就应该具有所有导弹需要的属性，和2D类似，需要的是一个Vector3记录初速度， 和一个bool记录模型是否存活。</p>

<p>添加这样两行到GameObject类中～</p>

<pre><code>public Vector3 velocity = Vector3.Zero;
public bool alive = false;
</code></pre>

<ul>
<li><p>velocity：Vector3，记录速度（速率和方向），初始化为0；</p></li>
<li><p>alive：bool，记录是否存活，初始化为false。</p></li>
</ul>


<hr />

<p><strong>第二步、添加missiles数组</strong></p>

<p>拥有了为导弹扩展之后的GameObject类，现在就要添加一定数量的导弹了，所以我们用到了一个GameObject数组，来记录所有游戏中出现及没有出现的导弹。</p>

<p><strong>1、声明：</strong>还是要先添加声明，一个const int记录数组大小，即最多的同屏导弹数。在Game1类的头部添加代码：</p>

<pre><code>const int numMissiles = 20;
GameObject[] missiles;
</code></pre>

<p><strong>2、初始化：</strong>在LoadContent中用循环来初始化数组中所有的GameObject。找到LoadContent()：</p>

<pre><code>missiles = new GameObject[numMissiles];
for (int i = 0; i &lt; numMissiles; i++)
{
    missiles[i] = new GameObject();
    missiles[i].model = Content.Load&lt;Model&gt;(
    @"Modelsmissile");
    missiles[i].scale = 3.0f;
}
</code></pre>

<p>实例化missiles数组为20个GameObject。</p>

<p>循环使用for，遍历每一个，并实例化 ，载入模型为missile，缩放大小为3倍，因为模型比较小的缘故吧。</p>

<hr />

<p><strong>第三步、导弹发射输入</strong></p>

<p>这一步要编写控制导弹发射的逻辑，和2D一模一样，除了命名不一样。一样从声明和Update代码两部分看。</p>

<p><strong>1、声明：</strong></p>

<pre><code>GamePadState previousState;
#if !XBOX
KeyboardState previousKeyboardState;
#endif
</code></pre>

<h1>if和#endif在之前控制炮台转动的教程中已经出现过。</h1>

<p>这里为什么用到这样两个变量，在文章最后为加上翻译的资料。</p>

<p><strong>2、Update代码：</strong></p>

<pre><code>missileLauncherHead.rotation.Y = MathHelper.Clamp(
missileLauncherHead.rotation.Y,
-MathHelper.PiOver4,
MathHelper.PiOver4);
missileLauncherHead.rotation.X = MathHelper.Clamp(
    missileLauncherHead.rotation.X,
    0,
    MathHelper.PiOver4);
if (gamePadState.Buttons.A == ButtonState.Pressed &amp;&amp;
    previousState.Buttons.A == ButtonState.Released)
{
    FireMissile();
}
#if !XBOX
if(keyboardState.IsKeyDown(Keys.Space) &amp;&amp;
    previousKeyboardState.IsKeyUp(Keys.Space))
{
    FireMissile();
}
#endif
previousState = gamePadState;
#if !XBOX
previousKeyboardState = keyboardState;
#endif
</code></pre>

<p>这里的代码看上去挺多，但逻辑其实很清晰。都是在上一次按键放下的前提下，看下的话，就调用FireMissile方法。这样就不能按住案件连续发射了。</p>

<p>FireMissile方法正是下一步要完成的内容。</p>

<hr />

<p><strong>第四步、发射导弹</strong></p>

<p>在Update方法里的FireMissile就是更新导弹的一个重要步骤，我们应该在这里让导弹活过来，并且给予初速度。</p>

<p>这里不向2D获取速度、位置那么简单，因为要知道我们是三维的，所以我们用了一些新的方法来得到我们想要的，看下去吧。</p>

<p><strong>1、完成FireMissile方法。</strong></p>

<pre><code>void FireMissile()
{
    foreach (GameObject missile in missiles)
    {
        if (!missile.alive)
        {
            missile.velocity = GetMissileMuzzleVelocity();
            missile.position = GetMissileMuzzlePosition();
            missile.rotation = missileLauncherHead.rotation;
            missile.alive = true;
            break;
        }
    }
}
</code></pre>

<p>我就说微软工程师都是天才，先直接写了FireMissile方法，然后现在又无中生有了两个方法。不去管它，逻辑比较简单，foreach遍历所有的数组中的GameObject，如果不存活就让他活过来。</p>

<p>要活过来的话，先要给速度，再给初始位置，再给初始旋转为炮塔转到的角度。然后设置alive为真，break跳出。跳出保证每次只发射一颗子弹。</p>

<p><strong>2、声明两个新变量。</strong></p>

<p>这里我们需要声明两个新的变量，在Game1头部加上两行代码：</p>

<pre><code>const float launcherHeadMuzzleOffset = 20.0f;
const float missilePower = 20.0f;
</code></pre>

<p>两个浮点的常量。命名有些奇怪，但其实意思很简单</p>

<ul>
<li><p>launcherHeadMuzzleOffset，发射器头部炮口偏移量，翻译过来就是这个意思，就是指炮管的长度，也就是导弹刚刚射出的时候距离模型中心的长度。这个值得问做模型的美工啦～</p></li>
<li><p>missilePower，导弹的威力，就是指每一次更新导弹的位移，也就是速率。导弹的威力取决于速度？也许在这个游戏中是的吧。</p></li>
</ul>


<p>这是一个准备工作，为的是完成天才们预留的两个方法。</p>

<p><strong>3、GetMissileMuzzleVelocity方法。</strong></p>

<pre><code>Vector3 GetMissileMuzzleVelocity()
{
    Matrix rotationMatrix =
         Matrix.CreateFromYawPitchRoll(
             missileLauncherHead.rotation.Y,
             missileLauncherHead.rotation.X,
             0);
    return Vector3.Normalize(
        Vector3.Transform(Vector3.Forward,
        rotationMatrix)) * missilePower;
}
</code></pre>

<p>这里首先创建了一个rotationMatrix，用的就是CreateFromYawPitchRoll，之前也使用到过。从初始化的代码来看，得到的就是炮台的旋转情况，因为Z轴的旋转，也就是翻转（roll） 是不存在的，所以传给其0就可以了。</p>

<p>之后的步骤有些复杂，拆开来看。</p>

<ul>
<li><p>首先是调用了Vector3.Transform()这个方法，这个方法是把一个旋转矩阵转换成一个向量。</p>

<ul>
<li><p>第一个参数为一个Vector3，也就是参考的方向向量。</p></li>
<li><p>第二个参数是一个Matrix，也就是旋转矩阵。</p></li>
</ul>
</li>
</ul>


<p>方法会得到相对于第一个参数的向量的，当前Matrix的旋转情况。</p>

<ul>
<li><p>其次是调用了Vector3.Normalize这个方法，这个方法是把一个向量转换成一个单位向量。唯一的参数就是一个Vector3。相当于只保留了向量对方向的表达性，而去掉了速率的表达性。这样为最后一个工作作了铺垫。</p></li>
<li><p>最后把单位向量乘上missilePower，也就是位移量，这样给返回的Vector3加上了速率的信息。</p></li>
</ul>


<p>得到Velocity的过程就是这样，有了方向和速率，速度就这样完整了。</p>

<p><strong>4、GetMissileMuzzlePosition方法。</strong></p>

<p>得到了速度，这里要给他一个位置信息。因为是在FireMissile方法中被调用，那么其实就是起始位置，所以来看看代码。</p>

<pre><code>Vector3 GetMissileMuzzlePosition()
{
    return missileLauncherHead.position +
        (Vector3.Normalize(
            GetMissileMuzzleVelocity()) *
            launcherHeadMuzzleOffset);
}
</code></pre>

<p>很简单的直接返回。一样是一句复杂的语句，拆开来看看。</p>

<ul>
<li><p>首先调用了GetMissileMuzzleVelocity()方法，得到上一个方法完成的速度Vector3。</p></li>
<li><p>然后调用了Vector3.Normalize()方法，只取得它的方向信息，去除速率信息。</p></li>
<li><p>最后乘上launcherHeadMuzzleOffset，使得导弹出现的第一个位置是炮管的顶端，而不是模型的中心。</p></li>
</ul>


<p>意思很明了，前两个调用相当于是得到炮塔在按键的一刹那的方向。换句话说，用GetMissileMuzzleVelocity方法里的逻辑也不难得到。</p>

<hr />

<p><strong>第五步、更新导弹</strong></p>

<p>因为3D的缘故，第四步稍稍显得有些复杂了，有一些新的方法。</p>

<p>当然在完成了这些工作后，现在就显得简单的多了，这一步，只要让导弹在每次更新是移动一定的距离，并且在移动到一定距离后就消失。</p>

<p><strong>1、编写一个UpdateMissile方法。</strong></p>

<p>首先要写一个UpdateMissile的方法来管理所有的Missile的移动。</p>

<pre><code>void UpdateMissiles()
{
    foreach (GameObject missile in missiles)
    {
        if (missile.alive)
        {
            missile.position += missile.velocity;
            if (missile.position.Z &lt; -6000.0f)
            {
                missile.alive = false;
            }
        }
    }
}
</code></pre>

<ul>
<li><p>不需要返回值。</p></li>
<li><p>遍历所有的导弹，如果它存活着就更新他的位置。</p></li>
<li><p>原来的位置加上速度就是现在的位置。</p></li>
<li><p>如果导弹的Z坐标小于-6000，即，深入屏幕6000，那么就让他死掉，准备再一次的发射。</p></li>
</ul>


<p>以上就是所有的逻辑。</p>

<p><strong>2、调用UpdateMissile方法。</strong></p>

<p>写完方法当然要调用（这次到不是先调用再写了）。在Update方法中，previousState = gamePadState;这一行之前插入一行代码。</p>

<blockquote><p>UpdateMissiles();</p></blockquote>

<p>就是这样。</p>

<hr />

<p><strong>第六步、绘制导弹</strong></p>

<p>最后一步每次都是这样子，就是完成之前逻辑后，把它画出来，习惯了这系列的教程就非常明白了。</p>

<p>相对于前面调用DrawGameObject来说，这一次只是要用一个foreach循环调用很多遍而已。</p>

<pre><code>foreach (GameObject missile in missiles)
{
    if (missile.alive)
    {
        DrawGameObject(missile);
    }
}
</code></pre>

<p>最后，编译，运行～(点击放大，导弹太小，难以察觉，不如调整一下参数啊～)</p>

<p><a href="/images/uploads/zb/2009-07-08_runtime.jpg"><img src="/images/uploads/zb/2009-07-08_runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=162"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>之前说过，处理输入的那一步存在的一些疑问。（其实2D里也一样吧～）为什么要记录上一步的操作状态。究竟起到了什么作用，那么这一段解释非常非常的清楚。</p>

<p>（以下文字翻译自XNA Create Club网站，未经允许禁止转载。由于本人水平有限，所以有任何错误希望高手更正。）</p>

<p><strong>什么是上一步操作状态，为什么需要记录它？</strong></p>

<blockquote><p>要理解对应游戏的输入，很有必要退一步看看更加普通的输入。控制器的输入信号一般只是简单的电流信号，它被一种称为驱动软件的低级软件系统分析解释。信号以一定的频率传入分析它们的软件。</p>

<p>有些软件把输入的解析表现出来，反映出很多用户使用这个输入设备做出的动作，并且把这些动作存入缓冲记忆体中等待被读取或释放。这种类型的输入处理被称为&#8221;缓冲模式输入&#8221;(buffered-mode input)。</p>

<p>另一种输入处理不使用缓冲。取而代之的，是提供索取信号是的当前状态。没有提供参数来标识一定时间内所做出的特定动作。取而代之的，是程序员可以在任何时间自由的访问控制器的当前状态，包括所有的轴的位置以及按键的情况。程序员可以自由存储和操作相关的信息。这种输入处理被称为&#8221;立即模式输入&#8221;( immediate-mode input)。</p>

<p>XNA Framework使用立即模式输入，并且支持全部三种输入方式&#8212;-Xbox360控制器，键盘以及鼠标。这意味着，对于任意一种输入设备，你都可以在任何时间查询输入设备的当前状态信息。然而，你却不能查询任何过去的设备状态，除非你明确的把它存储在其他地方。</p>

<p>为什么要查询过去的输入状态呢？举个强烈依赖玩家快速按键的游戏作为例子。在这样的游戏中，长按按键不会有什么效果，只有重复的连打才能奏效。</p>

<p>由于立即模式输入处理的这一特性，每一次输入状态被查询，一个长按的按钮表现为&#8221;被按下&#8221;（Pressed）。不检查过去的状态是否是&#8221;被释放&#8221;（Released），就没有办法来区分按键是刚刚被按下还是长按了一段时间。</p>

<p>存储上一次状态缓解了这个问题。每一次循环到达更新（Update），正常的处理输入，但是在循环的末尾，存储当前状态为一个变量。这个变量就成为上一次状态。要检查按键是否是被一次按下还不是长按着，检查当前按键状态为&#8221;已按下&#8221;(Pressed)，并且上一次按键状态为&#8221;已释放&#8221;（Released）。</p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-08T23:38:32+08:00" pubdate data-updated="true">Jul 8<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch6-finish-missile-launcher/">
		
			XNA教程-3D游戏-06-完成炮台</a>
	</h2>
	<div class="entry-content">
		<p>之前完成了GameObject类的一些基础工作，也因此，我们可以使得terrain和missle launcher base利用GameObject绘制在了屏幕上。应该记得，我们添加发射塔的时候说明了，这只是一个基座（base），至于炮塔部分其实是没有被添加的，而这就是我们这次要完成的工作。不但要完成这个发射塔，还要使得它可以被用户控制，对用户输入产生反应，那么现在开始吧。</p>

<p><strong>第一步、绘制炮塔的GameObject</strong></p>

<p>这一步的当然是非常的简单，我们只是把没有画上去的那一半处理好就可以了，添加一个新的GameObject，步骤还是声明和初始化。</p>

<p><strong>1、声明。</strong>找到声明部分，在已经添加的两个GameObject下面添加一个新的GameObject的声明，代码如下：</p>

<pre><code>GameObject missileLauncherHead = new GameObject();
</code></pre>

<p>代码很简单。</p>

<p><strong>2、初始化。</strong>找到LoadContent方法，在初始化另外两个GameObject的代码下面添加以下代码：</p>

<pre><code>missileLauncherHead.model = Content.Load&lt;Model&gt;(
    @"Modelslauncher_head");
missileLauncherHead.scale = 0.2f;
missileLauncherHead.position = missileLauncherBase.position +
    new Vector3(0.0f, 20.0f, 0.0f);
</code></pre>

<p>讲解一下：</p>

<ol>
<li><p>首先是载入asset，没有什么问题。</p></li>
<li><p>定义比例为0.2f，即和base一样。</p></li>
<li><p>下面初始化position的位置，实在原有的Base位置上加了(0, 20, 0)这样一个向量，意味着炮塔比基座升高了20。</p></li>
</ol>


<p>这里不妨先完成第三步，看看效果。不过按照之前的习惯，都是完成了逻辑代码之后再绘制的。（微软的工程师都是天才，囧）</p>

<p><img src="/images/uploads/zb/2009-07-07_151248.jpg" alt="" /><img src="/images/uploads/zb/2009-07-07_151225.jpg" alt="" /></p>

<p>不难看出变化吧～</p>

<hr />

<p><strong>第二步、加入输入控制</strong></p>

<p>这一步我们要让这个炮台可以被我们控制，方法很简单，和2D的非常的类似，如果你有2D基础那么就非常容易理解这个部分的内容了，如果没有我下面可能还会讲一下，你也可以回顾一下<a href="http://arthraim.cn/post/2009/06/65.html">2D教程</a>中相似的内容，讲解对应XBOX360手柄GamePad类的一些坐标系的说明。</p>

<p><strong>1、添加XBOX360的控制代码。</strong></p>

<pre><code>GamePadState gamePadState = GamePad.GetState(PlayerIndex.One);
missileLauncherHead.rotation.Y -=
    gamePadState.ThumbSticks.Left.X * 0.1f;
missileLauncherHead.rotation.X +=
    gamePadState.ThumbSticks.Left.Y * 0.1f;
</code></pre>

<p>GamePadState类用来获取手柄的操作情况，GamePad.GetState方法来决定获取哪个手柄的操作。因为XBOX360可以连接多个最多4个手柄，所以PlayerIndex这个枚举中分别由One,Two,Three,Four四个值，对应1P 2P 3P 4P手柄。</p>

<p>gamePadState.ThumbSticks.Left对应XBOX360手柄的左边的类比摇杆（传统游戏机上的方向键，microsoft用摇杆替代了方向键，顺应欧美玩家的习惯）。另外相对还有一个Right，当然是在右边。X轴决定左右，Y轴决定上下。</p>

<p>那么手柄的左右，决定了围绕Y轴（纵向轴）的旋转；上下决定了围绕X轴（横向轴）的旋转。还有个Z轴的旋转我们没有用到，如果是飞行模拟游戏里，一般左右控制Z轴，而另外L,R键来控制X轴。</p>

<p><strong>2、添加键盘的控制代码。</strong></p>

<pre><code>#if !XBOX
KeyboardState keyboardState = Keyboard.GetState();
if(keyboardState.IsKeyDown(Keys.Left))
{
    missileLauncherHead.rotation.Y += 0.05f;
}
if(keyboardState.IsKeyDown(Keys.Right))
{
    missileLauncherHead.rotation.Y -= 0.05f;
}
if(keyboardState.IsKeyDown(Keys.Up))
{
    missileLauncherHead.rotation.X += 0.05f;
}
if(keyboardState.IsKeyDown(Keys.Down))
{
    missileLauncherHead.rotation.X -= 0.05f;
}
#endif
</code></pre>

<h1>if和#endif之间表示如果不在XBOX情况下。</h1>

<p>其他代码非常的相似，0.05f是个幻数，其实表示了增加量。 这个值是固定的，使得用键盘操作和手柄操作产生了一些差别。</p>

<p>上下左右分别控制两个轴的变化，比手柄更易理解。</p>

<p><strong>3、限定旋转角度。</strong></p>

<p>炮塔的旋转不能任意，不太符合逻辑，所以要把它限定一下，使用MathHelper类，一样在2D教程中详细的讲解了这个类，从3D开始看教程的可以看一下<a href="http://arthraim.cn/post/2009/06/65.html">这篇文章</a>的第二步第3小节和末尾对角度的讲解。</p>

<p>这里要写的代码如下：</p>

<pre><code>missileLauncherHead.rotation.Y = MathHelper.Clamp(
    missileLauncherHead.rotation.Y,
    -MathHelper.PiOver4,
    MathHelper.PiOver4);
missileLauncherHead.rotation.X = MathHelper.Clamp(
    missileLauncherHead.rotation.X,
    0,
    MathHelper.PiOver4);
</code></pre>

<ul>
<li><p>第一次调用限定了rotation的Y轴，也就是左右的范围在-45度到45度之间。</p></li>
<li><p>第二次调用限定了rotation的X轴，也就是上下的范围在0度到45度之间。</p></li>
</ul>


<p>如果你添加了Draw部分的代码，那么现在已经完成了，没有添加，那就是我们下面要做的工作。</p>

<hr />

<p><strong>第三步、绘制炮台</strong></p>

<p>正如之前所说，非常简单的第三步，就是在Draw方法中插入一行代码，和之前的terrain和missleLauncherBase类似的代码。如果你是从第一步跳跃过来的，那么也一样，马上会有效果。</p>

<p>在另外两个GameObject的操作的下面插入代码：</p>

<pre><code>DrawGameObject(missileLauncherHead);
</code></pre>

<p>OK，编译、运行～</p>

<p><a href="/images/uploads/zb/2009-07-07_Runtime.jpg"><img src="/images/uploads/zb/2009-07-07_Runtime.jpg" alt="" /></a></p>

<p>大功告成，炮台可以旋转，并且在一定的范围之内了，试着变化这个范围DIY一下。</p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=161"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>特别说明：</strong>这段翻译，讲解了3D物体在游戏空间中的旋转情况，也就是pitch, yaw, roll三种情况。一样的，在翻译这三个单词的时候带来了一些困扰，权衡后决定翻译成您现在看到的样子，尤其是pitch不太贴切。</p>

<p>（以下文字翻译自XNA Creator Club网站，未经允许禁止转载。由于本人水平有限，所以有任何错误希望高手更正。）</p>

<p><strong>3D空间中的旋转：欧拉旋转</strong></p>

<blockquote><p>任意世界变换矩阵的一个重要组成部分就是旋转。旋转对应了一个对象相对于特定的轴的角度方向。</p>

<p>最终，一个物体的旋转将使用一个级联了&#8221;转换&#8221;（translation）矩阵和&#8221;比例&#8221;（scale）矩阵而约束的世界变化矩阵来决定。</p>

<p>我们在这个教程中使用的方法包括了一系列被叫做欧拉旋转的中间旋转。想象欧拉旋转为一系列的3个不同弧度的角，从0到2π，分别在不同的三个轴上。这些轴（X轴,Y轴,Z轴）可以被想象为低头、偏转、翻转轴（pitch, yaw and roll axes）。</p>

<p><a href="/images/uploads/zb/BG_4.6.2.1pd.png"><img src="/images/uploads/zb/BG_4.6.2.1pd.png" alt="" /></a></p>

<p>低头（picth），根据X轴测量，可以被想象为飞机头的方向向上或向下。</p></blockquote>

<pre><code>    偏转（yaw），根据Y轴测量，使得飞机从一边摆向（swing）另一边。

    翻转（roll），根据Z轴测量，可以想象为飞机翻向（banking）左边或右边。

    （英文中中西表述方式不同，难以理解，图片非常说明问题）
</code></pre>

<blockquote><p>在XNA Framework中使用欧拉旋转来创建世界变换矩阵中的旋转部分，使用Matrix.CreateFromYawPitchRoll方法，传入适当的旋转角度。它确定了一个你可以用来级联&#8221;转换矩阵&#8221;和&#8221;比例矩阵&#8221;的&#8221;旋转矩阵&#8221;，来确定最终&#8221;世界变换矩阵&#8221;。</p></blockquote>

<p><strong>补充说明：</strong>中西方人在操作上存在一些不同的习惯，（当然这不全是因为中西差异决定的，个别人之间也存在习惯的问题。）旋转的控制上也许会不同，所以很多游戏都设置了&#8221;反转X轴&#8221;，&#8221;反转Y轴&#8221;这样的选项。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-08T00:20:07+08:00" pubdate data-updated="true">Jul 8<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>

<nav id="pagenavi">
    
        <a href="/blog/page/13/" class="prev">Prev</a>
    
    
        <a href="/blog/page/15/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2012

    Arthur Wang

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'artorius';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>