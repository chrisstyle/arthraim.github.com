
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Artoirus</title>
	<meta name="author" content="Arthur Wang">

	
	<meta name="description" content="XNA教程 &#8211; 2D游戏 &#8211; 08 &#8211; 摧毁UFO 这一次要做的是很NB的事情，碰撞检测（Collision Detection），具体到我们的例子，具象一点的，那么就是摧毁UFO，当然在无数游戏中，碰撞检测都是至关重要的东西，和随机比起来不相上下吧。 &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Artoirus" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>

<body>
	<header id="header" class="inner"><h1><a href="/">Artoirus</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:artori.us">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:artori.us">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch8-destroy-ufo/">
		
			XNA教程-2D游戏-08-摧毁UFO</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 08 &#8211; 摧毁UFO</strong></p>

<p>这一次要做的是很NB的事情，碰撞检测（Collision Detection），具体到我们的例子，具象一点的，那么就是摧毁UFO，当然在无数游戏中，碰撞检测都是至关重要的东西，和随机比起来不相上下吧。无论是什么游戏类型，物体和物体之间的接触都是要处理的，尚且不说加上什么物理特性，光是这个例子里的子弹碰UFO总要有点反应吧。更不用说什么火星撞地球了………………</p>

<p>具体代码很简单，找到UpdateCannonBalls方法，在更新的时候，添加一种杀掉UFO和炮弹的情况，就是两者碰撞的时候。</p>

<p>大致的思路为：</p>

<ol>
<li><p>确定每个炮弹的范围大小和UFO的范围大小。</p></li>
<li><p>遍历每个炮弹。</p></li>
<li><p>遍历中每个炮弹再要遍历每个UFO。如果发生碰撞就同时摧毁两个（alive = false）</p></li>
</ol>


<p>这里我们要用到的碰撞检测，直接使用XNA的Rectangle的intersect方法。以下是代码，添加在判断是否出屏幕的下面。</p>

<pre><code>Rectangle cannonBallRect = new Rectangle(
    (int)ball.position.X,
    (int)ball.position.Y,
    ball.sprite.Width,
    ball.sprite.Height);
foreach(GameObject enemy in enemies)
{
    Rectangle enemyRect = new Rectangle(
        (int)enemy.position.X,
        (int)enemy.position.Y,
    enemy.sprite.Width,
    enemy.sprite.Height);
    if(cannonBallRect.Intersects(enemyRect))
    {
        ball.alive = false;
        enemy.alive = false;
        break;
    }
}
</code></pre>

<p>首先获得当前遍历到的cannonBall的范围，循环。循环中得到当前UFO的范围，检测是否和cannonBall相交（哪一方都一样）。碰撞了，就两个对象的alive都为false，然后break出UFO的循环。</p>

<p>执行结果（其实截图看不出来效果唉）</p>

<p><a href="/images/uploads/zb/2009-06-18_Chapter8Runtime.jpg"><img src="/images/uploads/zb/2009-06-18_Chapter8Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=155"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>翻译：使用Rectangle的2D碰撞检测</strong></p>

<p>（以下文字由本博客翻译自这里，转载请注明出处）</p>

<blockquote><p>图片创建的Sprite从一创建就必然是一个长方形。你可以使用遮盖(Mask)，来绘制Sprite中的一部分像素，这样就产生了Sprite不是一个长方形的视觉效果。Sprite可能呈现为一个圆形的物体，或者更加复杂的形状。但是所有的sprite一创建就都是矩形的。</p>

<p>Sprite的这一特性在非常基本的碰撞检测中很实用，XNA Framework提供了一个Rectangle类，自己就拥有碰撞帮助的方法：ectangle.Intersects，和Rectangle.Contains。</p>

<p>在基本的常识中，碰撞检测是基于相交检测的 &#8212;- 两块几何图形是否相交。如果两个几何图形相交，他们可以说是碰撞，游戏逻辑可以根据碰撞的物体产生适当的反应。</p>

<p>在我们的2D游戏中，我们关心加农炮是不是和地方UFO相交。如果加农炮的sprite的rectangle相交于敌人sprite的rectangle，那我们的游戏逻辑检测到了一个碰撞，并且同时摧毁两个物体。</p>

<p>Rectangle很容易创建。Rectangle类初始化时需要4个参数 &#8212;- 矩形左上角的点的X和Y坐标，以及矩形的宽度和高度。所有矩形的其他点都会有这些信息计算出来。</p>

<p>创建sprite占用的rectangle之间的碰撞，设置X和Y的值为游戏世界中的sprite的X和Y值，GameObject.position.X和GameObject.position.Y。设置宽度和高度为sprite中的Texture2D的宽度和高度，GameObject.sprite.Width和GameObject.sprite.Height。</p>

<p>凭借两种游戏直接中sprite的rectangle对象的创建和调用Rectangle.Intersects方法，你可以知道两个物体是否碰撞。这可能不是最精确的碰撞。包括还有其他的缺点，如果是屏幕上已经画了的一个旋转过的sprite，rectangle对象的定义就不再符合sprite在屏幕上绘制的样子了。然而这是一个简单高效的方法来做碰撞检测。</p>

<p>一个类似的有用的方法是Rectangle.Contains。在我们的2D游戏中，使用一个rectangle来表示整个屏幕，我们可以定义什么时候GameObject离开了屏幕的边界。我们在比较屏幕rectangle和对象rectangle的时候，使用检查Rectangle.Contains的值是否为false的方法来判断是否离开屏幕。</p>

<p>下面的图表列出了Rectangle.Intersects和Rectangle.Contains两个不同的矩形成员的不同输出情况。</p>

<p><img src="/images/uploads/zb/BG_3.8.1.1pd_a.png" alt="" /></p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-19T06:13:16+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch7-create-enemy-ufo/">
		
			XNA教程-2D游戏-07-添加敌人UFO</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 07 &#8211; 添加敌人UFO</strong></p>

<p>这次要做的就是添加敌人 &#8212;- UFO。我们有了一个防空武器，在一个可恶的看上去非常阴沉的外星球，那我们必须要有人来入侵，这才是建造军用设施的真正目的对吧。所以，程序员真是堪比创世纪的众神了。</p>

<p>加入UFO的方法其实和子弹差不多（记住这句话，因为我后面实在是懒得讲了），它需要它的初速度向量，需要被杀掉，最后需要画在屏幕上，如果稍微改一下，我们完全可以不看教程做到了。添加UFO还涉及到了一个新的概念，就是随机数，游戏中随机是非常重要的东西，几乎没有一个游戏不用到随机概念的，前段时间刚刚过了25岁生日的俄罗斯方块也是。随机，是游戏的灵魂，而我们将用到Random来产生随机数，再使用XNA提供的方法限定我们需要的范围。OK，开始吧。</p>

<p><strong>第一步、创建UFO</strong></p>

<p>我们要声明很多的变量，可能一时半会儿不会知道有什么用。一样的，找到你声明了其他东西的地方，加农炮啦，炮弹啦，手柄和键盘的状态啦之类的，Game类的首部，添加以下代码，代码如下：</p>

<pre><code>const int maxEnemies = 3;
const float maxEnemyHeight = 0.1f;
const float minEnemyHeight = 0.5f;
const float maxEnemyVelocity = 5.0f;
const float minEnemyVelocity = 1.0f;
Random random = new Random();
GameObject[] enemies;
</code></pre>

<p>似乎有很多不明所以的东西，来看看他们都是些什么。</p>

<ol>
<li><p>最大的敌人数，3个，好吧，我一定改了你。</p></li>
<li><p>最大敌人高度，0.1f，似乎可以想到。</p></li>
<li><p>最小敌人高度，0.5f，对啊，正如之前说到的，坐标系的Y轴是越上方越小。</p></li>
<li><p>最大敌人速率，5.0f，恩，敌人的速率是可变的，不错。</p></li>
<li><p>最小敌人速率，1.0f，最小的速度。</p></li>
<li><p>随机对象，一个Random对象，看来是创建随机数用的。</p></li>
<li><p>敌人数组，一个敌人的数组，和子弹一样，只是名字不同而已吧。</p></li>
</ol>


<p>这就是我们第一步完成的事情，之前说过，微软工程师都是强大的存在，可以预见未来，他们可以在刚刚开始写代码的时候就声明好所有将来需要使用的变量。当然，这是个笑话。</p>

<p>之后要初始化这些对象，载入enemy.tga资源。找到LoadContent的位置，在初始化cannonballs的循环下面添加一个for循环。记得之前怎么做的吗？如法炮制。</p>

<pre><code>enemies = new GameObject[maxEnemies];
for (int i = 0; i &lt; maxEnemies; i++)
{
    enemies[i] = new GameObject(
    Content.Load&lt;Texture2D&gt;(@"Spriteenemy"));
}
</code></pre>

<p>不麻烦吧，只是吧cannnonballs的名字换一下就是这里的代码了。继续。</p>

<hr />

<p><strong>第二步、更新UFO位置并杀掉屏幕以外的</strong></p>

<p>第二步做的是更新他们的位置，因为也是GameObject类，所以方法和cannonball一模一样。在Update方法中找到UpdateCannonBalls();这一行，在下面加入：</p>

<pre><code>UpdateEnemies();
</code></pre>

<p>说然后在类的其他任何地方加上我们的UpdateEnemies方法。</p>

<pre><code>public void UpdateEnemies()
{
    foreach (GameObject enemy in enemies)
    {
        if (enemy.alive)
        {
            enemy.position += enemy.velocity;
            if(!viewportRect.Contains(new Point(
                (int)enemy.position.X,
                (int)enemy.position.Y)))
            {
                enemy.alive = false;
                continue;
            }
        }
    }
}
</code></pre>

<p>真的，和CannonBalls一模一样，改一下名称，采用一样的杀掉的方法，这就是UFO移动，位置更新的代码了，目前为止没什么新的东西。</p>

<hr />

<p><strong>第三步、新生UFO</strong></p>

<p>和cannonballs不同，在做cannonballs的工作的时候，先让它射击出来，也就是在按键的一刻，之后在离开屏幕的一刻把它杀掉。而enemies在被处理的时候，是先在他离开屏幕的时候杀掉，可是它从没出现过。所以这一步，我们要让他出现。</p>

<p>要新生一个enemy的GameObject我们要给他一些属性，包括alive要变成true，这是肯定的。然后要给他一个初始的position，一个velocity速度向量，velocity包括了方向，和速率。（所以我始终觉得speed更好）。</p>

<p>然后就是决定，什么时候创建它。它在离开屏幕的时候会死去，那么我们就在它死去之后马上把它救活，所以我们找到上一步的UpdateEnemies方法，在if(enemy.alive){}的后面，加上enemy.alive == false的代码，让它死掉马上活过来，并出现在屏幕的右方。</p>

<pre><code>if (enemy.alive)
{
    // ...其他代码
}
else
{
    enemy.alive = true;
    enemy.position = new Vector2(
    viewportRect.Right,
    MathHelper.Lerp(
        (float)viewportRect.Height * minEnemyHeight,
        (float)viewportRect.Height * maxEnemyHeight,
        (float)random.NextDouble()));
    enemy.velocity = new Vector2(
    MathHelper.Lerp(
        -minEnemyVelocity,
        -maxEnemyVelocity,
        (float)random.NextDouble()),
        0);
}
</code></pre>

<p>看看我们做了什么。</p>

<p>enemy.alive = true; 没错，这是出生证明，起码在某些程度上说明了它活过来了。</p>

<p>enemy.position = new Vector2(); 这当然是给他位置向量，初始化向量要X坐标Y坐标，那X坐标就是屏幕右侧，X轴最大值，viewportRect记录了屏幕大小，调用viewportRect的Right属性，就是我们要的屏幕宽度，也就是X轴最大值。而Y坐标，我们要随机产生一个高度，这样才有游戏的味道。首先，我们用random.NextDouble随机生成一个0到1之间的double类型的随机数，这就是我们得到随机数的方法。但是，它不是我们要的数字，我们需要一个高度差之间的，而不是0到1的。于是这里要讲一下MathHelper.Lerp方法，它需要3个参数，随机数的最小值，随机数的最大值，和随机数。我们使用这个方法，把我们随机产生的那个书限定到我们给的新范围里。其实做法很简单，相信大家都可以写出来，(最大值-最小值)×随机值+最小值，这得到了我们的这个数，不过XNA帮你省去了这些代码（真是细致的过分了 = =），直接帮助得到我们的数。</p>

<p>enemy.velocity = new Vector2()，一样的，也是产生一个新的向量。因为要他笔直的从右往左穿过屏幕，那Y方向没有速度，Y给个0就好了。X则是要随机在我们定下的范围里得到一个数字，方法和position的类似，只是要注意的是，因为我们逆X轴正方向飞行，所以X轴速度是负数。</p>

<p>至此，完成了UFO的全部的Update工作。</p>

<hr />

<p><strong>第四步、绘制UFO</strong></p>

<p>嘿嘿，一样，最后我要画UFO。找到Draw方法，加入一个新的SpriteBatch.draw就可以了。因为UFO不会和加农炮碰撞，所以无论放在背景以上的什么层面都好，只是我觉得起码应该遮掉子弹吧～于是添加代码，又是和cannnonballs一样。</p>

<pre><code>foreach (GameObject enemy in enemies)
{
    if (enemy.alive)
    {
        spriteBatch.Draw(
        enemy.sprite,
        enemy.position,
        Color.White);
    }
}
</code></pre>

<p>We&#8217;re done here. 运行一下看看效果。（我修改了同屏敌人数，因为我的子弹改成是10 = = 并且我发现我的子弹是可以打成一张网的，这游戏没意思了）</p>

<p><a href="/images/uploads/zb/2009-06-16_Chapter7Runtime.jpg"><img src="/images/uploads/zb/2009-06-16_Chapter7Runtime.jpg" alt="" /></a></p>

<p>画面不错。OK，下一次就是要真的用子弹杀掉敌人了～</p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=154"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>第三步的补充内容翻译。</strong></p>

<p>这段文字详细讲解了Lerp方法的成因，作用，实现方式，用法，好处等等，可以说非常的详细。</p>

<p>但我个人其实非常不理解，首先我非常不理解为什么（最大值-最小值）×随机值+最小值 这样一个计算就可以完成的事情一定要封装到framework里，虽然那个类的名字叫MaxHelper。另外不理解的地方就是为啥还要用这么多的文字来说明，看了就知道，它用了很多文字来说为什么0到1之间的数可以转化为一个范围内的数，还打了从一个数轴映射到另一个数轴的例子。</p>

<p>只是觉得很有意思而已，美国人做事情有些德国人的味道。看文字吧。</p>

<blockquote><p><strong>随机数和线性插入</strong></p>

<p>在游戏中，随机事件会添加更多的曲折。从随机出现在随机位置的玩家或敌人，到一定几率出现的奖励道具，随机事件可以保持一个游戏的挑战性和乐趣。</p>

<p>怎么才能让你使用一个随机数字来创建随机事件呢？</p>

<p>Microsoft® Visual C# 2005 Express Edition和Visual Studio 2005的包含的标准库中提供了一个实用的类&#8212;-System.Random类。它可以被实例化，也可以生成特定最大范围内的随机整数，或随机生成0到1之间的双精度小数。</p>

<p>乍看之下，产生一个随机证书似乎更管用。在某些情况下，它很管用。举个例子，随机访问你的数组索引，你需要一个整数。但是2D游戏中的数是浮点数，这意味着，他们拥有小数部分。我们需要一些不是严格的整数的数值。打个比方，5到10之间产生一个随机速率。如果我们只是用5到10之间的整数，只有6中可能的数值，这使得速率间的差异性看上去不是那么随机。</p>

<p>一个双精度浮点数之给我们更多范围内数据的变化，使可以转化为更多各种各样的表现。这非常美妙，特别是当我们屏幕上有很多对象拥有不同的位置和速度的时候。</p>

<p>然而，我们的Random类只返回0到1之间的双精度浮点值，或称为double类型的值，却对我们要随机获得5到10之间的数字不怎么实用。你当然可以做一些必要的乘法和加法来让0到1之间的数适应5到10之间这个范围，但是XNA Framework提供了更加简单的方法 &#8212;- MathHelper.Lerp。</p>

<p>Lerp是linear interpolation（线性插入）的缩写，一个数学方法，提供它一些0到1之间的数值T，并提供给它最大值和最小值，它可以计算出一个最大值和最小值之间的输出T。</p>

<p><img src="/images/uploads/zb/BG_3.7.3.1pd.png" alt="" /></p>

<p>把它想象成是在一个最小值和最大值之间的数轴上决定位置，而T是从开始的0到1之间的一条数轴上的某个位置。如果T是0.75，它应该在数轴范围的3/4的位置，在5到10的数轴上就是8.75。照着这个方法，一个0到1之间的数值可以用来在两个浮点数之间找到一个对应的浮点数。</p>

<p>Lerp方法可以用在游戏中需要以恒定速率增加或减少的任何东西。速率、动画、淡出效果或变换颜色 &#8212;- 简简单单传入一个0到1之间的数值T，一个最小值，一个最大值，Lerp会完成之后的所有事情。</p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-16T19:24:54+08:00" pubdate data-updated="true">Jun 16<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch6-launch-missiles/">
		
			XNA教程-2D游戏-06-发射炮弹</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 06 &#8211; 发射炮弹</strong></p>

<p>之前已经完成了很多的工作，创建了GameObject类，实例化了加农炮，并且在屏幕上画出了背景和加农炮。而且加农炮已经拥有了Update的代码，即玩家可以控制这个加农炮了。只是，距离我们的要求，这还远远不够，我们的子弹在哪里呢？加农炮打出来的炮弹呢？没错这就是这一次要完成的。我们要创建能被你发射，并且按方向穿过屏幕的炮弹了。</p>

<p>这一次的工作可谓相对有些复杂了，无论是代码量，还是概念，还是数学知识的要求都有了一定的提升。不过不用慌，我们还是跟着视频一点一点的做下来，最终我们一定能理解只是，并且做好这个东西的。OK，直接进入正题。</p>

<hr />

<p><strong>第一步、修改GameObject</strong></p>

<p>之前说过了GameObject的作用，是用来实例化不同的游戏对象的，那么他的模型应该够健壮，能够实例化各种各样的现实对象。按照我个人的习惯，当然是一个对象一个类，不过既然视频是这么处理，还是跟着做。这里我们要做的很简单，找出之前的GameObject类，我们要添加两个成员变量。</p>

<p>速率：这个速率是指炮弹具有的速度，拥有了这个速度，我们才能慢慢的把它平滑的在画面上移动。不理解没关系，先看下去。</p>

<p>生存：是否生存，我的炮弹如果出了屏幕，那么它就已经消失了，或者说死了，所以这里有个boolean类型的值记录生存或死亡。</p>

<p>当然，这个类也会生成cannon，所以这里可以看一下，加农炮的速率是什么？速率是位移 / 时间，我们的加农炮只有旋转没有位移，很好就是0。再看生存，死亡，它应该一直存在，所以一直是true就好。那么接下来看代码。</p>

<p>先声明。</p>

<pre><code>public Vector2 velocity;
public bool alive;
</code></pre>

<p>然后在构造方法里初始化。</p>

<pre><code>velocity = Vector2.Zero;
alive = false;
</code></pre>

<p>好了，这就是我们要在第一步里完成的全部工作，不用疑惑，接下去做，就知道会发生什么了。</p>

<hr />

<p><strong>第二步、创建Cannonball数组</strong></p>

<p>这里我们要完成的工作是建立一个数组，放上所有可能被发射的炮弹的GameObject，然后把它们初始化。</p>

<p>首先找到Game1.cs，你创建背景和Cannon的地方，在那些代码下面声明两个新的东西。</p>

<pre><code>const int maxCannonBalls = 3;
GameObject[] cannonBalls;
</code></pre>

<p>解释一下，第一个带有const修饰符的是一个常量，maxCannonBalls。意思很明白，就是屏幕上最多出现的子弹数，因为子弹过多会使得update拖慢，那么能进行的draw就很少，所以一上来我们定义成3比较安全。如果过多，可以想见，会出现一帧一帧很卡的效果，像幻灯片一样。而如果加入了一些安全机制，那么就变成了跳帧现象，就是不再计算和绘制。之后一个GameObject[]的数组，就是放无数GameObject用的，至于放多少，是看初始化的。好吧，下面看初始化代码。</p>

<p>找到LoadContent方法，在cannon的相关后面加上以下代码。</p>

<pre><code>cannonBalls = new GameObject[maxCannonBalls];
for (int i = 0; i &lt; maxCannonBalls; i++)
{
    cannonBalls[i] = new GameObject(Content.Load&lt;Texture2D&gt;(
        @"Spritescannonball"));
}
</code></pre>

<p>如果你熟悉C#的话看懂这个没问题，无非就是循环一下，初始化一下。其实用List&lt;>的效率肯定要高一下。但是这里是不可以使用foreach的，因为foreach肯定要求所有的对象都已经实例化了，而我们的工作就是在实例化这些对象。恩，其实这一步已经完成了，这些代码和载入其他Content都是类似的，只是这里遍历了3次而已。下一步吧！</p>

<hr />

<p><strong>第三步、更新cannonball的位置</strong></p>

<p>这一步要更新cannonBalls的每一个ball的位置，当然这里就要用到我们的速度了。只要每一次更新的时候，都加上速率值（一个向量，叫速度更合适，速度是有方向的速率没有），那么它就会自动更新到新的位置了，如果在这个时候把它画出来，就可以看到它在一帧一帧的变换中变换着自己的位置，平滑的移动了一条直线（或其他轨迹，取决于速率或者更像是速度的这个值）。我们把要更新的代码分出一个方法来，叫做UpdateCannonBalls()，如果你坚持，也可以把它们写在Update的方法里，谁都没有强制你。看代码：</p>

<pre><code>protected override void Update(GameTime gameTime)
{
    //...Other code
    UpdateCannonBalls();
    base.Update(gameTime); //必须在这一行代码之前
}
public void UpdateCannonBalls()
{
    foreach (GameObject ball in cannonBalls)
    {
        if (ball.alive)
        {
             ball.position += ball.velocity;
        }
    }
}
</code></pre>

<p>上面是Update方法里的修改，其他代码不去管它，在base.Update(gameTime);之前加上就好。至于下面的方法，就是更新了，放在Game1类中的任何位置都是没有关系的，只要是别的方法的外面，Game类的里面。这里采用了foreach的方法，每一次做一个校验，如果还alive，活着，那么就给他的位置加上速度向量。没错就是这个逻辑。这一步就是这样子。</p>

<hr />

<p><strong>第四步、发射cannonBall</strong></p>

<p>这一步要完成的工作就是发射炮弹了，要知道我们的初始向量才是关键。当然，要知道按键的那一刻，才能确定初始向量。那么首先要做的就是确定按键的相关操作。这里我们需要先声明两个变量。</p>

<pre><code>protected override void Update(GameTime gameTime)
GamePadState previousGamePadState = GamePad.GetState(PlayerIndex.One);
KeyboardState previousKeyboardState = Keyboard.GetState();
</code></pre>

<p>它们会被用来记录上一次Update时候的按键状态，这是为什么呢？看下面的代码。它们中，第一个if语句被添加在Update方法中，你之前完成的cannon.rotation += gamePadState.ThumbSticks.Left.X * 0.1f;这一行的后面。而第二个if语句，放在#if !XBOX和#endif之间的区域内，#endif的上方就可以。当然其实顺序并不是那么重要。</p>

<pre><code>protected override void Update(GameTime gameTime)
if (gamePadState.Buttons.A == ButtonState.Pressed &amp;&amp;
    previousGamePadState.Buttons.A == ButtonState.Released)
{
    FireCannonBall();
}
if (keyboardState.IsKeyDown(Keys.Space) &amp;&amp;
    previousKeyboardState.IsKeyUp(Keys.Space))
{
    FireCannonBall();
}
</code></pre>

<p>解释一下，第一个if是用来检查是否按下X360的手柄上的A键。上一次没有按键，而这一次按键的情况下，即刚刚按键的一刹那，我们实施FireCannonBall()这个方法。而连续按住则不会连续的出发这个方法。另外一个if则是键盘的操作，一样的，只有按下键盘上空格键的那一刹那才会触发。这是操作，究竟触发了，调用了FireCannonBall这个方法要做什么，来看它的实现。</p>

<pre><code>public void FireCannonBall()
{
    foreach (GameObject ball in cannonBalls)
    {
        if (!ball.alive)
        {
            ball.alive = true;
            ball.position = cannon.position - ball.center;
            ball.velocity = new Vector2(
                (float)Math.Cos(cannon.rotation),
                (float)Math.Sin(cannon.rotation)) * 5.0f;
            return;
        }
    }
}
</code></pre>

<p>来分析下代码，首先，我们遍历三个ball，因为最多只有3个，所以用这样的方法就好了（否则应该加上索引什么的，这里不讨论算法），看哪个球还活着，哪个球死了，只有死了的炮弹，我们才能让他再一次活过来，否则就要等到它死掉为止。那么显然，if(!ball.alive)校验后，留下来的就是可以活过来的炮弹，于是我们让他活过来。</p>

<ol>
<li><p>首先设置它的alive属性为ture，证明它活过来了。</p></li>
<li><p>然后设置初始化的位置，是加农炮的位置减去炮弹的中心向量。（这个也许视频里直接ball.position = cannon.position了，那样子会错位）</p></li>
<li><p>然后要设置它的速度了，方向就是当前加农炮的角度，Cos(A)和Sin(A)计算出单位1的向量确定方向，然后乘上5倍使它得到速率。这样一个速度就初始化完成了，这样每一个炮弹会沿着加农炮发射的方向前进而不管你后面的，前面的炮弹如何。至于数学计算，后面会翻译相关资料说明。但其实很容易理解，画个半径为1的圆，然后连成一个三角形，用Sin,Cos就很容易理解了。数学知识。</p></li>
</ol>


<p>还有一个重要的步骤，就是我们还需要让每一次Update后，把当前的键盘（或手柄）状态存入为上一次的键盘（或手柄）状态。代码只有两行。那个标记就不用再多做什么解释了吧，键盘的操作都包含在这个标记里，只是这次我们要重新写一个而已。把这个代码紧贴着base.Update(gameTime);的上方就可以了。</p>

<pre><code>previousGamePadState = gamePadState;
#if !XBOX
previousKeyboardState = keyboardState;
#endif
</code></pre>

<p>这样，我们炮弹的发射就做完了，每一次按键，就会把已经死掉的炮弹重新发射出来，否则就不发射。很容易理解～下一步还没有画，我们要把发出去的杀掉，否则不是我们整个游戏从头到尾只能发射三次吗？</p>

<hr />

<p><strong>第五步、杀掉cannonball</strong></p>

<p>就像刚才说的，游戏从头至尾只能发3个炮弹就太可怕了，它们按照牛顿惯性定律按照初速度朝着遥远的宇宙和未来飞去了。所以，我们要在它们飞出屏幕看不见的那一刹那，就把它们杀掉，资源回收～ 当然杀掉的策略可以有很多，比如碰撞了什么东西（比如将来的UFO），比如限定一定的时间，比如我们使用的飞出屏幕。因为飞出屏幕最符合逻辑，且只需要我们已经定义的这些信息就可以实现，所以采用这个策略。</p>

<p>在UpdateCannonBalls这个方法里，找到ball.position += ball.velocity;这一行，在其后面加上如下代码：</p>

<pre><code>if(!viewportRect.Contains(new Point(
    (int)ball.position.X,
    (int)ball.position.Y)))
{
    ball.alive = false;
    continue;
}
</code></pre>

<p>翻译成中文就是：如果ball所在的位置，转换成一个点，且这个点没有包含在代表了整个屏幕大小的矩形viewportRect当中，那么就把alive改成false，换言之杀掉它。杀掉后继续循环，生怕还有别的一起死掉而漏掉了。</p>

<p>很清晰很明白，就这么简单的三行代码，我们把飞出屏幕的炮弹杀掉了。OK，接下去最激动人心的时刻就要到了。话说微软的教程还真奇怪，一般自己写游戏都会是加一点逻辑，画一点逻辑的吧，他这个逻辑也太强了，全部想明白了再画，多辛苦啊。当然人家肯定是现成有了代码才这么干的吧。</p>

<hr />

<p><strong>第六步、画出cannonball</strong></p>

<p>要画出这写炮弹，当然就是跑到Draw方法里面去了，有了之前的经验，我们应该很容易画。只是要注意的是画完背景先画炮弹，再画炮，这样感觉炮弹是从炮筒里出来的，不然很傻哦。</p>

<pre><code>foreach (GameObject ball in cannonBalls)
{
    if (ball.alive)
    {
        spriteBatch.Draw(
        ball.sprite,
        ball.position,
        Color.White);
    }
}
</code></pre>

<p>OK这就是绘制的代码，现在编译运行一下看看效果吧。（在我运行之后感到非常不满足，于是我把子弹数字稍微的改了一下，截图如下，嘿嘿～）</p>

<p><a href="/images/uploads/zb/2009-06-15_Chapter6Runtime.jpg"><img src="/images/uploads/zb/2009-06-15_Chapter6Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=153"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>翻译一、使用数组</strong></p>

<p>这是属于第二步的信息，教你使用数组，属于C#语法范围，其实没有什么特别的意义。权且翻译在这里。（以下翻译由本人翻译自<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/details/6_2">这里</a>，未经允许请勿转载，转载请注明译者及翻译出处）</p>

<blockquote><p>教程到目前为止，你已经能熟练的使用一些预定义的类，并且为了能封装一些有规律的使用的数据，能创建一些自己的类了。</p>

<p>但是还有另外一种数据组织形式你需要知道并且学会使用。你也许需要使用大量相似的对象或足够相似的对象，事实上，它们都是同一类型的类。它们可能是GameObject，Texture2D对象，也可能是其他对象。你需要一些这样的对象，并且希望有一个相似的操作方式来操作它们。</p>

<p>例如，如果你有一组要绘制到屏幕上的GameObject对象，并且他们中的每一个都有自己的位置和Texture2D，你为他们每一个写的代码都会是完全相同。虽然目前是这样，但是你还是会要写一些一样的代码来处理每个 GameObject，使你的代码变得混乱。有什么办法只需简单的让对象的集合运行一样的代码，并且可以让每一个都拥有同样方式的互动呢？</p>

<p>有 &#8212;- 解决方案就在于数组。一个数组是一个相似对象的线性集合。你可以拥有一个人和类型的数组；一个Vector数组，一个GameObject数组，一个字符串数组，或者其他任何可能并且合法的数组。</p>

<p><img src="/images/uploads/zb/BG_3.6.2.1pd.png" alt="" /></p>

<p>这张图显示了创建有3个GameObject元素的数组的代码顺序。你使用表明数组元素类型的类型名之后加上[]来声明一个数组。之后你使用new和[x]来初始化数组，x是你数组元素的数量。</p>

<p>如果数组中的数据类型为一个类，你必须循环遍历这个数组并且初始化每一个数组元素存储的对象。</p>

<p>一旦完成这些工作，你可以使用数组名加上[x]的方式访问数组中的每个元素，x代表了你要访问的元素，0开始代表第一个元素。因为这个指数的开始是0，调用cannonBalls[1].position会给你数组中第二个GameObject对象的position变量。</p>

<p>一个更加强大的方式来访问数组是循环，在上面的图中已经表现出来。一个for循环允许你针对所有数组中的元素运行相同的代码。你也可以使用一个foreach循环，它将被在后面的步骤中表现出来。两种方法都允许你让多个同类元素运行相同的代码。这也帮助你对已写代码的重用，而不用写更多的代码，即便数组的大小在今后得到扩展。</p></blockquote>

<p><strong>翻译二、转换一个旋转角度为速度向量。</strong></p>

<p>这是属于第四步的信息，属于数学知识，可以帮助不懂这个数学原理的朋友理解那部分代码，翻译在这里。（以下翻译由本人翻译自<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/details/6_4">这里</a>，未经允许请勿转载，转载请注明译者及翻译出处）</p>

<blockquote><p>学会这个教程的重点，你已经学会了采用弧度来传递旋转角度。然而，发射炮弹的动作需要我们使用Vector2来传递cannonball的动作。</p>

<p>Cannonball的动作应当和加农炮的角度有联系 &#8212;- 当你的加农炮转到垂直向上，你的炮弹应该垂直向上飞。同样的，当你的加农炮转到平行于地面的位置，炮弹应该平行于地面飞行。</p>

<p>来做出确定这个数据的唯一方法就是通过加农炮旋转角度的弧度。显然，你必须做一些转换工作，把旋转角度转换为给予炮弹的向量。</p>

<p><img src="/images/uploads/zb/BG_3.6.4.1pd.png" alt="" /></p>

<p>一个Vector2有两个组成部分：X坐标和Y坐标。在这个2D游戏的最终目标中，炮弹的X坐标在横轴上有怎样的动作，炮弹的Y坐标在纵轴上也有怎么样的动作。</p>

<p>在三角中，有个灯饰我们可以用来从一个角构造成一个vector。在如图所示的单位圆中，任何一个向量V可以被想象为拥有特定的从0开始的角θ。这个角度相当于我们想法中的旋转角度。为了得到向量V，也就是炮弹的速度向量，我们尝试着去发现，你可以使用下面的规则从θ中得到X和Y.</p>

<p>V = (cos(θ), sin(θ))</p>

<p>这些数学方程式,sine和cosine,代表任何一个有θ大小的角的X和Y的数据。为了构造一个2D向量,你只需要知道X和Y.所以sine和cosine方程就是我们想要的.向量的X坐标是cos(θ)，而向量的Y坐标是sin(θ)。</p>

<p>一个向量的方向使用Y和X坐标的关系来表现。（成为斜度）但是向量也具有幅度。从我们的炮弹上说，它决定了多快的速度来接近向量所指向的方向。在我们的代码中，我们使用一个常数去乘向量的方式来增长这个幅度。它同时使用相同的值去乘了X和Y坐标，确保斜度不变，但向量变得更长了 &#8212;- 这样，炮弹移动加快了。</p></blockquote>

<p>That&#8217;s all, finished~ Good luck ;)</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-15T19:23:44+08:00" pubdate data-updated="true">Jun 15<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch5-create-a-cannon/">
		
			XNA教程-2D游戏-05-添加一门加农炮</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 05 &#8211; 添加一门加农炮</strong></p>

<p>来到第五章，这一次要完成的是：建立一个类掌握你所有的游戏数据，并建立你第一个Game Object（游戏对象？还是不翻译比较好）&#8212;- 一个用户控制的加农炮，使用Xbox360手柄或者是PC键盘作为输入。完成了这一次的事情，整个程序就有交互了，就更加接近一个游戏了，其实游戏说穿了不就是一个有交互的幻灯片吗。</p>

<p>之前我们做过的东西都是一样的，所以这里就直接开始说真正的步骤了。直接看到此文的同学，相关文章里面应该可以找到之前的那些文章，从第一篇开始看吧，我想等我写完之后，会整理一个目录出来的。</p>

<p>在做所有的工作之前，我们要了解一个概念，就是屏幕的向量。一般做其他游戏的时候，包括direct3D也一样，屏幕的坐标是左上角的点为原点的。X轴正方向在朝右边，而Y轴正方向朝向下边。但是在XNA中也是这样。另外，角度却不是这个坐标系，而是右边是X轴正方向，上边才是Y轴正方向，原点因为是角度当然就无所谓了。这是说明，请大家不要被positon和rotation采取不一样的坐标系而搞混了。</p>

<p><strong>第一步 &#8212;- 建立我们的GameObject，在Game中添加这个GameObject</strong></p>

<p>GameObject是什么，究竟为什么要添加这么一个GameObject在说完具体的代码方法之后我会说，先讲直接上手的东西，因为可能有人对于概念不太感冒。我们要做的工作的前提是，你已经成功的画上了背景，那么接下去我们要加上的加农炮，让我们先添加一个GameObject吧</p>

<p><strong>1、添加GameObject</strong></p>

<p>首先就是要新建一个类，作为GameObject，具体的步骤如下。</p>

<p><strong>1.1、新建一个类。</strong>（中文版不好意思啦）</p>

<ul>
<li><p>右键单击你的Project选择Add中的New Item。（这里也可以直接选择Add，New Class）</p></li>
<li><p>选中class，然后输入类的名称，方便讲解所以和视频一样，取名为GameObject.cs，确认。</p></li>
</ul>


<p>（如下图，点击放大）</p>

<p><a href="/images/uploads/zb/2009-06-14_AddGameObject.jpg"><img src="/images/uploads/zb/2009-06-14_AddGameObject.jpg" alt="" /></a></p>

<p><strong>1.2、添加引用。</strong></p>

<ul>
<li>复制所有Game1.cs（如果你没改名字的话）的上面的using到新建的GameObject.cs文件的头部，OK</li>
</ul>


<p><strong>1.3、添加属性。</strong></p>

<p>虽然个人认为还是添加为属性比较好，不过这里全都是用了Public的成员变量，那么权且这么用着，不讨论工程范畴的事情了。代码如下。</p>

<pre><code>public Texture2D sprite;
public Vector2 position;
public float rotation;
public Vector2 center;
</code></pre>

<p>分别是一个Texture2D，我们全部要画的图像信息；Vector2，物体的具体位置；float，旋转的角度；Vector2，旋转中心的位置。有了这些信息，基本上一个2D游戏里能用到的物件的所有信息都在了，起码一个加农炮都在了。</p>

<p><strong>1.4、添加方法。</strong></p>

<p>这里我们只需要添加一个构造方法。代码如下：</p>

<pre><code>public GameObject(Texture2D loadedTexture)
{
    rotation = 0.0f;
    position = Vector2.Zero;
    sprite = loadedTexture;
    center = new Vector2(sprite.Width / 2, sprite.Height / 2);
}
</code></pre>

<p>传入一个Texture2D作为GameObject中的Texture2D sprite，并且初始化角度为0，位置为0，旋转中心为sprite的中心点。中心点可不是一定的，看下图，我们的中心点刚好是Sprite的二分之一高度二分之一宽度的地方，如果不是，那么要根据具体情况重新决定。</p>

<p><a href="/images/uploads/zb/2009-06-14_OriginalCannon.jpg"><img src="/images/uploads/zb/2009-06-14_OriginalCannon.jpg" alt="" /></a></p>

<p><strong>2、在Game1中载入加农炮。</strong></p>

<p>之后要在Game1中用到刚才的GameObject，并且把它初始化成加农炮。那么我们来吧，具体步骤如下。</p>

<p><strong>2.1、声明一个GameObject。</strong></p>

<p>在Game1.cs中，你声明了backgroundTexture的位置的附近加上新的声明代码，声明一个GameObject并且命名为cannon，这就是我们的加农炮了，具体代码如下。</p>

<pre><code>GameObject cannon;
</code></pre>

<p><strong>2.2、加载Content资源，并初始化位置。</strong></p>

<p>和背景的方法一样，让它读取我们的cannon.tga就好了，在Content Pipline中被自动命名为cannon（去掉后缀）的就是了。同样在你添加背景的LoadContent()方法，加入以下两行代码，载入资源，并把加农炮的初始位置放在距离屏幕右侧120像素，距离屏幕底端80像素的位置。</p>

<pre><code>cannon = new GameObject(Content.Load&lt;Texture2D&gt;(
    @"Spritescannon"));
cannon.position = new Vector2(
    120, graphics.GraphicsDevice.Viewport.Height - 80);
</code></pre>

<p>至此，第一步就做完了，我们已经实现并且实例化了一个GameObject，并且把实例化的GameObject整成了cannon加农炮放到了需要的位置上，接下去就可以加入相应对它的操作了。</p>

<hr />

<p><strong>第二步、添加玩家的控制，是加农炮可以旋转</strong></p>

<p>我们会使用Gamepad类和Keyboard类分别来接受Xbox360的手柄和PC键盘的控制。另外，我们用到一个MaxHelper类来实现简单的工作，而避免添加过多繁杂的代码。要做的依然很简单，所有的代码都在Update这个方法中完成，所以你只要找到Update方法，并且把代码加入到// TODO: Add your update logic here附近base.Update(gameTime);之前就好了。</p>

<p><strong>1、添加Xbox360手柄的控制。</strong></p>

<p>这个步骤相当的简单，我们可以看到在Update前部已经加上了一个类似的控制，就是为了使得游戏可以在Xbox360中退出的，可以关注一下它的实现，至于我们这里怎么做还要稍微讲一讲。</p>

<pre><code>GamePadState gamePadState = GamePad.GetState(PlayerIndex.One);
cannon.rotation += gamePadState.ThumbSticks.Left.X * 0.1f;
</code></pre>

<p>如果你无视360，那么请直接看2好了，不过这里要稍微对这个代码解释一下。</p>

<p>GetState(PlayerIndex.One)是获取的操作是第一个玩家。因为采用无线手柄，所以X360会对玩家的手柄进行排序，最多四个玩家，也就是最多接4个手柄，分别为PlayIndex这个枚举类型下的One Two Three Four。这里也就是说默认的操作全部来自于One，就是所谓的1P，第一个玩家。</p>

<p>ThumbStick.Left就是XBOX左侧的类比遥感，这个东西不是简单的上下左右就好了，它是矢量的，就是说你打左的程度也会成为控制的一个信息，而不是简单的boolean。那么在这里的代码是怎么回事呢？首先，你要知道，ThumbSticks.Left.X这是一个Vector2（也重载了其他情况比如Vector3），也就是一个向量，相当于把摇杆所在的范围看作一个坐标系。这样一来这行代码的意思就非常的明显了，往左的程度越多×0.1f，加到角度（旋转角度也是一个向量）上，那么越往左就是越往逆时针旋转。这样理解下来的话，这句话的意思也可以写成：</p>

<pre><code>cannon.rotation -= gamePadState.ThumbSticks.Right.X * 0.1f;
</code></pre>

<p>这样其实我们控制的效果和键盘是不一样的，也就是说扳动类比遥感的角度越大，旋转速度就会越大。</p>

<p><strong>2、添加PC键盘的控制。</strong></p>

<p>相对于XBOX，这里的代码量要稍微多一点，不过反而好理解一点。只要读取左右按键是否按下，按下就相应的产生操作就好了。因为update是每一帧都会来读取的内容，所以虽然一次只读键盘一次，但是其实一直按住的连续操作也是会被接受的，不理解的朋友可以留言，因为初学者可能不知道update和draw两个方法在游戏主循环里会不停的调用的。代码如下：</p>

<pre><code>#if !XBOX
KeyboardState keyboardState = Keyboard.GetState();
if(keyboardState.IsKeyDown(Keys.Left))
{
    cannon.rotation -= 0.1f;
}
if(keyboardState.IsKeyDown(Keys.Right))
{
    cannon.rotation += 0.1f;
}
#endif
</code></pre>

<p>注意一下#if和#endif之前的代码，!XBOX的意思就是如果不是XBOX360的话，就会在编译的时候编译这一段代码，否则就不编译了，因为360是没有键盘的哦。</p>

<p>代码没有什么特别值得解释的东西。如果按键被按下，是左边就减去向量角度，是右边就加上向量角度。</p>

<p><strong>3、限制加农炮旋转角度。</strong></p>

<p>已经对加农炮的旋转进行了操作，可是还存在什么问题么？是的，现在我们的加农炮是可以360度回旋的，转啊转啊大风车一样，可是我们只能让他转在朝着屏幕右上角的90度里面怎么办？很简单，利用XNA提供的一个MathHelper类。名字取得很好听，&#8221;数学助手&#8221;，如果数学不过关那么就用它吧。不过这里我们只是限定一个范围，那么其实用if也完全可以完成，MathHelper帮我们减少了代码量，功德无量啊。代码也很简单，一行：</p>

<pre><code>cannon.rotation = MathHelper.Clamp(
cannon.rotation, -MathHelper.PiOver2, 0);
</code></pre>

<p>加农炮的旋转角度来接收返回值。返回值一定不是最大值就是最小值了吧。</p>

<p>看看MathHelper.Clamp传入了什么？</p>

<ul>
<li><p><strong>第一个参数</strong>：需要被限定的变量，那么我们要限定的就是加农炮的旋转角度 &#8212;- cannon.rotation。</p></li>
<li><p><strong>第二个参数</strong>：最小值，我们旋转角度的最小值。显然，我们传入的最小的是-MathHelper.PiOver2，这有点像个宏，其实是MathHelper的另一个重要功能，帮我们记录一些常数。PiOver就是90度，Pi/2，这个学过向量应该知道，不知道的就可以补习数学去了。（下文会对这个东西详细的讲解）</p></li>
<li><p><strong>第三个参数</strong>：最大值，就是0，就是说它最大的旋转角度在0，也就是水平线往右，X正方向，这个角度就可以了。</p></li>
</ul>


<p>至此，我们第二步的工作就宣告完成了～ 接下去就是最令人兴奋的部分了，把我们已经加载的，并且可以操作的加农炮显示到屏幕上，把它画出来！其实我们它已经存在了，只是我们还看不见，所以，第三步就是让我们看见他！</p>

<hr />

<p><strong>第三步、绘制加农炮</strong></p>

<p>无聊了，看了这么久写了这么久为什么运行的时候都不变？当然，因为没有画出来啊，接下来就是要在Draw方法里画了，方法也异常简单。</p>

<p>找到上次画了背景的那个地方， 也就是Draw方法，在画背景的那一行的下面加入如下代码。</p>

<pre><code>spriteBatch.Draw(
    cannon.sprite,
    cannon.position,
    null,
    Color.White,
    cannon.rotation,
    cannon.center,
    1.0f,
    SpriteEffects.None,
    0);
</code></pre>

<p>没错，其实和画背景一样，我们只是调用了SpriteBatch类的Draw方法，只是这一次我们使用了另外一个重载而已。只是这一次使用了参数比较多的那一个，一个一个的讲解过来吧。</p>

<ul>
<li><p><strong>第一个参数</strong>：Texture2D，也就是要画的纹理，这样我们全部要画的就是这个cannon.sprite这个Texture2D了。没错～</p></li>
<li><p><strong>第二个参数</strong>：Vector2D，向量，也就是我们放的位置。我们传入了cannon.position，还记得吗？当时设定的是(120,高度-80)这个向量。</p></li>
<li><p><strong>第三个参数</strong>：Rectangle，矩形，是指在我们的Texture2D上面的裁剪，有经验的一定知道，很多的动画都是通过这样的方式实现的，每一帧画在一张texture上，一次载入之后，以后每一次都只要变化这个参数来读取不一样的位置就好了。这里我们传入了null，意思就是默认为不进行任何的裁剪。可以尝试把第三个参数改成new Rectangle(0, cannon.sprite.Height / 2, cannon.sprite.Width, cannon.sprite.Height)绘制一半。</p></li>
<li><p><strong>第四个参数</strong>：Color，传入颜色，和之前画背景一样，就是我们的色彩过滤。White代表不进行任何过滤。</p></li>
<li><p><strong>第五个参数</strong>：float，传入的是旋转的值，它指的是向量的角度，就是屏幕的坐标系上的角度。我们传入的是0，那么就是X正方向，也就是不进行任何旋转，加农炮朝着屏幕左边。</p></li>
<li><p><strong>第六个参数</strong>：Vector2，是图像的中心点的位置，这里要注意一下，这个中心会根据你绘制的图形重新定义，如果你画的东西不是整个的，那就会发生变化了。这里我们绘制了全部的内容，所以没问题。如果之前一样你只绘制一半，就惨了。也就是说在这个方法内部，是先切割，决定画的部分，再决定中心点，而不是先根据你传入的Texture2D决定中心点，再切割的。</p></li>
<li><p><strong>第七个参数</strong>：float，这个是指图形缩放的倍数，如果要实现平滑的缩放，那么简单的Update里调整这个数值就可以了。我们这里的1.0f就是1倍，1 / 1，不缩放的意思。</p></li>
<li><p><strong>第八个参数</strong>：SpriteEffects枚举，这个枚举也只有三个成员，FlipHorizontally，FlipVertically和None。也是2D游戏的除旋转、缩放意外非常重要的特效&#8212;-翻转。一个是纵向的一个是横向的翻转。应该很好理解。我们传入None，就是不翻转。</p></li>
<li><p><strong>第九个参数</strong>：Int32，也就是int了，这是指深度，0和1之间。2D游戏经常会有深度这个概念，Depth，往往，Sprite会自动对这些深度排序，这样可以实现一些角色挡住丛林，或者丛林挡住角色的变化。这是2D游戏很重要的一个参数。当然如果要让这个参数有效，你必须先设置SpriteSortMode，在这里就不多加讨论了，总之我们这里传入了0。</p></li>
</ul>


<p>这样我们就画好了加农炮。运行一下吧，你已经在游戏上面做了一个可以转动的加农炮了。然后修改一下之前的一些代码看看有什么不同的变化～比如旋转的角度限定注释掉，炮会很可爱的。</p>

<p><a href="/images/uploads/zb/2009-06-14_RunTime.jpg"><img src="/images/uploads/zb/2009-06-14_RunTime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=152"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>之前也说到了，一些问题会在最后讨论一下，其实这就是两段在官网上也特别罗列出来要讲的东西，于是放上这两段的翻译。</p>

<p><strong>一、为什么要创建自己的类？</strong></p>

<p>我们在代码过程中，创建了一个GameObject，并且实例化为Cannon，可是为什么要自己创建一个GameObject呢？不是简单的把四个变量放到Game1里面就可以了吗？来看看下面这段翻译。（下文由本人翻译自<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/details/5_1">这里</a>，转载请注明翻译作者Arthraim，并表明出处，尊重我的劳动成功）</p>

<blockquote><p><a href="/images/uploads/zb/BG_3.5.1.1pd_a.png"><img src="/images/uploads/zb/BG_3.5.1.1pd_a.png" alt="" /></a></p>

<p>目前为止，你已经使用过了一段时间XNA Framework中的一些实现定义好的类（代码层面的对象，包含了数据和针对数据的操作的方法）了。</p>

<p>你已经修改了一些包含在Game1这个类中的一些方法，添加了一些新的类的声明，诸如SpriteBatch和Texture2D，并且在类中使用了他们。</p>

<p>然而，创建GameObject类完全是一种新的操作：创建一个你自己的包含了数据和方法的类的过程叫做定义一个类。乍一看，创建一个新的类文件，并且定义一些能像在Game1里面定义了一样，能够被简单的使用的数据和变量，也许需要非常多的工作。</p>

<p>例如，在GameObject中，一个被叫做position的数据成员Vector2。你可以简单的在Game1中定义一个包含位置数据的Vector2，因为一个就可以记录想让你追踪位置的对象了。但是还有旋转，速率，和其他活动的变量。当你考虑可以添加更多对象到屏幕上，而需要的都是一样的数据的时候，加入Game1的变量的数目就会开始向着无法工作的庞大的数据增长。</p>

<p>另外，如果你需要对这些数据进行一些运算操作，你就必须对每个变量采取相同的计算操作，一个接着一个。最终你的代码量将会非常的庞大并且没有效率。</p>

<p>类的目标是重用。综合一类你可能要用到多次的数据和方法到一个单独的&#8221;代码对象&#8221;，这样一个小单元，比一些独立的数据对象更加容易操作。</p>

<p>就像你可以在图中看到的一样，使用一个类，显著的减少了你需要在Game1.cs里要添加的声明，并且保持数据有序。当你要开始使用数列（相似并且可以按序操作的数据集合）声明一些对象，即游戏中对象变得更多的时候，这个概念会显得更加重要，没有类，数据会变得难以追踪。</p></blockquote>

<p>其实这只是一个简单的面向对象的概念，不应该放到游戏编程这里来说，就像视频里其实没必要讲一些VS的用法，因为虽然讲了，但是根本对不会用VS的人没有帮助。一样的，对不懂OO的人来说，讲这么一段东西对于他们的思维来说也不能产生什么变化。所以说，无论是VS的用法，还是C#的语法，或是这里提到的OO思想，都是需要慢慢积累，或是在别的地方补课的，而不是通过这个简单的教程。</p>

<p><strong>二、Game Studio中的角</strong></p>

<p>（下文由本人翻译自<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/details/5_2">这里</a>，转载请注明翻译作者Arthraim，并表明出处，尊重我的劳动成功）</p>

<blockquote><p>开发游戏中经常会需要你传递一个表示一个角的数值。2D对象的旋转只是你使用角的开始，还会有很多角的使用，比如在3D对象中，不同对象间反射的角，还有更多其他的。</p>

<p>有很多不同的方式去传递角。一个标准的方法就是用角度。意思是，把一个圆圈分为360个部分，每一个被称为一度。90度是四分之一个圆，180度是半个圆，等等。</p>

<p>然而，在计算机图形和XNA Game Studio中，更多的采用弧度来传递一个角。弧度采用和角度不一样的方法去切割一个圆 &#8212;- 代替360度代表一个圆周的方法，是用2倍的π或2π代表一个圆周。这个值被存储在MathHelper类当中，只需简单的调用MathHelper.TwoPi。半圆则就是这个值的一半，或是简单的用π表示，也就是MathHelper.Pi。你可以继续细分来得到其他角度。90度则是MathHelper.PiOver2。</p>

<p><a href="/images/uploads/zb/BG_3.5.2.1pd_a.png"><img src="/images/uploads/zb/BG_3.5.2.1pd_a.png" alt="" /></a></p>

<p>当使用SpriteBatch.Draw画一个Sprite，或者当你创建一些用来旋转的矩阵的时候，你需要弧度来传入旋转的值。但是如果你觉得角度更加方便的话，你可以在游戏中继续使用它，只要你在调用一些XNA Framework中需要传入弧度的方法的时候把它们转换成弧度就可以了。你可以使用MathHelper.ToRadians来完成这个工作，只要传入你要转换的角度即可。</p></blockquote>

<p>这也是之前说到的会详细说的内容。最后我再补上一张图，方便大家学习吧。</p>

<p><a href="/images/uploads/zb/2009-06-14_CordinateSystem.jpg"><img src="/images/uploads/zb/2009-06-14_CordinateSystem.jpg" alt="" /></a></p>

<p>画是画的难看一点。</p>

<ul>
<li><p>我们在设置position的时候，使用的是最外面黄色箭头表示的这个坐标系的，就是X正方向朝左，Y正方向朝下。</p></li>
<li><p>在设置center的时候，这个向量也是使用一样的方向的，只是坐标原点换成了Sprite的左上角，就比如我图例那个粉红色的框框的左上角（好像有些圆了 ;)）。</p></li>
<li><p>而在设置初始旋转的时候，我们设置了0，那么就是像图例的弧度这张图一样，是摆正的。就是Y轴方向是和屏幕坐标系相反的。（但是弧度这个概念可是不受限于坐标系的，只是rotation这个参数默认的0度是在这样的一个坐标系里面的。）</p></li>
</ul>


<p>好了我觉得该说的都说过了，那么就是这样。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-15T03:56:33+08:00" pubdate data-updated="true">Jun 15<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch4-rending-backgrounds/">
		
			XNA教程-2D游戏-04-绘制背景</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 04 &#8211; 绘制背景</strong></p>

<p>通过前面三篇文章，大概可以知道做一个简单的小游戏的准备工作了。我们已经迈出了第一步。但是程序员们一定不高兴了，我们看了三篇文章，不但没有一行代码，还讲了VS怎么用，软件怎么安装这些无聊的事情。那么好吧，这一次我们要直接开始写一些代码，一些可以运行起来的代码。</p>

<p>在我们做这个之前，首先建立工程，并且把asset加入到content里面。完成的同学举手～是的我也已经完成了。那么，在做这个之前，还是要再讲一些东西 &#8212;- Game1.cs。没错generate的文件中至关重要的就是Game1.cs这个东西，它在你的命名空间中自动生成了一个类，派生自Microsoft.Xna.Framework.Game，究竟Game类里实现了什么，你可以把dll找出来看看。（别告诉我.net的dll是不可读的，工具才是王道，哈哈）但是之前说了，微软还是奉行着不用关注底层的策略去做XNA的，所以大部分就不要关注了。</p>

<p>直接来看类的结构。有经验的人一定发现了，这个结构和directX的C#程序非常的接近，如果你和我一样用SharpDevelop直接新建过D3D的工程，那么一定看到过类似的代码。只不过仔细看看会发现很多东西不见了，也有些东西不能不见。比如熟悉的device变成了GraphicsDeviceManager。是换汤不换药吗？还是那句话，不要关注了。可能写完所有的教程我能讲讲。先大概讲一下：</p>

<p>他是个类，那么就具有一般类的所有的特性，比如与其他类进行数据交换等等。它代表了一个游戏，在XNA中Game类负责&#8221;开始&#8221;，&#8221;运行&#8221;，&#8221;绘制&#8221;（还是摧毁？没听清视频的话）一个游戏。它处理一些事物，例如&#8221;时钟计时&#8221;，&#8221;视频设备选择&#8221;，&#8221;清理&#8221;等。只要有这样一个类，就拥有了一个完整的游戏，用开始到运行到结束。</p>

<pre><code>public class Game1 : Microsoft.Xna.Framework.Game
{
    GraphicsDeviceManager graphics;
    SpriteBatch spriteBatch;
    public Game1()    {    }
    protected override void Initialize()    {    }
    protected override void LoadContent()    {    }
    protected override void UnloadContent()    {    }
    protected override void Update(GameTime gameTime)    {    }
    protected override void Draw(GameTime gameTime)    {    }
}
</code></pre>

<p>这个类实现我们两个变量和6个方法。</p>

<p>GraphicsDeviceManager类：是对device的封装，device的相关操作也可以通过这个类完成。</p>

<pre><code>SpriteBatch类：用以完成绘制2D纹理的相关操作。
</code></pre>

<p>Game1()不用说了，一个构造方法。</p>

<pre><code>public Game1()
{
    graphics = new GraphicsDeviceManager(this);
    Content.RootDirectory = "Content";
}
</code></pre>

<p>代码中实例化了GraphicsDeviceManager类，命名为graphics 。并且设置了Content管道的根地址为Content。这样一来，我们接下去在Content管道里可以调用的全部的asset都只能来自于Content目录中</p>

<pre><code>protected override void Initialize()
{
    // TODO: Add your initialization logic here
    base.Initialize();
}
</code></pre>

<p>覆盖了父类中的Initialize()方法，法如其名，就是用来初始化的。它允许游戏在运行之前做一些初始化的工作。可以在此查询任何需要的服务，和载入与图形无关的内容。</p>

<pre><code>base.Initialize()方法在被调用后可以通过任何组件枚举并初始化它们。




protected override void LoadContent()
{
    // Create a new SpriteBatch, which can be used to draw textures.
    spriteBatch = new SpriteBatch(GraphicsDevice);
    // TODO: use this.Content to load your game content here
}
</code></pre>

<p>一样覆盖了父类中的LoadContent()方法。方法是用来加载content的。</p>

<pre><code>这个方法一个游戏只会被调用一次，并且是你加载所有content的地方。

实例化了SpriteBatch类，命名为spriteBatch。




protected override void UnloadContent()    {    }
</code></pre>

<p>这个方法一样简单，UnloadContent，就是释放内容的地方。</p>

<pre><code>这个方法同样只会被调用一次，并且是卸载所有已经载入的资源的地方。

当前因为C#的托管机制，我们不用关注实例化的各种类的释放。




protected override void Update(GameTime gameTime)
{
    // Allows the game to exit
    if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed)
        this.Exit();
    // TODO: Add your update logic here
    base.Update(gameTime);
}
</code></pre>

<p>Update方法相当于D3D中会被命名为FrameMove之类的方法，说白了图形上就是修改当前画面的地方。</p>

<pre><code>按照注释所说，他用以游戏执行一些逻辑，诸如更新画面，检查碰撞，收集输入以及播放音频。

if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed) this.Exit();是退出代码

base.Update(gameTime);自然就是调用更新的方法，一切工作要在它之前完成。




protected override void Draw(GameTime gameTime)
{
    GraphicsDevice.Clear(Color.CornflowerBlue);
    // TODO: Add your drawing code here
    base.Draw(gameTime);
}
</code></pre>

<p>Draw方法相当于Paint和onPaint这样的方法了，是系统自动绘图的方法。应该很容易了解。</p>

<pre><code>GraphicsDevice.Clear(Color.CornflowerBlue);是清楚画面，现阶段试着改下颜色就会呈现不同的画面背景了。

base.Draw(gameTime);则是绘制工作。
</code></pre>

<hr />

<p>实际来开始写代码吧～</p>

<p><strong>第一步：声明一些东西</strong></p>

<p>我们声明一些我们需要的东西，在SpriteBatch spriteBatch;之前加入两行代码。</p>

<pre><code>Texture2D backgroundTexture;
Rectangle viewportRect;
</code></pre>

<p>声明一个2D的纹理，加载之后将储存所有我们要画的东西。至于Rectangle矩形是一个数学概念上的类，用来确定屏幕上的绘制范围，无论画什么将画在这个区域内。</p>

<p><strong>第二步：加载asset</strong></p>

<p>我们要做的依然很傻瓜，就是在LoadContent中写一些载入asset（理解为载入文件多容易）的代码。LoadContent方法会在程序开始之前完成加载的工作，而你则需要把所有这个游戏会用到的东西在这里加载，这样才能在之后被调用。我们找到// TODO: use this.Content to load your game content here这行注释，就可以在它下面加上我们需要的以下代码了。</p>

<pre><code>backgroundTexture = Content.Load&lt;Texture2D&gt;(
    @"Spritesbackground");
base.LoadContent();
</code></pre>

<p>正如大家看到的，这里只要直接用Content属性，然后告诉他路径就好了。.tga的后缀被省略了。调用base.LoadContent后资源载入成功。另外这里很高兴的看到了范型，写游戏的肯定很注意效率，那一定会担心范型的效率。不过我记得范型的效率有时候还高于现行数组等集合。</p>

<p>这里特别注意一下，按照视频中的GS2.0来看，会自动生成base.LoadContent();这行代码，留个心眼。</p>

<p><strong>第三步：绘制texture</strong></p>

<p>之前我们声明了texture并且载入了asset，那么接下去就是要coding了。要把它画在画面上，就要用到SpriteBatch类，在自动生成的代码中已经帮我们写好并且实例化好的类。它将帮助你把Scirpte画到你的设备上，PC或是X360，这就是为什么实例化SpriteBatch的时候传入了Device。我必须知道要画在哪里才可以。</p>

<p>接下去还是找到LoadContent方法，首先我们要确定绘图的范围，因为我们是画的背景，所以只要得到当前Device的viewport（视窗？）就可以知道这个范围。初始化这个范围到viewportRect这个矩形就好了，如参为四个，起始点的X坐标，Y坐标和宽度，长度。于是就是下面的一行代码。</p>

<pre><code>viewportRect = new Rectangle(0, 0,
GraphicsDevice.Viewport.Width,
GraphicsDevice.Viewport.Height);
</code></pre>

<p>意思很清晰，不过有个地方值得注意，视频中GraphicsDevice是通过graphics中的属性得到的，即是通过this，也就是当前的Game类实例化的GraphicDeviceManger中的属性得到的；而从3.1自动生成的代码来看，实例化ScriptBatch的时候可以直接使用this的GraphicsDevice属性。于是我们的代码也可以直接这么使用GraphicDevice属性，小细节而已，这里提到一下，于是继续。</p>

<p>接下来找到Draw方法绘制这一部分，找到// TODO: Add your drawing code here的地方，插入如下代码。</p>

<pre><code>spriteBatch.Begin(SpriteBlendMode.AlphaBlend);
spriteBatch.Draw(backgroundTexture, viewportRect, Color.White);
spriteBatch.End();
</code></pre>

<p>这段代码是2D游戏中才会出现的，在D3D里用sprite的时候也会看到类似的代码，beginscene等。SpriteBlendMode是个枚举类型，Additive和AlphaBlend和None三种。Additive就是叠加，等到后面有多个texture画上去的时候再做实验。Alphablend是alpha混合，就是半透明效果，带有半透明信息的图片可以直接贴上去而不需要你做额外的混合工作。在draw中传入要画的texture，要画的范围，以及最后一个颜色参数。这个颜色参数相当于CSS中的filter，就是一个滤镜，调整颜色的，这里传入白色代表不做任何过滤。最后end相当于ndScene，结束。</p>

<p>OK到这里代码就写完了，看一下总共我们只写了8行代码，就完成了背景的绘制，很简单，运行一下看看效果（点击放大），就收工啦～</p>

<p><a href="/images/uploads/zb/2009-06-13_DrewBackground.jpg"><img src="/images/uploads/zb/2009-06-13_DrewBackground.jpg" alt="" /></a></p>

<p>官方提供的源代码下载。</p>

<p><a href="http://creators.xna.com/downloads/?id=151"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>接下去通过对网站上其他资源的翻译，达到对一些没有解释的内容的解释作用。</p>

<p><strong>一、Content</strong></p>

<p>Content是最莫名其妙的东西，我们莫名其妙的写出了Content.Load这样的方法，但是事实上，Content这个Game的属性是怎么回事我们根本不知道，里面有什么我们也不知道，那么究竟它是如何工作的我们先看一下我的翻译。（以下为本人根据微软提供的资料所做的翻译，原文请查看<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/details/4_2">这里</a>）</p>

<p>Content Pipeline是如何工作的？</p>

<blockquote><p><img src="/images/uploads/zb/BG_3.4.2.1pd.png" alt="" /></p>

<p>XNA Framework的ContentPipeline是XNA Game Studio非常重要的一个部分，目前为止所展现给你的那部分（添加物件到工程中以及调用和加载）只是对发生在幕后的事情的暗示。</p>

<p>在传统的游戏开发中，载入内容（转换内容文件到游戏在运行时可以使用的格式）是一件困难且耗时的工作。往往，程序员必须要从零开始编写一个载入系统（loading system），必须写一个导入器（importer）来消费3D和2D资源（诸如美工提供的模型和纹理），再写一个处理器（processor）转换这些导入的格式为代码对象，使得其他程序员可以这些代码对象进行操作，使模型显示出来并在游戏中产生互动。</p>

<p>然而在XNA Game Studio中，大量的这类工作已经由XNA Framework Content Pipeline完成了。Content Pipeline</p></blockquote>

<pre><code>    在你把一些资源放到解决方案查看器里的那一刻已经参与了进来。
</code></pre>

<blockquote><p>如果你添加了一个Content Pipline能够识别的内容类型，你可以在解决方案查看器点击看到Content Pipline的属性。你会注意到任何一个内容都有四个属性。</p>

<p>第一个是Asset名字。这是一个字符串，用来在你调用ContentManager.Load的时候定义内容名称。注意他的命名就是文件名去掉了后缀。</p>

<p>第二个是Content导入器（importer）。它定义了从磁盘文件读取内容所使用的导入器的类型。一个导入器被调整接受某特定格式。只要文件一被导入，他会通过第三个道具&#8212;-Content处理器（Processor）。这些处理器转换传入的数据到可以在运行时被读取的格式，并且转换成一个类。</p>

<p>任何独立的物件所对应的导入器和处理器可以通过第四个属性（名叫XNA Framework Content）的设置打开或关闭。如果设为true，这个内容就会完成之前提到过的导入和处理工作。如果设为false，Content Pipeline将不会导入或处理内容。</p>

<p>当你添加一个物件到解决方案查看器，这些设置将按照默认值设置，并且在大多数情况下，他们不需要修改。想要完成你会经常在游戏类中完成的事情&#8212;-把内容加载到游戏中，所有你要做的事情就是调用ContentManager.Load方法了。</p></blockquote>

<p>看完这段翻译有些东西不得不讲一下：</p>

<p>首先是属性，按照这里所说的属性是四个，并且Processor是没有扩展的。（如引用区域内的那张小图，此图为官网使用的示例图，不能放大）这是基于GS2.0的教程，但是在我现在使用的3.1版中我们根本没有这第四个属性，反而是像我的截图（下图，点击放大）里的一样，Processor拥有了很多的属性。</p>

<p><a href="/images/uploads/zb/2009-06-13_ContentPiplineProperty.jpg"><img src="/images/uploads/zb/2009-06-13_ContentPiplineProperty.jpg" alt="" /></a></p>

<p>其次就是ContentManager的解释，翻译里的描述的，我们采用的ContentManager类，其实不需要我们自己定义或实例化，在构造Game类的同时，这个ContentManager类已经作为Game类的一个属性被定义完成了，我们只需要直接调用(Game)this.Load<object>()方法就可以调用了。于是结合上面提到的GraphicsDeviceManager，我想，能不能也不要呢。于是我注释掉了两行代码，一个是声明一个是实例化，之后在运行到draw方法，需要用到this.GraphicsDevice类的时候提示：This property requires a graphics device service in the game service container. 这么说来ContentManager已经会自动被实例化，可是GraphicsDeviceManager却不可以。毕竟从这些代码上面来看，构造ContentManager只需要一个IServiceProvider作为如参，那么Game实例化过程中就可以完成这个操作。而GraphicsDeviceManager需要的入参是Game，这就不可能自动在构造Game的时候完成。（当然在我们看不到的地方是完全可以实现的）看来究竟内部如何实现的，又有什么考量，有深入研究的价值。</p>

<p><strong>二、sprites，sprite绘制，和spritebatch</strong></p>

<blockquote><p><img src="/images/uploads/zb/BG_3.4.3.1pd.png" alt="" /></p>

<p>Sprite（常译作精灵，此处不翻译）是游戏中显示的2D图形的常用名字。在过去，几乎所有的游戏是基于sprite方式的；2D图形曾是古老的处理器和电视游戏系统所能实时处理的全部。随着当前计算机和电视游戏主机中包含的图形处理但与（GPU）的降临，很多游戏转向了3D图形，但是在那些游戏当中，sprite仍然出现了，成为诸如烟和火这样一类的效果的首选方式，给予了他们不高的复杂度和较快的绘图速度。</p>

<p>在XNA Framework中，没有类似的Sprite类；一个XNA Framework制作的游戏中的一个sprite来自于很写Texture2D对象的结合，他们包含了要绘制的图像信息，和一个能设置图形设备让其正常绘制2D图形的SpriteBatch对象。</p>

<p>在3D游戏中，XNA Framework的绘制方法主要用来绘制3D模型到屏幕上。一系列的叫做绘制状态（render state）的图形设备的设置选项，按照默认设置的都是用来绘制3D模型的。SpriteBatch类处理转换这些绘制状态到允许2D图形的绘制。要做到这一点，SpriteBatch拥有两个方法，Begin和End。你必须分别调用它们让图形设备为2D图形做好准备，或者回复图形设备到3D绘制状态。</p>

<p>在调用Begin和End方法的中间，你可以调用SpriteBatch.Draw，并通过调整位置、大小、旋转、翻转、调色，以及更多的丰富多彩的选项来绘制Texture2D对象到屏幕上。</p>

<p>在调用Draw方法时，通过调整位置、大小、旋转、调色还有其他显示参数，你可以让一个单独的Texture2D对象表现出丰富多彩的不同的状态。利用随着时间的推移，平滑的变换这些参数，你可以模拟表情或其他动画效果。</p>

<p>一个标准的2D游戏，你只需要调用Begin一次，然后利用一系列的Draw方法的调用绘制所有的和游戏相关的sprite，然后再调用End。注意，在你的游戏中，你只需要一个SpriteBatch对象，无论你将要有多少Texture2D对象要画。</p>

<p>在教程的最后，你还会学到如何使用SpriteBatch来显示文本到屏幕上。这对于显示文本和数字信息给玩家来说非常的实用，就像得分，角色间的对话或者更多其它的东西。</p></blockquote>

<p>可以总结下，一般2D游戏的Sprite就是Sprite，而XNA中的Sprite对象是不存在的，只有一个SpriteBatch对象，它不是真正意义上传统的Sprite，他是一系列texture纹理的集合。</p>

<p>其实这种实现方式在Direct3D9中就已经被使用了。人们在做2D游戏的时候（就像我当时找资料的时候）总是要回忆说DD7如何如何的好，如何如何的方便。于是有了利用DD7供给VB调用的组件实现C#调用DD7对象来实现2D游戏这样子极端的做法。其实在D3D8时代，去除directDraw的时候，就已经采用了类似XNA这样的2D游戏的实现方式。而D3D9中不但依然使用这种实现方式，还提供了directDraw7的.net的实现。</p>

<p>当然，如今在XNA中一定不会有directDraw了，不过我们应该已经能够接受这种2D游戏的开发方式了。只是话说回来，2D游戏还有多少市场呢？</p>

<p>终于结束Chapter4了，保证各位看过我的文章不用再去XNA Creator Club学习了。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-14T00:35:48+08:00" pubdate data-updated="true">Jun 14<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch3-add-assets/">
		
			XNA教程-2D游戏-03-添加Assets</a>
	</h2>
	<div class="entry-content">
		<p><a href="/images/uploads/zb/2009-06-13_WhatIsAssets.jpg"><img src="/images/uploads/zb/2009-06-13_WhatIsAssets.jpg" alt="" /></a></p>

<p><strong>XNA教程 &#8211; 2D游戏 &#8211; Chapter 03 &#8211; 添加Asset</strong></p>

<p>这一部分我们将完成的工作是在工程中添加Asset，听上去好像很复杂，Asset是什么？添加到工程又是什么概念？那其实是很简单的事情，我会通过三个部分的解说包括实际的操作方法来说明这次的章节，看不懂的可以看视频的，那么接下去就正式开始写了。</p>

<p><strong>一、Visual Studio的用法。</strong></p>

<p>这就是我说的三个部分中的第一个，VS的解说。肯定很多看到这里的人要不耐烦了，你弄这种东西干什么啊，都来看XNA了当然会C#会.net会VS啊。其实，之所以加上这一块，是因为我惨痛的童年回忆造成的。很多向往做游戏的儿童青少年们，好不容易找到了一个教程，可是往往教程默认了很多很多的前提以至于一头雾水。那么看到这里的小朋友们～ 记住，我也默认了很多前提在这里，你们可以先去学C#，用C#做一个按一下按钮出来一个对话框显示一个Hello,world的，OK基本上你就可以来看这里的内容了（囧，可以吗？）好讲一下VS。VS有solution（解决方案）的概念，这是比project（项目）更加高级的东西。一个solution中可以有多个project，很常见的就是dll一个界面一个。VS提供了一些控件，比如类视图、解决方案视图、控制台、追踪、错误列表等等，这些和普通的IDE都是一样的。（写到这里自己都觉得多余了）</p>

<p><strong>二、什么是Asset？</strong></p>

<p>说完多余的东西，我们终于可以将一些重点了。究竟Asset是什么呢？我觉得程序里涉及到一些哪怕日常的单词也不应该去翻译，比如并行设计到的actor模型，难道翻译成角色模型？不合适吧。所以Asset如果翻译成&#8221;资产、有用的东西&#8221;之类的意思，那也就真的不合适了。所以还是用asset原来的样子来讲解比较好，通过后面的讲解你一定很快明白什么是asset了，微软忽悠这么一个概念也挺强大的。</p>

<p>（注：以下文字由本人翻译自微软官方解释。）</p>

<p>在XNA Game Studio项目中，你会频繁的听到&#8221;代码&#8221;和&#8221;asset&#8221;这样的措辞。&#8221;代码&#8221;指在程序说明中包含的.cs文件。这些说明告诉游戏怎么行动：怎么对用户操作进行反应，怎么移动物体，以及怎么显示给玩家看。</p>

<p>另一方面的asset，不是唯一的一个文件类型。位图图形、声音文件、3D模型 &#8212;- 他们都是asset。总之，accets指数据（图形、声音或其他一些东西），他们被&#8221;代码&#8221;操控着。举个UFO图片的例子。这个UFO图片本身，存储为.tga或者.png文件，他是一个asset。代码可能载入这个UFO图像，并且把它显示在屏幕的不同位置，并给他一些移动的效果。如果有一组asset的话，它不被称为content。</p>

<p>在游戏中，你必须同时拥有&#8221;代码&#8221;和&#8221;asset&#8221;。典型的，asset表现出物体的外表和声音，你的代码代表了它的动作（行动）。</p>

<p>这个规则有一个例外，就是一个asset的特殊类型，叫做shader。他是一些特别的代码，帮助绘制图形在屏幕上，但是它不是图片。Shader不会在这次的教程中使用到，但是在使用高级图形的游戏中它们经常被用到，并且要像代码一样的进行编辑就。</p>

<p>在教程中，我们只使用两种类型的asset &#8212;- 2D texture（材质，还是不要翻译了）和font（字体）。2D texture只是一些图片文件。在教程中，我们每个游戏元素拥有一个图片 &#8212;- 我们玩家的加农炮，敌人的UFO，玩家可以发射的加农炮的子弹，还有一个背景。font字体是特殊的一种texture，代表了我们可以画在屏幕上的文本。它将在游戏中当我们需要跟踪玩家得分时帮助到我们。</p>

<p><strong>三、如何添加？</strong></p>

<p>步骤其实非常的简单，在工程中我们可以看到Contend的存在。当前里面只有一个引用项，不去管它。第一步我们要做的是下载我们这次要用到的素材，或者现在应该叫做asset。（直接看到此文的请转至Chapter2补下，当然你也可以在本文最后的完整工程代码下载中找到你要的文件）</p>

<p>下载下来的是一个BG_2D_Chapter2.Zip文件，解压缩后得到Microsoft Permissive License.rtf和Sprites文件夹。Sprites文件夹里有之前说到的4张图，background.tga, cannon.tga , cannonball.tga, enemy.tga。</p>

<p>要加入到工程中很简单，两步走。</p>

<p>1、右键单击Content &#8211; Add &#8211; New Folder。然后命名为Sprites。2D游戏里都这么称呼，那么我们就这么命名。（中文版自重）</p>

<p>2、右键单击Sprites文件夹 &#8211; Add &#8211; Existing Items。然后选中你刚才解压缩出来的四个.tga文件，add就好了。（其实你愿意的话，把解压缩出来的文件夹复制到工程里也行，只是一样要add过而已）</p>

<p><a href="/images/uploads/zb/2009-06-13_AddAssets.jpg"><img src="/images/uploads/zb/2009-06-13_AddAssets.jpg" alt="" /></a></p>

<p>很神奇吧，做完这个，其实内容就已经完成了，看上去真是有点脑残了。完成如下图。</p>

<p><a href="/images/uploads/zb/2009-06-13_AddedAssets.jpg"><img src="/images/uploads/zb/2009-06-13_AddedAssets.jpg" alt="" /></a></p>

<p>这就是本章要讲解的内容，万事开头难，大家要有耐心，虽然做起来很简单，不过无论是Content还是Asset都是微软给我们的概念，一定要记住了。</p>

<p><a href="http://creators.xna.com/downloads/?id=150"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" />示例代码下载</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-13T21:24:27+08:00" pubdate data-updated="true">Jun 13<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch2-create-solution/">
		
			XNA教程-2D游戏-02-创建游戏工程</a>
	</h2>
	<div class="entry-content">
		<p><a href="/images/uploads/zb/2009-06-13_PlatformerGameDemo.jpg"><img src="/images/uploads/zb/2009-06-13_PlatformerGameDemo.jpg" alt="" /></a></p>

<p><strong> XNA教程 &#8211; 2D游戏 &#8211; Chapter 2 &#8211; 创建游戏工程</strong></p>

<p>从最开始学习XNA，那么首先我们需要自己的环境。微软提供XNA Game Studio给大家，当然还要有Visual Studio，如果愿意你可以在安装好Visual Studio 2005或更高版本的前提下安装XNA Game Studio（以下简称GS）。当然，本着XNA游戏开发是基本免费的原则，我们也可以使用Express版本，也是支持的。具体VS和GS的安装和配置请大家自己解决了，这里不赘述了。</p>

<p>使用GS3.1+VS2008是基于.NET Framework 3.5的，否则一些新特性将不会被用到，如果你的开发使用其他环境，那么也许会不一样。</p>

<p><strong>步骤一：Visual Studio简单介绍</strong></p>

<p>这一步骤简单的雷人。稍微讲讲就过去了吧。首先要安装好VS和GS，就像之前说到的，然后我们看一下VS的新建。新建中总共有这么几项（GS3.1+VS2008，不保证其他版本有一样的工程）</p>

<p><a href="/images/uploads/zb/2009-06-13_VS2008GS31.jpg"><img src="/images/uploads/zb/2009-06-13_VS2008GS31.jpg" alt="" /></a></p>

<blockquote><ul>
<li><p>Windows Game (3.1) &#8212;- XNA Game For Windows游戏的开发，很多游戏打着这个标志</p></li>
<li><p>Windows Game Library (3.1) &#8212;- Windows游戏类库</p></li>
<li><p>Xbox 360 Game (3.1) &#8212;- Xbox360游戏</p></li>
<li><p>Xbox 360 Game Library (3.1) &#8212;- Xbox360游戏类库</p></li>
<li><p>Zune Game (3.1) &#8212;- Zune游戏</p></li>
<li><p>Zune Game Library (3.1) &#8212;- Zune游戏类库</p></li>
<li><p>Content Pipeline Extension Library (3.1) &#8212;- Content管道扩展库</p></li>
<li><p>Platformer Starter Kit (3.1) &#8212;- 一个游戏示例（提供windows x360 zune三种版本都有，本章顶部图为Windows版）</p></li>
</ul>
</blockquote>

<p>VS的具体操作就不介绍了，至于最终我们的游戏如何使用，如果你没有加入XNA Creator Club成为白金会员，那么你的游戏也是没办法在XBOX360上用的，我这里就简单的使用Windows开发了。另外，视频中使用的是VS2005+GS2，所以我们直接可以看到两个视频中制作的游戏的示例工程，偷懒的直接下2吧。究竟3有什么新特性，我也不是很了解，也许讲到最后我也就了解了吧。（总觉得自己都不会就开始写是非常不妥的方法。）</p>

<p><strong>步骤二：新建工程，获取资源</strong></p>

<p>这一步也非常的简单，根据刚才介绍的新建，建立相应的工程。</p>

<p>比如我新建一个Windows Game (3.1)工程，并且取名为Chapter2。</p>

<p><img src="/images/uploads/zb/2009-06-13_Project.jpg" alt="" /></p>

<p>可以看到IDE为我们创建了如图一些文件，具体都是什么呢？</p>

<blockquote><ul>
<li><p>Content &#8212;- 就是一切我们需要的游戏资源，在XNA中存在Content Pipeline这个概念，而这里的所有资源可以之后在Content管道中直接调用加载。</p></li>
<li><p>Game1.cs &#8212;- 游戏逻辑代码。</p></li>
<li><p>Game.ico &#8212;- 不用多说，一个Xbox360的手柄样式的ico图标。</p></li>
<li><p>GameThumbnail.png &#8212;- 正如他的名字，是一个缩略图，当然要你自己画的啦。</p></li>
<li><p>Program.cs &#8212;- 就是程序的入口Main方法了。</p></li>
</ul>
</blockquote>

<p>GameThumbnail.png原图如下</p>

<p><img src="/images/uploads/zb/2009-06-13_GameThumb.jpg" alt="" /></p>

<p>接下去本章很重要的一部就是下载必须的游戏素材。这里提供官方链接，下载解压缩后放入Content文件夹中，这是我们制作我们示例要用到的全部素材了。只有一个lisense文件和sprite文件夹，sprite文件夹中有四张图，看看就知道干什么了～</p>

<p><a href="http://creators.xna.com/downloads/?id=149"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a>素材下载点击图标</p>

<p>OK，好了这一章很简单，就说到这里吧。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-13T20:47:02+08:00" pubdate data-updated="true">Jun 13<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch1-introduction/">
		
			XNA教程-2D游戏-01-2D游戏教程简介</a>
	</h2>
	<div class="entry-content">
		<p><a href="/images/uploads/zb/2009-06-13_XNA_logo.jpg"><img src="/images/uploads/zb/2009-06-13_XNA_logo.jpg" alt="" /></a></p>

<p><strong>XNA教程 &#8211; 2D游戏 &#8211; Chapter 1.1 &#8211; 2D游戏教程简介</strong></p>

<p>从今天开始，我将分享对于XNA学习的所有过程，这是一个教程，但其实我也不懂，这是自己学习和所有一起学习的人的过程，我想通过这段时间的简单学习可以初步实现XNA的简单的小游戏，无论将来能够做出什么，能做出基本的demo就可以。也通过这段学习，比对一下先前使用过的一些游戏开发手段。比如GDI+,DirectX3D,DirectDraw还有psp sdk, nds PALib等。</p>

<p>首先说明，本教程所有素材来源与XNA Creator Club的Beginner&#8217;s Guide。<a href="http://creators.xna.com/en-US/education/gettingstarted">该站点</a>提供了全部的视频教学，而我也是根据此视频教学进行学习的，如果说各位看官觉得我的翻译或讲解可以，那么和我一起学习下去，如果各位觉得我的进程相对缓慢，那么不妨自己去加速了。只不过，对于网速受限或者语言受限的朋友，我的教程应当会有用。</p>

<p>正如前面的图片一样，我们使用的将是XNA Game Studio作为开发环境，应当说是配置起来最为方便的游戏开发环境了，他不但强大而且是免费的，介绍及下载请参见《<a href="http://arthraim.cn/post/2009/06/60.html">XNA Game Studio 3.1 Avalable</a>》这篇文章，它将告诉你如何配置好这个环境。</p>

<p>本2D教程最终我们要完成的，是一个炮塔攻击UFO的简单的demo（效果如图）。而在对3D感兴趣的朋友，在完成2D的教程之后，我将继续写3D的部分，不过即便是想学习3D的内容，也不要放弃对2D的学习，这对于3D游戏的开发将具有非常重要的作用。</p>

<p><img src="/images/uploads/zb/2009-06-13_2DGameDemo.jpg" alt="" /></p>

<p>另外，为了方便大家看到效果，特地在博客中加入了lightbox，所以任何一张图片都是可以通过点击放大查看的～ 希望能给大家带来更好的体验。那么看完这篇文章，下一篇就将是这个教程真正的开始了。你准备好了吗？</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-13T19:38:00+08:00" pubdate data-updated="true">Jun 13<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-game-studio-3-1-available/">
		
			XNA Game Studio 3.1 Available</a>
	</h2>
	<div class="entry-content">
		<p><img src="/images/uploads/zb/2009-06-12_XNA.png" alt="" /></p>

<p>微软的XNA一直是个好东西，依靠他不但可以做出Game For Windows，还可以直接在XBOX360上使用，当然前提是你的游戏做的足够好，你的会员资格是白金。</p>

<p>引用一段WikiPedia对XNA的介绍～</p>

<blockquote><p>Microsoft XNA (&#8216;XNA&#8217;s Not Acronymed&#8217;) is a set of tools with a managed runtime environment provided by Microsoft that facilitates computer game development and management. XNA attempts to free game developers from writing &#8220;repetitive boilerplate code&#8221; and bring different aspects of game production into a single system. The XNA toolset was announced March 24, 2004, at the Game Developers Conference in San Jose, California. A first Community Technology Preview of XNA Build was released on March 14, 2006. XNA Game Studio 2.0 was released in December 2007, followed by XNA Game Studio 3.0 on October 30, 2008.</p></blockquote>

<p>首先XNA提供了一个框架，基于.NET Compact Framework 2.0和.NET Framework 2.0的框架，分别对应支持Xbox 360和Windows。这使得很多.net的工程师可以轻松来到XNA的开发工作当中。另外使用的语言是C#，这是.net框架决定的，但是它只支持C#，VB.NET就不可以。XNA framework和.net framework一样，不用开发者过度关注底层细节，让教学和开发变得更加简便。</p>

<p>而XNA提供开发者的工具也是相当的便捷 &#8212;- XNA Game Studio。它不但提供了XNA库，还有一堆一堆的工具插件附加到Visual Studio上，所以几乎让习惯于.net开发的程序员不用做任何的习惯上的改变。昨天XNA GS 3.1正式公布了。</p>

<p><img src="/images/uploads/zb/2009-06-12_XNAGameSudio3.1.jpg" alt="" /></p>

<p><a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=80782277-d584-42d2-8024-893fcd9d3e82&amp;displaylang=en"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a><a href="http://www.microsoft.com/downloads/details.aspx?FamilyID=80782277-d584-42d2-8024-893fcd9d3e82&amp;displaylang=en">下载地址</a></p>

<p>微软还提供了一个<a href="http://creators.xna.com/en-US/">XNA爱好者平台</a>，可以论坛交流，上传游戏等等，让XNA这个以免费为宗旨的基于开发爱好者的游戏开发平台更加完善。</p>

<p>介绍结束。实践一下，来简单看一下这个环境如何。</p>

<p>需要说明的是，我当前的操作系统版本为Windows7 build7057，程序运行没有问题～</p>

<p><strong>安装</strong>：</p>

<p><img src="/images/uploads/zb/2009-06-12_forVS2008.png" alt="" /></p>

<p>安装完毕，看看我们能用的东西。IDE直接使用VS2008，device center可以加载device来运行。提供了文档以及一些音频等制作工具，还有命令行工具。</p>

<p><img src="/images/uploads/zb/2009-06-12_XNA_files.png" alt="" /></p>

<p>打开VS2008，<strong>新建工程：</strong></p>

<p><a href="/images/uploads/zb/2009-06-12_XNA_VS2008_NEW.png"><img src="/images/uploads/zb/2009-06-12_XNA_VS2008_NEW.png" alt="" /></a></p>

<p>会自动<strong>genarate一些代码和文件</strong>。</p>

<p><a href="/images/uploads/zb/2009-06-12_XNA_VS2008_CODE.png"><img src="/images/uploads/zb/2009-06-12_XNA_VS2008_CODE.png" alt="" /></a></p>

<p>直接<strong>运行</strong>：</p>

<p><a href="/images/uploads/zb/2009-06-12_XNAGame.jpg"><img src="/images/uploads/zb/2009-06-12_XNAGame.jpg" alt="" /></a></p>

<p>OK，这里就不详细说怎么去写一个XNA游戏了。微软在这里提供了<a href="http://creators.xna.com/en-US/education/gettingstarted">视频教程</a>，2D或者3D的教程都有。感兴趣的同学可以去学习一下，希望大家一切顺利。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-12T18:22:06+08:00" pubdate data-updated="true">Jun 12<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/asp-net-twitter-api-client/">
		
			ASP.NET调用twitter Api实现简单的功能</a>
	</h2>
	<div class="entry-content">
		<p>很让人高兴的是在敏感时期过后，我们可爱的twitter又能上去了。今天更新的tweet特别多，很多人都在欢呼雀跃，不过大多数用着其他渠道发的人还是继续保持步调。于是在一星期前就有过看twitter api的想法，今天还是得以如愿以偿了。不过看着看着我就偷了个懒，在blogengine.net的开源项目里找到了一段.net实现的通过feed方式获取tweets的方法。把代码整理了一下，去掉了blogengine的widget成分，做成个页面……</p>

<p><strong><a href="http://twitter.com/arthraim/">Follow me</a></strong></p>

<p><strong>Links:</strong></p>

<p><a href="http://www.dotnetblogengine.net/">BlogEngine.net</a> | blogEngine.net的官方网站，下载完整博客文件后，查看widget中的twitter部分就可以了。</p>

<pre><code>[TwitterFeed-Widget for BlogEngine.NET](http://twitterfeedwidget.codeplex.com/) | 这是在上面那些代码的基础上修改的一个codeplex开源项目，稍微优化了一下，其实读下来差不多。  

[twitter api 中文文档](http://www.54chen.com/c/591) | twitter api的翻译，来自陈臻（@54chen）。
</code></pre>

<p><strong>前台代码</strong>。加入页面，如Default.aspx。</p>

<pre><code>&lt;asp:HyperLink runat="server" ID="hlTwitterAccount" Text="Follow me on Twitter" rel="me" /&gt;
&lt;asp:Repeater runat="server" ID="repItems" OnItemDataBound="repItems_ItemDataBound"&gt;
    &lt;ItemTemplate&gt;
        &lt;img src="twitter.ico" alt="Twitter" /&gt;
        &lt;asp:Label runat="server" ID="lblDate" style="color:gray" /&gt;&lt;br /&gt;
        &lt;asp:Label runat="server" ID="lblItem" /&gt;&lt;br /&gt;&lt;br /&gt;
    &lt;/ItemTemplate&gt;
&lt;/asp:Repeater&gt;
</code></pre>

<p><strong>后台代码</strong>。</p>

<pre><code>using System;
using System.Configuration;
using System.Data;
using System.Xml;
using System.Text.RegularExpressions;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Net;
using System.Globalization;
public partial class _Default : System.Web.UI.Page
{
    protected void Page_Load(object sender, EventArgs e)
    {
        ShowTweets();
    }
    private static DateTime LastModified = DateTime.MinValue;
    private const string CACHE_KEY = "twits";
    private void ShowTweets()
    {
        //用户名
        string _username = "arthraim";
        //用户的twitter地址
        string _url = "http://twitter.com/" + _username + "/";
        //FEED地址（user_timeline为自己的，可以根据需要修改）
        string _feedurl = "http://twitter.com/statuses/user_timeline/" + _username + ".rss";
        //显示的最大条目数
        int maxItems = 30;
        hlTwitterAccount.NavigateUrl = _url;
        if (_feedurl != null)
        {
            if (HttpRuntime.Cache[CACHE_KEY] != null)
            {
                string xml = (string)HttpRuntime.Cache[CACHE_KEY];
                XmlDocument doc = new XmlDocument();
                doc.LoadXml(xml);
                BindFeed(doc, maxItems);
            }
            if (DateTime.Now &gt; LastModified.AddMinutes(15))
            {
                LastModified = DateTime.Now;
                BeginGetFeed(_feedurl);
            }
        }
    }
    protected void repItems_ItemDataBound(object sender, RepeaterItemEventArgs e)
    {
        Label text = (Label)e.Item.FindControl("lblItem");
        Label date = (Label)e.Item.FindControl("lblDate");
        Twit twit = (Twit)e.Item.DataItem;
        text.Text = twit.Title;
        date.Text = twit.PubDate.ToString("MMMM d. HH:mm");
    }
    private void BeginGetFeed(string url)
    {
        HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(url);
        request.Credentials = CredentialCache.DefaultNetworkCredentials;
        request.BeginGetResponse(EndGetResponse, request);
    }
    private void EndGetResponse(IAsyncResult result)
        {
        HttpWebRequest request = (HttpWebRequest)result.AsyncState;
        using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
        {
            XmlDocument doc = new XmlDocument();
            doc.Load(response.GetResponseStream());
            HttpRuntime.Cache[CACHE_KEY] = doc.OuterXml;
        }
    }
    private void BindFeed(XmlDocument doc, int maxItems)
    {
        XmlNodeList items = doc.SelectNodes("//channel/item");
        List&lt;Twit&gt; twits = new List&lt;Twit&gt;();
        int count = 0;
        for (int i = 0; i &lt; items.Count; i++)
        {
            if (count == maxItems)
                break;
            XmlNode node = items[i];
            Twit twit = new Twit();
            string title = node.SelectSingleNode("description").InnerText;
            if (title.Contains("@"))
                continue;
            if (title.Contains(":"))
            {
                int start = title.IndexOf(":") + 1;
                title = title.Substring(start);
            }
            twit.Title = ResolveLinks(title);
            twit.PubDate = DateTime.Parse(node.SelectSingleNode("pubDate").InnerText, CultureInfo.InvariantCulture);
            twit.Url = new Uri(node.SelectSingleNode("link").InnerText, UriKind.Absolute);
            twits.Add(twit);
            count++;
        }
        twits.Sort();
        repItems.DataSource = twits;
        repItems.DataBind();
    }
    private static readonly Regex regex = new Regex("((http://|https://|www\.)([A-Z0-9.\-]{1,})\.[0-9A-Z?;~&amp;\(\)#,=\-_\./\+]{2,})", RegexOptions.Compiled | RegexOptions.IgnoreCase);
    private const string link = "&lt;a href="{0}{1}" rel="nofollow"&gt;{1}&lt;/a&gt;";
    /// &lt;summary&gt;
    /// The event handler that is triggered every time a comment is served to a client.
    /// &lt;/summary&gt;
    private string ResolveLinks(string body)
    {
        CultureInfo info = CultureInfo.InvariantCulture;
        foreach (Match match in regex.Matches(body))
        {
            if (!match.Value.Contains("://"))
            {
                body = body.Replace(match.Value, string.Format(info, link, "http://", match.Value));
            }
            else
            {
                body = body.Replace(match.Value, string.Format(info, link, string.Empty, match.Value));
            }
        }
        return body;
    }
    private struct Twit : IComparable&lt;Twit&gt;
    {
        public string Title;
        public Uri Url;
        public DateTime PubDate;
        public int CompareTo(Twit other)
        {
            return other.PubDate.CompareTo(this.PubDate);
        }
    }
}
</code></pre>

<p>[修改自开源项目blogengine.net]</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-09T06:49:31+08:00" pubdate data-updated="true">Jun 9<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>

<nav id="pagenavi">
    
        <a href="/blog/page/15/" class="prev">Prev</a>
    
    
        <a href="/blog/page/17/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2013

    Arthur Wang

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'artorius';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-8352384-7']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>