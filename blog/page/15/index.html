
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Artoirus</title>
	<meta name="author" content="Arthur Wang">

	
	<meta name="description" content="安装好环境、建立了XNA工程、添加了要用到的模型以及贴图，那么接下来要做的就是实际的代码了，而一上来就和2D大为不同的是，我们要直接创建我们的&#8221;宇宙环境&#8221;。要知道，在2D游戏中，我们游戏的&#8221;世界&#8221;是整个一张图，就是背景，简单的2D游戏就是这样。 &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Artoirus" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>

<body>
	<header id="header" class="inner"><h1><a href="/">Artoirus</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:Arthraim.github.com">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:Arthraim.github.com">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch4-render-3d-titan/">
		
			XNA教程-3D游戏-04-绘制3D地表</a>
	</h2>
	<div class="entry-content">
		<p>安装好环境、建立了XNA工程、添加了要用到的模型以及贴图，那么接下来要做的就是实际的代码了，而一上来就和2D大为不同的是，我们要直接创建我们的&#8221;宇宙环境&#8221;。要知道，在2D游戏中，我们游戏的&#8221;世界&#8221;是整个一张图，就是背景，简单的2D游戏就是这样。而3D则不然，即便是这个环境，那么也是需要我们用模型自己创建的，而这将会是一个非常复杂的工作，究竟如何复杂，看到下面的所有内容你就明白了。</p>

<p>从2D到3D，应该说当前我们在做的是一个非常困难的转换时期，我们要完成第一个3D的绘制，那么就必须了解很多很多只有在3D游戏中才会出现的概念。但是，简单的说，在代码上我们要完成的工作还是类似的，比如2D中，我们先声明了sprite；然后loadContent，或者load确定它的位置等信息；最后我们draw把它绘制出来。那么一样的，3D也是声明、初始化、绘制三个工作。只是2D中无论是初始化还是绘制都是相对简单的，3D就要复杂的多的多，跟着步骤走吧。</p>

<hr />

<p><strong>第一步、创建模型，确定视角</strong></p>

<p>似乎看了标题就有些茫然，有很多的概念要讲，不过和2D教程一样，先直接说代码怎么写，回头再讲大道理。（本文后面将会有官方解释的翻译内容）</p>

<p><strong>1、声明场景模型</strong></p>

<p>代码找到Game1类中最前面，SpriteBatch spriteBatch;这一行的下方，在这里我们先插入这样两行代码。</p>

<pre><code>Model terrainModel;
Vector3 terrainPosition = Vector3.Zero;
</code></pre>

<p>这里用到了XNA Framework提供的Model类，以及Vector类。</p>

<p>显然，terrainModel这样的命名让人比较容易理解，就是场景模型，这是我们的场景或者说是地面模型，都一样，就是我们的大环境。</p>

<p>而terrainPostision就更加容易理解了，是terrain的位置，究竟整个地表是怎样的一个位置。这里我们用Vector3这个类来描述。Vector3是一个3维的向量，就像Vector2是X,Y两个轴的向量一样，Vector3实质上就是把Vector2扩展到X,Y,Z，3个轴的向量。初始化为Vector3.Zero，即在整个3维坐标系的原点上。</p>

<p>和2D游戏不同，我们2D游戏所有涉及到的坐标都是在屏幕范围内的。我们知道屏幕向右是X轴正方向，向下是Y轴正方向，所以所有的坐标都是在这样一个坐标系上想象的。而3D游戏则不同，我们必须把这些位置都想象在自己的脑海中，因为屏幕看见的什么只是你3D世界的一角，你必须在整个思维中存在你的自己的一个三维世界，它所在的一个三维坐标系和它的所有坐标。然后我们再讨论从什么视角（什么坐标）去看这个世界。</p>

<p><strong>2、声明镜头</strong></p>

<p>说明一下，这里的镜头英文应当是camera，翻译成相机这样子比较好。不过也许很多像我一样的游戏玩家会知道，一般我们评价一个游戏，会说镜头能控制不能控制等等，所以我想这个词会更加容易被接受。我的文章里的镜头，指的就是camera。可以想象你的眼睛就是你看这个现实世界的camera。</p>

<p>在刚才两行代码下面，继续写以下内容。</p>

<pre><code>Vector3 cameraPosition = new Vector3(0.0f, 60.0f, 160.0f);
Vector3 cameraLookAt= new Vector3(0.0f, 50.0f, 0.0f);
Matrix cameraProjectionMatrix;
Matrix cameraViewMatrix;
</code></pre>

<p>详细说一下我们做了什么。</p>

<ul>
<li><p>cameraPosition：这是镜头所在的位置，比如我们的眼睛在脸上这样的描述。这里是(0, 60, 160)这样一个位置。</p></li>
<li><p>cameraLookAt：镜头的焦点。可以想象一下terrain被放在Y轴也就是高度轴的0上，镜头被放在Z轴也就是深度轴的160的位置，高度是60的位置，而它看着Y轴上50的那点，连成的直线就是你的视线了。</p></li>
<li><p>cameraProjectionMatrix：镜头投影矩阵。</p></li>
<li><p>cameraViewMatrix：镜头视角矩阵。关于两个矩阵，先不详细讲了。图形学中涉及到了任意点的变换可以使用矩阵，矩阵变换是一个图形学非常重要的概念。稍微讲一下。</p></li>
</ul>


<p>矩阵变换一般情况下有平移、缩放、旋转。各种复杂的变化都可以由很多这样的操作完成。其他还有诸如投影、切割等等。所有的变化都可以最终表示成为一个矩阵，这就是变换矩阵。不详细讲，举3个例子。</p>

<p><strong>例一</strong>：平移 W(wx,wy,wz)</p>

<p><img src="/upload/2009-07-03_Matrix1.jpg" alt="" /></p>

<p><strong>例二</strong>：缩放 T(tx,ty,tz)</p>

<p><img src="/upload/2009-07-03_Matrix2.jpg" alt="" /></p>

<p><strong>例三</strong>：绕X轴旋转alpha度</p>

<p><img src="/upload/2009-07-03_Matrix3.jpg" alt="" /></p>

<p>当然在XNA framework里封装的Matrix类不是一个简单的矩阵的实现了，还加上了很多智能的功能，当然也包括变换，至于如何使用这样一个Matrix，以及我们声明的Matrix是做什么样的变换的，看下去。</p>

<p><strong>3、初始化变换矩阵</strong></p>

<p>我们要初始化声明的资源，那么就要找到LoadContent()方法，在其中TODO的位置加上这样两句。</p>

<pre><code>cameraViewMatrix = Matrix.CreateLookAt(
    cameraPosition,
    cameraLookAt,
    Vector3.Up);
cameraProjectionMatrix = Matrix.CreatePerspectiveFieldOfView(
    MathHelper.ToRadians(45.0f),
    graphics.GraphicsDevice.Viewport.AspectRatio,
    1.0f,
    10000.0f);
</code></pre>

<p>这里做的工作是实例化两个Matrix，但是这里用到了Matrix类中的CreateLookAt和CreatePerspectiveFieldOfView方法。说下参数的意思。</p>

<ul>
<li><p>CreateLookAt：</p>

<ul>
<li><p>cameraPosition：Vector3，镜头所在位置</p></li>
<li><p>cameraLookAt：Vector3，镜头焦点坐标</p></li>
<li><p>Vector3.Up：Vector3，按照MSDN所说传入&#8221;上&#8221;就好，当然你可以试一下其他方向……</p></li>
</ul>
</li>
<li><p>CreatePerspectiveFieldView：</p>

<ul>
<li><p>MathHelper.ToRadians(45.0f)：float，视角大小</p></li>
<li><p>graphics.GraphicsDevice.Viewport.AspectRatio：float，窗口的比率，&#8221;宽&#8221;比上&#8221;长&#8221;的比率</p></li>
<li><p>1.0f：float，镜头最小深度（近处）</p></li>
<li><p>10000.0f：float，镜头最大深度（远处）（恐怕真三国无双和GTA这样的游戏里面这个参数的体会会比较深刻）</p></li>
</ul>
</li>
</ul>


<p>初始化完毕，就可以接下去继续了。</p>

<hr />

<p><strong>第二步、编写模型绘制方法</strong></p>

<p>因为游戏中将会出现很多很多的模型，虽然每一个模型都有其特殊的地方，但是每一个模型都将拥有一个默认的绘制方式。而，即便采用默认的方式，绘制模型也将会涉及到很多操作，所以将本来可以在draw方法中完成的内容单独的写一个方法来完成。方法传入的参数为模型和其所在的位置，这样我们的方法就可以把它用一样的操作绘制出来。</p>

<p>这里涉及到一个ModelMesh的类，每一个Model都一个很多的ModelMesh的集合，因此我们需要单独绘制每一个mesh。至于ModelMesh和Model的概念，在后面会加上说明。（本文后面将会有官方解释的翻译内容）</p>

<p>具体方法是，在Game1类中重新写一个方法，当然是任意位置的，代码具体如下。</p>

<pre><code>void DrawModel(Model model, Vector3 modelPosition)
{
    foreach (ModelMesh mesh in model.Meshes)
    {
        foreach (BasicEffect effect in mesh.Effects)
        {
            effect.EnableDefaultLighting();
            effect.PreferPerPixelLighting = true;
            effect.World = Matrix.CreateTranslation(modelPosition);
            effect.Projection = cameraProjectionMatrix;
            effect.View = cameraViewMatrix;
        }
        mesh.Draw();
    }
}
</code></pre>

<p>如参正如之前所说，一个是Model类，一个是Vector3类，分别表示要绘制的模型和其所在的位置。</p>

<ul>
<li><p>第一个foreach循环是遍历Model中所有的ModelMesh，单独处理每一个。</p></li>
<li><p>第二个foreach循环是遍历ModelMesh中的Effects，单独处理每一个效果的处理。具体看看做了一些什么</p>

<ul>
<li><p>EnableDefaultLighting()：设定光源为默认光源。</p></li>
<li><p>effect.PreferPerPixelLighting = true;：在支持Pixel Shader Model 2.0的情况下，开启每个像素按光源渲染的效果。</p></li>
<li><p>effect.World = Matrix.CreateTranslation(modelPosition);：创建传入模型的矩阵变换</p></li>
<li><p>effect.Projection = cameraProjectionMatrix;：设定投影变换矩阵。</p></li>
<li><p>effect.View = cameraViewMatrix;：设定视角变换矩阵。</p></li>
</ul>
</li>
</ul>


<p>这样，我们就完成了绘制方法的编写。但是不要忘了，我们还没有加载需要绘制的模型，也没有在draw方法中调用这个方法，所以看接下去的两步，完成这两个工作。</p>

<hr />

<p><strong>第三步、加载模型</strong></p>

<p>载入模型才能画，载入模型的方法和2D的一模一样，只是一个操作的是Sprite，一个操作的是Model，但是我们知道LoadContent方法是支持范型的，那么显然我们的工作就变得非常的简单了。</p>

<p>找到LoadContent方法，在之前添加的代码下面加上如下代码。</p>

<pre><code>terrainModel = Content.Load&lt;Model&gt;(@"Modelsterrain");
</code></pre>

<p>这样，这一步就简简单单的完成了。</p>

<hr />

<p><strong>第四步、绘制模型</strong></p>

<p>之前第二步完成的工作就大大简化了这一步我们的代码了。而这一步我们就只要调用之前我们写的drawModel方法，并且传入我们的模型和位置就可以了。</p>

<p>在Draw方法的TODO处，加入以下代码：</p>

<pre><code>DrawModel(terrainModel, terrainPosition);
</code></pre>

<p>还等什么呢？现在就是编译运行的时候了！效果图。</p>

<p><a href="/upload/2009-07-03_Runtime.jpg"><img src="/upload/2009-07-03_Runtime.jpg" alt="" /></a></p>

<p>下面加了4张修改了参数之后的图，方便理解一些参数。[点击放大]</p>

<p><a href="/upload/2009-07-03_Runtime_Down.jpg"><img src="/upload/2009-07-03_Runtime_Down.jpg" alt="" /></a> <a href="/upload/2009-07-03_Runtime_100CameraHeight.jpg"><img src="/upload/2009-07-03_Runtime_100CameraHeight.jpg" alt="" /></a> <a href="/upload/2009-07-03_Runtime_95Radians.jpg"><img src="/upload/2009-07-03_Runtime_95Radians.jpg" alt="" /></a> <a href="/upload/2009-07-03_Runtime_5000Depth.jpg"><img src="/upload/2009-07-03_Runtime_5000Depth.jpg" alt="" /></a></p>

<ul>
<li><p>cameraViewMatrix实例化，CreateLookAt时，修改第三个参数为Vector3.Down</p></li>
<li><p>cameraPosition声明并实例化时，修改为Vector3(0.0f, 100.0f, 160.0f)</p></li>
<li><p>cameraProjectionMatrix实例化，CreatePerspectiveFieldOfView时，修改第一个参数为90.0f</p></li>
<li><p>cameraProjectionMatrix实例化，CreatePerspectiveFieldOfView时，修改第四个参数为5000.0f</p></li>
</ul>


<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=159"><img src="/upload/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>那么下面就贴翻译的内容，也算是比较重要的东西了，2D和3D游戏的概念上的区别。</p>

<p>（以下翻译为本人原传，未经允许严禁转载。另外，因本人能力有限难免出错，请高手指正。原址点击<a href="http://creators.xna.com/en-US/education/gettingstarted/bg3d/details/4_1">这里</a>。）</p>

<p><strong>1、3D世界：2D游戏和3D游戏之间的区别</strong></p>

<blockquote><p>如果你学习过第一个教程（创建2D游戏），那么你已经变得习惯用2D空间来思维了。位置、方向和动作可以全都用Vector2和一个单独的旋转角度来表示。</p>

<p>这个教程介绍了在三维的概念，和其一系列的新的对象。从根本上，3D世界区别于2D世界的就是新增的第三个坐标轴&#8212;-Z轴，或者说是深度。在XNA Game Studio中，2D世界实质上是一个特殊的，受限制的3D世界的版本&#8212;-你将会在本教程读到的计算也同样在2D中可以读到。</p>

<p>在XNA Game Studio这哦你，3D的变化意味着，取代在平面世界中画静态的Texture2D对象的是绘制用Model类表示的3D模型。Model类是被叫做网络（mesh）的许多有联系的3D点的集合，在整个世界中，最终渲染在屏幕上的对象，取决于对象的位置和方向，和镜头的位置和方向。</p>

<p><a href="/upload/BG_4.4.1.1pd.png"><img src="/upload/BG_4.4.1.1pd.png" alt="" /></a>这过程也许初看十分复杂，但其实在3D世界编程，只依靠一些非常基本的元素。想象一个点在3D空间中，一个点有一个X坐标,一个Y坐标,和一个Z坐标。非常类似2D空间中的一个点，3D空间中的一个点也可以使用一个向量来移动，但是在3D空间中，我们使用包含Z坐标的Vector3类。</p>

<p>然而，使用一个叫做矩阵的数学结构体，可以使3D点做更多的事情。这些结构体，在XNA Framework中表示为Matrix类，它描述了一系列可以应用于点的变换、点的集合、或一个响亮。使用矩阵，3D对象可以移动、旋转、切割、以及（通过使用被叫做视点矩阵和投影矩阵的特殊的矩阵）绘制成一个可以显示在屏幕上的2D图像。</p>

<p>想象有一系列我们想画在屏幕上的3D世界中的点。它们拥有相对于被叫做原点的中心点的位置和方向信息。如果没有任何的变换，这些点只是存在于他们自己的空间，被叫做&#8221;对象空间&#8221;。</p>

<p>当你加载一系列的点，并且把它们添加到你的3D世界中，你可能会想给他们一个在3D世界中的位置，用来旋转或切割他们。这些行动的产物被叫做世界变换矩阵。应用了这样的矩阵的点，就被想象成在&#8221;世界空间&#8221;中（而不是对象空间中）了。</p>

<p>来渲染在用户屏幕上的点，需要一些附加的信息。没有要绘制的2D场景的角度和位置，是不可能把整个3D常见转换到2D图像的。使用一个视点是必要的，也被称作镜头，只需绘制它所看到的3D场景。在准备这次绘制时，镜头信息会被计算到一个视角矩阵中，把3D点的方向和位置都和镜头联系起来。之后，这些3D点就被想象成在&#8221;视觉空间&#8221;中了。</p>

<p>用2D绘制一个3D场景最后还需要一些其他信息。像视点的视角和领域的信息，控制着3D点如何绘制在2D计算机屏幕上。这些信息存储在一个投影矩阵中，应用之后，把3D坐标的系统中的点转换到2D坐标系统中，2D坐标系统被成为&#8221;屏幕空间&#8221;，这样点被绘制成像素。</p>

<p><a href="/upload/BG_4.4.1.2pd.png"><img src="/upload/BG_4.4.1.2pd.png" alt="" /></a></p>

<p>如果要套用这个概念到3D点的集合所组成的网络（mesh）上（可以是3D表示的任何东西，一个飞船、一个人、或一只恐龙），你只需用到一些在XNA Framework中的基本的对象来制作你的游戏&#8212;-Mesh类，Matrix类和Vector类。</p></blockquote>

<p><strong> 2、创建一个模型绘制方法</strong></p>

<blockquote><p>绘制一个3D模型到屏幕上是一个复杂的工作。它包括了庞大数据量的多边形的绘制，而它们经常被构造成许多不同的方式。有些可能是基于艺术效果的，而有些也许是倾向于程序化的。绘制同时也是必要的工作。每个游戏中可见的3D对象都是需要经过一个绘制过程的。</p>

<p>毫无悬念的，不是只有一种组织一个模型绘制方法的方式。参数、界限以及绘制算法对每个游戏来说都是不同的，取决于游戏的需求和涉及的技术。在这样的情况下，XNA Framewrok没有尝试去提供一个单独的模型绘制方法。取而代之的是提供一些元素，而把组织它们的工作留给了程序员来做。</p>

<p>一个Model类是XNA Framework中表示3D模型的一个基本对象，但是它比最初的模型要复杂许多。一个模型由一个或多个ModelMesh对象以一个集合的形式组成。每个ModelMesh对象是一系列组成网络（mesh）的顶点的集合，它们可以在同一个模型中被单独的移动。</p>

<p>一个坦克的模型是一个很好的例子。坦克的身体也许是一个ModelMesh，坦克的炮台也许是另外一个。虽然你绘制的是整个坦克，但是你可能需要分开移动坦克的不同部分。你可以使用ModelMesh对象的集合来移动不同的部分。</p>

<p>ModelMesh包含了一个绘制方法。每绘制一个ModelMesh到屏幕上需要调用这个方法一次。然而如果你没有实现设定变换和MedelMesh上的光的属性，那么你什么也看不到。</p>

<p>变换（决定了ModelMesh在世界中的定向，并且最终，物体是否出现或是出现在屏幕的哪里）和光（）没有被应用到ModelMesh层面。相对的，每个ModelMesh有一些Effect和它联系在一起。一个Effect对象可以想成提供给可视设备的说明，关于如何绘制一个ModelMesh。</p>

<p>在很多游戏中，Effect对象是由很多复杂的顶点和像素遮罩（shader）组成的。在XNA Game Studio中也可以实现，并且对于高级图形效果来说十分重要。但是在简单的渲染中，XNA Framework Content Pipline（内容管道）提供了一个简单的机制来完成基本的光和绘制效果 &#8212;- BasicEffect类。</p>

<p>每个通过content pipline加载的ModelMesh接受了一个或多个BasicEffect对象，它们可以在不处理像素或顶点遮罩（shader）的情况下简单的处理变换和光源效果。所有这些BasicEffect类需要一系列表示世界（World）矩阵，视点（View）矩阵和投影（Projection）矩阵的Matrix类，和一些光照的参数。可以调用BasicEffect.EnableDefaultLighting()方法获得默认的参数。</p>

<p>在BasicEffect的参数被设置后，剩下的就只有调用ModelMesh.Draw方法，使用之前为BasicEffect设置的参数，来绘制ModelMesh到屏幕上了。</p>

<p><a href="/upload/BG_4.4.2.1pd.png"><img src="/upload/BG_4.4.2.1pd.png" alt="" /></a></p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-04T03:50:05+08:00" pubdate data-updated="true">Jul 4<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch3-add-assets/">
		
			XNA教程-3D游戏-03-添加Asset</a>
	</h2>
	<div class="entry-content">
		<p>到了这里其实还是和2D的教程是重叠的，这里我们要做的是添加asset们。所以这里你要问自己三个问题：</p>

<ol>
<li><p>你已经建立了工程（project）了吗？&#8212;- <a href="http://arthraim.cn/post/2009/06/72.html">点我补课</a></p></li>
<li><p>你已经下载了上一部分要求下载的资源了吗？&#8212;- <a href="http://creators.xna.com/downloads/?id=157">点我下载</a></p></li>
<li><p>你知道什么是asset吗？你看过之前2D教程的添加asset内容吗？&#8212;- <a href="http://arthraim.cn/post/2009/06/63.html">点我补课</a>（重点浏览链接指向的文章的后半部分，讲解什么是asset）</p></li>
</ol>


<p>三个问题过关的，再来看我的这里的屁话。放假回家，所以把编译一个XNA游戏都要3分钟的windows xp给格掉了（关注我的twitter的一定知道了），所以把windows 7的引导也格掉了。因为找不到之前安装windows 7的那张光盘，所以一下子没有修复引导，所以这一次的教程就先用XP完成了。装了3、4的系统，终于把一个一个的东西下载下来给装上了，现在可以继续了。</p>

<p>OK言归正传，看看这一次要做的是如何简单。和2D类似的右键添加等等工作，就能完成了。</p>

<p><strong>第一步、添加models到工程的content中</strong></p>

<p>Content中的asset可以在content pipeline中被我们调用。这是一个非常方便的设计，当然这也使得我们这一步的工作显得非常重要，你可以从磁盘去读取一些你需要的资源，但是让他在content管道中，会大大方便你的管理。</p>

<p>2D教程中，我们加入一些.tga资源到Content/Sprites中，我们右键新建文件夹，然后添加存在的资源等等这样完成了这部工作，那么这一次和视频一样，我们偷懒一下。直接把解压缩出来的models文件夹拖到VS2008的树状Solution Explorer的Content目录上，来完成这一步工作。</p>

<p>添加进来之后，我们看到了一些.fbx文件和.tga文件，fbx就是我们的模型，而tga是这些模型对应的贴图，不会被我们实际的工作主动调用到，他们只要在他们应该在的磁盘位置上就可以了，在我们调用模型的时候，相关联的贴图会自动被寻找，所以把他们排除我们的工程吧。右键选择所有的.tga文件，选择&#8221;Exclude From Project&#8221;将其排除工程。</p>

<p><a href="/upload/2009-07-01_ExcludeTgas.JPG"><img src="/upload/2009-07-01_ExcludeTgas.JPG" alt="" /></a></p>

<p><strong>第二步、添加audio到工程的content中</strong></p>

<p>这还分成两步看起来有点傻，一样的，把解压缩出来的audio文件夹也一并拖到Solution Explorer的Content目录上。展开Audio文件夹，右键点击Waves目录，选择&#8221;Exlude From Project&#8221;，把这些.wav文件全部排除在工程之内。因为对于声音的asset处理会有很大的不同，所以这里我们暂时先这样处理就好。</p>

<p>准备就绪之后，就可以开始代码阶段的工作了。</p>

<p>【官方工程下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=158"><img src="/upload/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-02T00:17:14+08:00" pubdate data-updated="true">Jul 2<span>nd</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch2-create-solution/">
		
			XNA教程-3D游戏-02-创建游戏工程</a>
	</h2>
	<div class="entry-content">
		<p>进行了之前的工作，搭建了环境之后，现在就要进入实际开发过程了。我想过程和2D也许存在着一些区别，但是还是相对比较依赖2D教程的，尤其像这一章和3D的确是别无二致，不过我这里还是按照步骤说一下。（参考：<a href="http://arthraim.cn/post/2009/06/62.html">《XNA教程-2D游戏-Chapter2-创建游戏工程》</a>）</p>

<p>使用GS3.1+VS2008是基于.NET Framework 3.5的，否则一些新特性将不会被用到，如果你的开发使用其他环境，那么也许会不一样。</p>

<p>具体涉及到一些可能和2D教程重复的东西，看过2D的直接跳过就好。</p>

<p><strong>第一步、Visual Studio简单介绍</strong></p>

<p>安装高于Visual Studio 2005 Express的版本，并且装好XNA Game Studio（2.0以上）。那么如果安装成功的话，在VS的新建对话框中应该可以看到这么几项（GS3.1+VS2008，不保证其他版本有一样的工程）</p>

<p><a href="/upload/2009-06-27_NewProject.jpg"><img src="/upload/2009-06-27_NewProject.jpg" alt="" /></a></p>

<blockquote><ul>
<li><p>Windows Game (3.1) &#8212;- XNA Game For Windows游戏的开发，很多游戏打着这个标志</p></li>
<li><p>Windows Game Library (3.1) &#8212;- Windows游戏类库</p></li>
<li><p>Xbox 360 Game (3.1) &#8212;- Xbox360游戏</p></li>
<li><p>Xbox 360 Game Library (3.1) &#8212;- Xbox360游戏类库</p></li>
<li><p>Zune Game (3.1) &#8212;- Zune游戏</p></li>
<li><p>Zune Game Library (3.1) &#8212;- Zune游戏类库</p></li>
<li><p>Content Pipeline Extension Library (3.1) &#8212;- Content管道扩展库</p></li>
<li><p>Platformer Starter Kit (3.1) &#8212;- 一个游戏示例（提供windows x360 zune三种版本都有）</p></li>
</ul>
</blockquote>

<p><strong>第二步、新建工程，获取资源</strong></p>

<p>根据刚才介绍的新建，建立相应的工程。</p>

<p>比如我新建一个Windows Game (3.1)工程，并且取名为TChapter2，那么我们可以得到一些IDE为我们创建的文件，具体情况如下。</p>

<blockquote><ul>
<li><p>Content &#8212;- 就是一切我们需要的游戏资源，在XNA中存在Content Pipeline这个概念，而这里的所有资源可以之后在Content管道中直接调用加载。</p></li>
<li><p>Game1.cs &#8212;- 游戏逻辑代码。</p></li>
<li><p>Game.ico &#8212;- 不用多说，一个Xbox360的手柄样式的ico图标。</p></li>
<li><p>GameThumbnail.png &#8212;- 正如他的名字，是一个缩略图，当然要你自己画的啦。</p></li>
<li><p>Program.cs &#8212;- 就是程序的入口Main方法了。</p></li>
</ul>
</blockquote>

<p><strong>第三步、下载资源</strong></p>

<p>接下去本章很重要的一部就是下载必须的游戏素材。这里提供官方链接，下载解压缩后就可以看到我们本教程的例子要用到的全部素材了。</p>

<p><a href="/upload/2009-06-27_files1.JPG"><img src="/upload/2009-06-27_files1.JPG" alt="" /></a> &#8230;/Audio/Waves/</p>

<p><a href="/upload/2009-06-27_files2.JPG"><img src="/upload/2009-06-27_files2.JPG" alt="" /></a> &#8230;/Models/</p>

<p>【点击下载官方素材】</p>

<p><a href="http://creators.xna.com/downloads/?id=157"><img src="/upload/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-27T10:08:42+08:00" pubdate data-updated="true">Jun 27<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch1-introduction/">
		
			XNA教程-3D游戏-01-3D游戏教程简介</a>
	</h2>
	<div class="entry-content">
		<p>在之前，我把所有的2D视频教程都用文字重新写了一遍，也完成了2D教程中完成的那个例子，应该说，如果是XNA变成从无到有的话，那收获已经颇为丰富了。并且，教程中所有的More Details（原视频教程的页面）我也都进行了翻译，一部分还加上了一些自己的说明。应该说，无论是机械的完成代码学会技能，还是了解一些XNA提供的实质性内容，都起到了很大的作用。</p>

<p>之后正好面临我的期末考试，一个学期也就这么几天读书的，总要成全我吧。所以加上复习和考试，暂停了那么几天博客的更新，也算是之前一星期之后的小小的休息吧。现在回家放暑假，休息了几天之后，我决定继续开始3D的教程了，利用之前在2D学到的东西，我们应该可以轻松的进入3D的学习了。</p>

<p>在3D的教程中，我们将完成一个2D教程中的demo中的3D版本。我们要完成一些类似的东西，也会接触一些新的东西。</p>

<ol>
<li><p>建立自己的3D环境 &#8212;- 毕竟是3D游戏了，所以不单单是像2D一样画一个背景就好了，我们需要建造自己的3D外太空环境。</p></li>
<li><p>添加加农炮 &#8212;- 同样内容相似的，我们需要一个可以旋转的加农炮，只是这次的旋转是在3D环境中了。</p></li>
<li><p>添加炮弹 &#8212;- 加农炮设计的炮弹，也将在3D环境中处理，当然其实也就是初速度稍许不同，接触到之后就会发觉到2D教程的作用了。</p></li>
<li><p>添加敌方UFO &#8212;- 还是类似的，UFO从屏幕的远端向近端飞来，而不是右侧飞到左侧了哦。</p></li>
<li><p>碰撞检测 &#8212;- 3D的碰撞检测。</p></li>
<li><p>添加声效 &#8212;- 之前2D的游戏是没有声音的，这一次的3D中我们将加入声音，者是新的内容，会十分有趣的。</p></li>
</ol>


<p>大致的内容就是这样。当然，如果你没有看2D的教程，直接开始3D的也是可以的，只是和2D对比的部分直接略去就可以了。另外，本教程使用XNA Game Studio 3.1开发，如果你是使用的是之前的版本，或者是未来的某个版本，那么其中也许会有一些不同之处。如果你刚刚开始，那么就赶快装上Game Studio开始吧。</p>

<p><strong>相关链接：</strong></p>

<ul>
<li><p><a href="http://arthraim.cn/post/2009/06/61.html">XNA教程-2D游戏-索引</a></p></li>
<li><p><a href="http://creators.xna.com/en-US/education/gettingstarted/bg3d/chapter1">XNA Creators Club 教程原址</a></p></li>
<li><p><a href="http://creators.xna.com/en-us/news/xnagamestudio3.1">XNA Game Studio 3.1 介绍及下载地址</a></p></li>
<li><p><a href="http://arthraim.cn/post/2009/06/60.html">环境配置及安装的简单介绍请看《XNA Game Studio 3.1 Available》</a></p></li>
</ul>


<p><strong>Demo效果图：</strong></p>

<p><a href="/upload/2009-06-27_Glance.jpg"><img src="/upload/2009-06-27_Glance.jpg" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-25T22:47:25+08:00" pubdate data-updated="true">Jun 25<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-index/">
		
			XNA教程-2D游戏-目录索引</a>
	</h2>
	<div class="entry-content">
		<p><a href="/upload/XNA_logo.jpg"><img src="/upload/XNA_logo.jpg" alt="" /></a></p>

<p><strong>2011-01-16更新：换了域名和URL，更新一下链接~</strong></p>

<p>XNA GameStudio 3.1，微软XNA Creators Club Online上2D游戏视频教程文字版索引。</p>

<p><strong>XNA游戏教程.2D</strong></p>

<ol>
<li><p><a href="/xna-tutorial-2d-ch1-introduction/">2D游戏教程简介</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch2-create-solution/">创建游戏工程</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch3-add-assets/">添加Asset</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch4-rending-backgrounds/">绘制背景</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch5-create-a-cannon/">添加一门加农炮</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch6-launch-missiles/">发射炮弹</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch7-create-enemy-ufo/">添加敌人UFO</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch8-destroy-ufo/">摧毁UFO</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch9-record-scores/">记录分数</a></p></li>
<li><p>其他扩展：<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/ExtraCredit">Extra Credit - Community Tutorials</a></p></li>
</ol>


<p><strong>相关知识点链接</strong>（在各个章节中涉及到的知识点，基本上都在文章的末尾）：</p>

<ol>
<li><p><a href="/xna-tutorial-2d-ch3-add-assets/">什么是Asset？</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch4-rending-backgrounds/">Content Pipeline是如何工作的？</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch4-rending-backgrounds/">Sprites，Sprites绘制，和SpriteBatch。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch5-create-a-cannon/">为什么要创建GameObject类？</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch5-create-a-cannon/">XNA Game Studio中表示的角。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch6-launch-missiles/">使用数组。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch6-launch-missiles/">转化一个旋转角度为速度向量。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch7-create-enemy-ufo/">随机数和线性插入方法Lerp。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch8-destroy-ufo/">使用Rectangle的2D碰撞检测。</a></p></li>
</ol>


<p><strong>原视频教程链接</strong>：<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/chapter1">这里</a></p>

<p><strong>系列3D教程目录索引</strong>：<a href="/xna-tutorial-3d-index/">这里</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-19T08:18:48+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch9-record-scores/">
		
			XNA教程-2D游戏-09-记录分数</a>
	</h2>
	<div class="entry-content">
		<p>游戏基本上已经什么都有了，不过接下去还有一些工作 &#8212;- 记分。通过击毁UFO来获得分数，这是一个简单的功能，不过还是什么必要的，因为我们不单单是记住分数，还要把它显示在屏幕上，所以如何在屏幕上显示字符才是关键所在。如果你愿意，可以显示一些其他信息，比如常见fps等等。</p>

<p>那么接下来，介绍方法。</p>

<p><strong>第一步、添加Font到Content中</strong></p>

<p><strong>一、添加SpriteFont的Content资源。</strong></p>

<p>要在Content pipline中添加SpriteFont（字体）的内容。</p>

<ol>
<li><p><strong>Content中添加一个Fonts文件夹</strong>。</p>

<p>   <img src="/upload/2009-06-19_AddFontToContent.jpg" alt="" /></p></li>
<li><p><strong>在Fonts中添加一个GameFont对象</strong>。</p>

<p>   [<img src="/upload/2009-06-19_AddSpriteFont.jpg" alt="" /></p>

<p>   ](/upload/2009-06-19_AddSpriteFont.jpg)</p></li>
<li><p><strong>修改XML文件</strong>。具体参照如下代码，字体和字体大小的修改。</p></li>
</ol>


<pre><code>&lt;FontName&gt;Arial&lt;/FontName&gt;
&lt;Size&gt;18&lt;/Size&gt;
</code></pre>

<p>好了，这样准备工作就完成了，我们可以在之后的Content的相关操作中使用这个font了。</p>

<p><strong>二、声明一些新变量</strong></p>

<p>声明一个int型的分数。</p>

<p>声明一个SpriteFont对象当作字体。</p>

<p>声明一个Vector2来记录分数显示的位置（百分比）。</p>

<pre><code>int score;
SpriteFont font;
Vector2 scoreDrawPoint = new Vector2(0.1f, 0.1f);
</code></pre>

<p>就像之前说的，微软的大大们都有强大逻辑，可以在开始写程序的时候声明出所有的变量。</p>

<p><strong>三、Content载入字体</strong></p>

<p>在LoadContent方法中载入我们感概添加和修改的字体。</p>

<pre><code>font = Content.Load&lt;SpriteFont&gt;(@"FontsGameFont");
</code></pre>

<p>这样，我们就可以自由的使用了。</p>

<hr />

<p><strong>第二步、添加记分逻辑</strong></p>

<p>视频中的逻辑是击毁一个UFO加一分，所以在判断碰撞的地方加上score++就好。</p>

<p>我设计的逻辑击毁加2分，漏掉一个（飞出屏幕）扣一分。</p>

<p>当然你可以设计更加复杂的功能，比如距离远速度快的3分等等，总之分数不是关键。</p>

<hr />

<p><strong>第三步、绘制分数</strong></p>

<p>绘制我们记分的结果，在Draw这个方法的SpriteBatch.End()之前加入绘制字符串的代码。</p>

<pre><code>spriteBatch.DrawString(
    font,
    "Score:" + score.ToString(),
    new Vector2(
        scoreDrawPoint.X * viewportRect.Width,
        scoreDrawPoint.Y * viewportRect.Height),
    Color.White);
</code></pre>

<p>看一下参数。</p>

<ol>
<li><p>SpriteFont，要求传入一个SpriteFont，我们这里传入了之前创建的font。</p></li>
<li><p>string，传入要显示的字符串，这里是得分。</p></li>
<li><p>Vector2，传入一个显示位置（左上角）的Vector2，这里我们利用之前创建的百分比和屏幕大小计算出一个新的Vector2</p></li>
<li><p>Color，传入一个字形的颜色。</p></li>
</ol>


<p>好了，这样我们的游戏就完整的完成了。放一张运行时的截图。</p>

<p><a href="/upload/2009-06-19_Chapter9_Runtime.jpg"><img src="/upload/2009-06-19_Chapter9_Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=156"><img src="/upload/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-19T08:03:20+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch8-destroy-ufo/">
		
			XNA教程-2D游戏-08-摧毁UFO</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 08 &#8211; 摧毁UFO</strong></p>

<p>这一次要做的是很NB的事情，碰撞检测（Collision Detection），具体到我们的例子，具象一点的，那么就是摧毁UFO，当然在无数游戏中，碰撞检测都是至关重要的东西，和随机比起来不相上下吧。无论是什么游戏类型，物体和物体之间的接触都是要处理的，尚且不说加上什么物理特性，光是这个例子里的子弹碰UFO总要有点反应吧。更不用说什么火星撞地球了………………</p>

<p>具体代码很简单，找到UpdateCannonBalls方法，在更新的时候，添加一种杀掉UFO和炮弹的情况，就是两者碰撞的时候。</p>

<p>大致的思路为：</p>

<ol>
<li><p>确定每个炮弹的范围大小和UFO的范围大小。</p></li>
<li><p>遍历每个炮弹。</p></li>
<li><p>遍历中每个炮弹再要遍历每个UFO。如果发生碰撞就同时摧毁两个（alive = false）</p></li>
</ol>


<p>这里我们要用到的碰撞检测，直接使用XNA的Rectangle的intersect方法。以下是代码，添加在判断是否出屏幕的下面。</p>

<pre><code>Rectangle cannonBallRect = new Rectangle(
    (int)ball.position.X,
    (int)ball.position.Y,
    ball.sprite.Width,
    ball.sprite.Height);
foreach(GameObject enemy in enemies)
{
    Rectangle enemyRect = new Rectangle(
        (int)enemy.position.X,
        (int)enemy.position.Y,
    enemy.sprite.Width,
    enemy.sprite.Height);
    if(cannonBallRect.Intersects(enemyRect))
    {
        ball.alive = false;
        enemy.alive = false;
        break;
    }
}
</code></pre>

<p>首先获得当前遍历到的cannonBall的范围，循环。循环中得到当前UFO的范围，检测是否和cannonBall相交（哪一方都一样）。碰撞了，就两个对象的alive都为false，然后break出UFO的循环。</p>

<p>执行结果（其实截图看不出来效果唉）</p>

<p><a href="/upload/2009-06-18_Chapter8Runtime.jpg"><img src="/upload/2009-06-18_Chapter8Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=155"><img src="/upload/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>翻译：使用Rectangle的2D碰撞检测</strong></p>

<p>（以下文字由本博客翻译自这里，转载请注明出处）</p>

<blockquote><p>图片创建的Sprite从一创建就必然是一个长方形。你可以使用遮盖(Mask)，来绘制Sprite中的一部分像素，这样就产生了Sprite不是一个长方形的视觉效果。Sprite可能呈现为一个圆形的物体，或者更加复杂的形状。但是所有的sprite一创建就都是矩形的。</p>

<p>Sprite的这一特性在非常基本的碰撞检测中很实用，XNA Framework提供了一个Rectangle类，自己就拥有碰撞帮助的方法：ectangle.Intersects，和Rectangle.Contains。</p>

<p>在基本的常识中，碰撞检测是基于相交检测的 &#8212;- 两块几何图形是否相交。如果两个几何图形相交，他们可以说是碰撞，游戏逻辑可以根据碰撞的物体产生适当的反应。</p>

<p>在我们的2D游戏中，我们关心加农炮是不是和地方UFO相交。如果加农炮的sprite的rectangle相交于敌人sprite的rectangle，那我们的游戏逻辑检测到了一个碰撞，并且同时摧毁两个物体。</p>

<p>Rectangle很容易创建。Rectangle类初始化时需要4个参数 &#8212;- 矩形左上角的点的X和Y坐标，以及矩形的宽度和高度。所有矩形的其他点都会有这些信息计算出来。</p>

<p>创建sprite占用的rectangle之间的碰撞，设置X和Y的值为游戏世界中的sprite的X和Y值，GameObject.position.X和GameObject.position.Y。设置宽度和高度为sprite中的Texture2D的宽度和高度，GameObject.sprite.Width和GameObject.sprite.Height。</p>

<p>凭借两种游戏直接中sprite的rectangle对象的创建和调用Rectangle.Intersects方法，你可以知道两个物体是否碰撞。这可能不是最精确的碰撞。包括还有其他的缺点，如果是屏幕上已经画了的一个旋转过的sprite，rectangle对象的定义就不再符合sprite在屏幕上绘制的样子了。然而这是一个简单高效的方法来做碰撞检测。</p>

<p>一个类似的有用的方法是Rectangle.Contains。在我们的2D游戏中，使用一个rectangle来表示整个屏幕，我们可以定义什么时候GameObject离开了屏幕的边界。我们在比较屏幕rectangle和对象rectangle的时候，使用检查Rectangle.Contains的值是否为false的方法来判断是否离开屏幕。</p>

<p>下面的图表列出了Rectangle.Intersects和Rectangle.Contains两个不同的矩形成员的不同输出情况。</p>

<p><img src="/upload/BG_3.8.1.1pd_a.png" alt="" /></p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-19T06:13:16+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch7-create-enemy-ufo/">
		
			XNA教程-2D游戏-07-添加敌人UFO</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 07 &#8211; 添加敌人UFO</strong></p>

<p>这次要做的就是添加敌人 &#8212;- UFO。我们有了一个防空武器，在一个可恶的看上去非常阴沉的外星球，那我们必须要有人来入侵，这才是建造军用设施的真正目的对吧。所以，程序员真是堪比创世纪的众神了。</p>

<p>加入UFO的方法其实和子弹差不多（记住这句话，因为我后面实在是懒得讲了），它需要它的初速度向量，需要被杀掉，最后需要画在屏幕上，如果稍微改一下，我们完全可以不看教程做到了。添加UFO还涉及到了一个新的概念，就是随机数，游戏中随机是非常重要的东西，几乎没有一个游戏不用到随机概念的，前段时间刚刚过了25岁生日的俄罗斯方块也是。随机，是游戏的灵魂，而我们将用到Random来产生随机数，再使用XNA提供的方法限定我们需要的范围。OK，开始吧。</p>

<p><strong>第一步、创建UFO</strong></p>

<p>我们要声明很多的变量，可能一时半会儿不会知道有什么用。一样的，找到你声明了其他东西的地方，加农炮啦，炮弹啦，手柄和键盘的状态啦之类的，Game类的首部，添加以下代码，代码如下：</p>

<pre><code>const int maxEnemies = 3;
const float maxEnemyHeight = 0.1f;
const float minEnemyHeight = 0.5f;
const float maxEnemyVelocity = 5.0f;
const float minEnemyVelocity = 1.0f;
Random random = new Random();
GameObject[] enemies;
</code></pre>

<p>似乎有很多不明所以的东西，来看看他们都是些什么。</p>

<ol>
<li><p>最大的敌人数，3个，好吧，我一定改了你。</p></li>
<li><p>最大敌人高度，0.1f，似乎可以想到。</p></li>
<li><p>最小敌人高度，0.5f，对啊，正如之前说到的，坐标系的Y轴是越上方越小。</p></li>
<li><p>最大敌人速率，5.0f，恩，敌人的速率是可变的，不错。</p></li>
<li><p>最小敌人速率，1.0f，最小的速度。</p></li>
<li><p>随机对象，一个Random对象，看来是创建随机数用的。</p></li>
<li><p>敌人数组，一个敌人的数组，和子弹一样，只是名字不同而已吧。</p></li>
</ol>


<p>这就是我们第一步完成的事情，之前说过，微软工程师都是强大的存在，可以预见未来，他们可以在刚刚开始写代码的时候就声明好所有将来需要使用的变量。当然，这是个笑话。</p>

<p>之后要初始化这些对象，载入enemy.tga资源。找到LoadContent的位置，在初始化cannonballs的循环下面添加一个for循环。记得之前怎么做的吗？如法炮制。</p>

<pre><code>enemies = new GameObject[maxEnemies];
for (int i = 0; i &lt; maxEnemies; i++)
{
    enemies[i] = new GameObject(
    Content.Load&lt;Texture2D&gt;(@"Spriteenemy"));
}
</code></pre>

<p>不麻烦吧，只是吧cannnonballs的名字换一下就是这里的代码了。继续。</p>

<hr />

<p><strong>第二步、更新UFO位置并杀掉屏幕以外的</strong></p>

<p>第二步做的是更新他们的位置，因为也是GameObject类，所以方法和cannonball一模一样。在Update方法中找到UpdateCannonBalls();这一行，在下面加入：</p>

<pre><code>UpdateEnemies();
</code></pre>

<p>说然后在类的其他任何地方加上我们的UpdateEnemies方法。</p>

<pre><code>public void UpdateEnemies()
{
    foreach (GameObject enemy in enemies)
    {
        if (enemy.alive)
        {
            enemy.position += enemy.velocity;
            if(!viewportRect.Contains(new Point(
                (int)enemy.position.X,
                (int)enemy.position.Y)))
            {
                enemy.alive = false;
                continue;
            }
        }
    }
}
</code></pre>

<p>真的，和CannonBalls一模一样，改一下名称，采用一样的杀掉的方法，这就是UFO移动，位置更新的代码了，目前为止没什么新的东西。</p>

<hr />

<p><strong>第三步、新生UFO</strong></p>

<p>和cannonballs不同，在做cannonballs的工作的时候，先让它射击出来，也就是在按键的一刻，之后在离开屏幕的一刻把它杀掉。而enemies在被处理的时候，是先在他离开屏幕的时候杀掉，可是它从没出现过。所以这一步，我们要让他出现。</p>

<p>要新生一个enemy的GameObject我们要给他一些属性，包括alive要变成true，这是肯定的。然后要给他一个初始的position，一个velocity速度向量，velocity包括了方向，和速率。（所以我始终觉得speed更好）。</p>

<p>然后就是决定，什么时候创建它。它在离开屏幕的时候会死去，那么我们就在它死去之后马上把它救活，所以我们找到上一步的UpdateEnemies方法，在if(enemy.alive){}的后面，加上enemy.alive == false的代码，让它死掉马上活过来，并出现在屏幕的右方。</p>

<pre><code>if (enemy.alive)
{
    // ...其他代码
}
else
{
    enemy.alive = true;
    enemy.position = new Vector2(
    viewportRect.Right,
    MathHelper.Lerp(
        (float)viewportRect.Height * minEnemyHeight,
        (float)viewportRect.Height * maxEnemyHeight,
        (float)random.NextDouble()));
    enemy.velocity = new Vector2(
    MathHelper.Lerp(
        -minEnemyVelocity,
        -maxEnemyVelocity,
        (float)random.NextDouble()),
        0);
}
</code></pre>

<p>看看我们做了什么。</p>

<p>enemy.alive = true; 没错，这是出生证明，起码在某些程度上说明了它活过来了。</p>

<p>enemy.position = new Vector2(); 这当然是给他位置向量，初始化向量要X坐标Y坐标，那X坐标就是屏幕右侧，X轴最大值，viewportRect记录了屏幕大小，调用viewportRect的Right属性，就是我们要的屏幕宽度，也就是X轴最大值。而Y坐标，我们要随机产生一个高度，这样才有游戏的味道。首先，我们用random.NextDouble随机生成一个0到1之间的double类型的随机数，这就是我们得到随机数的方法。但是，它不是我们要的数字，我们需要一个高度差之间的，而不是0到1的。于是这里要讲一下MathHelper.Lerp方法，它需要3个参数，随机数的最小值，随机数的最大值，和随机数。我们使用这个方法，把我们随机产生的那个书限定到我们给的新范围里。其实做法很简单，相信大家都可以写出来，(最大值-最小值)×随机值+最小值，这得到了我们的这个数，不过XNA帮你省去了这些代码（真是细致的过分了 = =），直接帮助得到我们的数。</p>

<p>enemy.velocity = new Vector2()，一样的，也是产生一个新的向量。因为要他笔直的从右往左穿过屏幕，那Y方向没有速度，Y给个0就好了。X则是要随机在我们定下的范围里得到一个数字，方法和position的类似，只是要注意的是，因为我们逆X轴正方向飞行，所以X轴速度是负数。</p>

<p>至此，完成了UFO的全部的Update工作。</p>

<hr />

<p><strong>第四步、绘制UFO</strong></p>

<p>嘿嘿，一样，最后我要画UFO。找到Draw方法，加入一个新的SpriteBatch.draw就可以了。因为UFO不会和加农炮碰撞，所以无论放在背景以上的什么层面都好，只是我觉得起码应该遮掉子弹吧～于是添加代码，又是和cannnonballs一样。</p>

<pre><code>foreach (GameObject enemy in enemies)
{
    if (enemy.alive)
    {
        spriteBatch.Draw(
        enemy.sprite,
        enemy.position,
        Color.White);
    }
}
</code></pre>

<p>We&#8217;re done here. 运行一下看看效果。（我修改了同屏敌人数，因为我的子弹改成是10 = = 并且我发现我的子弹是可以打成一张网的，这游戏没意思了）</p>

<p><a href="/upload/2009-06-16_Chapter7Runtime.jpg"><img src="/upload/2009-06-16_Chapter7Runtime.jpg" alt="" /></a></p>

<p>画面不错。OK，下一次就是要真的用子弹杀掉敌人了～</p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=154"><img src="/upload/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>第三步的补充内容翻译。</strong></p>

<p>这段文字详细讲解了Lerp方法的成因，作用，实现方式，用法，好处等等，可以说非常的详细。</p>

<p>但我个人其实非常不理解，首先我非常不理解为什么（最大值-最小值）×随机值+最小值 这样一个计算就可以完成的事情一定要封装到framework里，虽然那个类的名字叫MaxHelper。另外不理解的地方就是为啥还要用这么多的文字来说明，看了就知道，它用了很多文字来说为什么0到1之间的数可以转化为一个范围内的数，还打了从一个数轴映射到另一个数轴的例子。</p>

<p>只是觉得很有意思而已，美国人做事情有些德国人的味道。看文字吧。</p>

<blockquote><p><strong>随机数和线性插入</strong></p>

<p>在游戏中，随机事件会添加更多的曲折。从随机出现在随机位置的玩家或敌人，到一定几率出现的奖励道具，随机事件可以保持一个游戏的挑战性和乐趣。</p>

<p>怎么才能让你使用一个随机数字来创建随机事件呢？</p>

<p>Microsoft® Visual C# 2005 Express Edition和Visual Studio 2005的包含的标准库中提供了一个实用的类&#8212;-System.Random类。它可以被实例化，也可以生成特定最大范围内的随机整数，或随机生成0到1之间的双精度小数。</p>

<p>乍看之下，产生一个随机证书似乎更管用。在某些情况下，它很管用。举个例子，随机访问你的数组索引，你需要一个整数。但是2D游戏中的数是浮点数，这意味着，他们拥有小数部分。我们需要一些不是严格的整数的数值。打个比方，5到10之间产生一个随机速率。如果我们只是用5到10之间的整数，只有6中可能的数值，这使得速率间的差异性看上去不是那么随机。</p>

<p>一个双精度浮点数之给我们更多范围内数据的变化，使可以转化为更多各种各样的表现。这非常美妙，特别是当我们屏幕上有很多对象拥有不同的位置和速度的时候。</p>

<p>然而，我们的Random类只返回0到1之间的双精度浮点值，或称为double类型的值，却对我们要随机获得5到10之间的数字不怎么实用。你当然可以做一些必要的乘法和加法来让0到1之间的数适应5到10之间这个范围，但是XNA Framework提供了更加简单的方法 &#8212;- MathHelper.Lerp。</p>

<p>Lerp是linear interpolation（线性插入）的缩写，一个数学方法，提供它一些0到1之间的数值T，并提供给它最大值和最小值，它可以计算出一个最大值和最小值之间的输出T。</p>

<p><img src="/upload/BG_3.7.3.1pd.png" alt="" /></p>

<p>把它想象成是在一个最小值和最大值之间的数轴上决定位置，而T是从开始的0到1之间的一条数轴上的某个位置。如果T是0.75，它应该在数轴范围的3/4的位置，在5到10的数轴上就是8.75。照着这个方法，一个0到1之间的数值可以用来在两个浮点数之间找到一个对应的浮点数。</p>

<p>Lerp方法可以用在游戏中需要以恒定速率增加或减少的任何东西。速率、动画、淡出效果或变换颜色 &#8212;- 简简单单传入一个0到1之间的数值T，一个最小值，一个最大值，Lerp会完成之后的所有事情。</p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-16T19:24:54+08:00" pubdate data-updated="true">Jun 16<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch6-launch-missiles/">
		
			XNA教程-2D游戏-06-发射炮弹</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 06 &#8211; 发射炮弹</strong></p>

<p>之前已经完成了很多的工作，创建了GameObject类，实例化了加农炮，并且在屏幕上画出了背景和加农炮。而且加农炮已经拥有了Update的代码，即玩家可以控制这个加农炮了。只是，距离我们的要求，这还远远不够，我们的子弹在哪里呢？加农炮打出来的炮弹呢？没错这就是这一次要完成的。我们要创建能被你发射，并且按方向穿过屏幕的炮弹了。</p>

<p>这一次的工作可谓相对有些复杂了，无论是代码量，还是概念，还是数学知识的要求都有了一定的提升。不过不用慌，我们还是跟着视频一点一点的做下来，最终我们一定能理解只是，并且做好这个东西的。OK，直接进入正题。</p>

<hr />

<p><strong>第一步、修改GameObject</strong></p>

<p>之前说过了GameObject的作用，是用来实例化不同的游戏对象的，那么他的模型应该够健壮，能够实例化各种各样的现实对象。按照我个人的习惯，当然是一个对象一个类，不过既然视频是这么处理，还是跟着做。这里我们要做的很简单，找出之前的GameObject类，我们要添加两个成员变量。</p>

<p>速率：这个速率是指炮弹具有的速度，拥有了这个速度，我们才能慢慢的把它平滑的在画面上移动。不理解没关系，先看下去。</p>

<p>生存：是否生存，我的炮弹如果出了屏幕，那么它就已经消失了，或者说死了，所以这里有个boolean类型的值记录生存或死亡。</p>

<p>当然，这个类也会生成cannon，所以这里可以看一下，加农炮的速率是什么？速率是位移 / 时间，我们的加农炮只有旋转没有位移，很好就是0。再看生存，死亡，它应该一直存在，所以一直是true就好。那么接下来看代码。</p>

<p>先声明。</p>

<pre><code>public Vector2 velocity;
public bool alive;
</code></pre>

<p>然后在构造方法里初始化。</p>

<pre><code>velocity = Vector2.Zero;
alive = false;
</code></pre>

<p>好了，这就是我们要在第一步里完成的全部工作，不用疑惑，接下去做，就知道会发生什么了。</p>

<hr />

<p><strong>第二步、创建Cannonball数组</strong></p>

<p>这里我们要完成的工作是建立一个数组，放上所有可能被发射的炮弹的GameObject，然后把它们初始化。</p>

<p>首先找到Game1.cs，你创建背景和Cannon的地方，在那些代码下面声明两个新的东西。</p>

<pre><code>const int maxCannonBalls = 3;
GameObject[] cannonBalls;
</code></pre>

<p>解释一下，第一个带有const修饰符的是一个常量，maxCannonBalls。意思很明白，就是屏幕上最多出现的子弹数，因为子弹过多会使得update拖慢，那么能进行的draw就很少，所以一上来我们定义成3比较安全。如果过多，可以想见，会出现一帧一帧很卡的效果，像幻灯片一样。而如果加入了一些安全机制，那么就变成了跳帧现象，就是不再计算和绘制。之后一个GameObject[]的数组，就是放无数GameObject用的，至于放多少，是看初始化的。好吧，下面看初始化代码。</p>

<p>找到LoadContent方法，在cannon的相关后面加上以下代码。</p>

<pre><code>cannonBalls = new GameObject[maxCannonBalls];
for (int i = 0; i &lt; maxCannonBalls; i++)
{
    cannonBalls[i] = new GameObject(Content.Load&lt;Texture2D&gt;(
        @"Spritescannonball"));
}
</code></pre>

<p>如果你熟悉C#的话看懂这个没问题，无非就是循环一下，初始化一下。其实用List&lt;>的效率肯定要高一下。但是这里是不可以使用foreach的，因为foreach肯定要求所有的对象都已经实例化了，而我们的工作就是在实例化这些对象。恩，其实这一步已经完成了，这些代码和载入其他Content都是类似的，只是这里遍历了3次而已。下一步吧！</p>

<hr />

<p><strong>第三步、更新cannonball的位置</strong></p>

<p>这一步要更新cannonBalls的每一个ball的位置，当然这里就要用到我们的速度了。只要每一次更新的时候，都加上速率值（一个向量，叫速度更合适，速度是有方向的速率没有），那么它就会自动更新到新的位置了，如果在这个时候把它画出来，就可以看到它在一帧一帧的变换中变换着自己的位置，平滑的移动了一条直线（或其他轨迹，取决于速率或者更像是速度的这个值）。我们把要更新的代码分出一个方法来，叫做UpdateCannonBalls()，如果你坚持，也可以把它们写在Update的方法里，谁都没有强制你。看代码：</p>

<pre><code>protected override void Update(GameTime gameTime)
{
    //...Other code
    UpdateCannonBalls();
    base.Update(gameTime); //必须在这一行代码之前
}
public void UpdateCannonBalls()
{
    foreach (GameObject ball in cannonBalls)
    {
        if (ball.alive)
        {
             ball.position += ball.velocity;
        }
    }
}
</code></pre>

<p>上面是Update方法里的修改，其他代码不去管它，在base.Update(gameTime);之前加上就好。至于下面的方法，就是更新了，放在Game1类中的任何位置都是没有关系的，只要是别的方法的外面，Game类的里面。这里采用了foreach的方法，每一次做一个校验，如果还alive，活着，那么就给他的位置加上速度向量。没错就是这个逻辑。这一步就是这样子。</p>

<hr />

<p><strong>第四步、发射cannonBall</strong></p>

<p>这一步要完成的工作就是发射炮弹了，要知道我们的初始向量才是关键。当然，要知道按键的那一刻，才能确定初始向量。那么首先要做的就是确定按键的相关操作。这里我们需要先声明两个变量。</p>

<pre><code>protected override void Update(GameTime gameTime)
GamePadState previousGamePadState = GamePad.GetState(PlayerIndex.One);
KeyboardState previousKeyboardState = Keyboard.GetState();
</code></pre>

<p>它们会被用来记录上一次Update时候的按键状态，这是为什么呢？看下面的代码。它们中，第一个if语句被添加在Update方法中，你之前完成的cannon.rotation += gamePadState.ThumbSticks.Left.X * 0.1f;这一行的后面。而第二个if语句，放在#if !XBOX和#endif之间的区域内，#endif的上方就可以。当然其实顺序并不是那么重要。</p>

<pre><code>protected override void Update(GameTime gameTime)
if (gamePadState.Buttons.A == ButtonState.Pressed &amp;&amp;
    previousGamePadState.Buttons.A == ButtonState.Released)
{
    FireCannonBall();
}
if (keyboardState.IsKeyDown(Keys.Space) &amp;&amp;
    previousKeyboardState.IsKeyUp(Keys.Space))
{
    FireCannonBall();
}
</code></pre>

<p>解释一下，第一个if是用来检查是否按下X360的手柄上的A键。上一次没有按键，而这一次按键的情况下，即刚刚按键的一刹那，我们实施FireCannonBall()这个方法。而连续按住则不会连续的出发这个方法。另外一个if则是键盘的操作，一样的，只有按下键盘上空格键的那一刹那才会触发。这是操作，究竟触发了，调用了FireCannonBall这个方法要做什么，来看它的实现。</p>

<pre><code>public void FireCannonBall()
{
    foreach (GameObject ball in cannonBalls)
    {
        if (!ball.alive)
        {
            ball.alive = true;
            ball.position = cannon.position - ball.center;
            ball.velocity = new Vector2(
                (float)Math.Cos(cannon.rotation),
                (float)Math.Sin(cannon.rotation)) * 5.0f;
            return;
        }
    }
}
</code></pre>

<p>来分析下代码，首先，我们遍历三个ball，因为最多只有3个，所以用这样的方法就好了（否则应该加上索引什么的，这里不讨论算法），看哪个球还活着，哪个球死了，只有死了的炮弹，我们才能让他再一次活过来，否则就要等到它死掉为止。那么显然，if(!ball.alive)校验后，留下来的就是可以活过来的炮弹，于是我们让他活过来。</p>

<ol>
<li><p>首先设置它的alive属性为ture，证明它活过来了。</p></li>
<li><p>然后设置初始化的位置，是加农炮的位置减去炮弹的中心向量。（这个也许视频里直接ball.position = cannon.position了，那样子会错位）</p></li>
<li><p>然后要设置它的速度了，方向就是当前加农炮的角度，Cos(A)和Sin(A)计算出单位1的向量确定方向，然后乘上5倍使它得到速率。这样一个速度就初始化完成了，这样每一个炮弹会沿着加农炮发射的方向前进而不管你后面的，前面的炮弹如何。至于数学计算，后面会翻译相关资料说明。但其实很容易理解，画个半径为1的圆，然后连成一个三角形，用Sin,Cos就很容易理解了。数学知识。</p></li>
</ol>


<p>还有一个重要的步骤，就是我们还需要让每一次Update后，把当前的键盘（或手柄）状态存入为上一次的键盘（或手柄）状态。代码只有两行。那个标记就不用再多做什么解释了吧，键盘的操作都包含在这个标记里，只是这次我们要重新写一个而已。把这个代码紧贴着base.Update(gameTime);的上方就可以了。</p>

<pre><code>previousGamePadState = gamePadState;
#if !XBOX
previousKeyboardState = keyboardState;
#endif
</code></pre>

<p>这样，我们炮弹的发射就做完了，每一次按键，就会把已经死掉的炮弹重新发射出来，否则就不发射。很容易理解～下一步还没有画，我们要把发出去的杀掉，否则不是我们整个游戏从头到尾只能发射三次吗？</p>

<hr />

<p><strong>第五步、杀掉cannonball</strong></p>

<p>就像刚才说的，游戏从头至尾只能发3个炮弹就太可怕了，它们按照牛顿惯性定律按照初速度朝着遥远的宇宙和未来飞去了。所以，我们要在它们飞出屏幕看不见的那一刹那，就把它们杀掉，资源回收～ 当然杀掉的策略可以有很多，比如碰撞了什么东西（比如将来的UFO），比如限定一定的时间，比如我们使用的飞出屏幕。因为飞出屏幕最符合逻辑，且只需要我们已经定义的这些信息就可以实现，所以采用这个策略。</p>

<p>在UpdateCannonBalls这个方法里，找到ball.position += ball.velocity;这一行，在其后面加上如下代码：</p>

<pre><code>if(!viewportRect.Contains(new Point(
    (int)ball.position.X,
    (int)ball.position.Y)))
{
    ball.alive = false;
    continue;
}
</code></pre>

<p>翻译成中文就是：如果ball所在的位置，转换成一个点，且这个点没有包含在代表了整个屏幕大小的矩形viewportRect当中，那么就把alive改成false，换言之杀掉它。杀掉后继续循环，生怕还有别的一起死掉而漏掉了。</p>

<p>很清晰很明白，就这么简单的三行代码，我们把飞出屏幕的炮弹杀掉了。OK，接下去最激动人心的时刻就要到了。话说微软的教程还真奇怪，一般自己写游戏都会是加一点逻辑，画一点逻辑的吧，他这个逻辑也太强了，全部想明白了再画，多辛苦啊。当然人家肯定是现成有了代码才这么干的吧。</p>

<hr />

<p><strong>第六步、画出cannonball</strong></p>

<p>要画出这写炮弹，当然就是跑到Draw方法里面去了，有了之前的经验，我们应该很容易画。只是要注意的是画完背景先画炮弹，再画炮，这样感觉炮弹是从炮筒里出来的，不然很傻哦。</p>

<pre><code>foreach (GameObject ball in cannonBalls)
{
    if (ball.alive)
    {
        spriteBatch.Draw(
        ball.sprite,
        ball.position,
        Color.White);
    }
}
</code></pre>

<p>OK这就是绘制的代码，现在编译运行一下看看效果吧。（在我运行之后感到非常不满足，于是我把子弹数字稍微的改了一下，截图如下，嘿嘿～）</p>

<p><a href="/upload/2009-06-15_Chapter6Runtime.jpg"><img src="/upload/2009-06-15_Chapter6Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=153"><img src="/upload/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>翻译一、使用数组</strong></p>

<p>这是属于第二步的信息，教你使用数组，属于C#语法范围，其实没有什么特别的意义。权且翻译在这里。（以下翻译由本人翻译自<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/details/6_2">这里</a>，未经允许请勿转载，转载请注明译者及翻译出处）</p>

<blockquote><p>教程到目前为止，你已经能熟练的使用一些预定义的类，并且为了能封装一些有规律的使用的数据，能创建一些自己的类了。</p>

<p>但是还有另外一种数据组织形式你需要知道并且学会使用。你也许需要使用大量相似的对象或足够相似的对象，事实上，它们都是同一类型的类。它们可能是GameObject，Texture2D对象，也可能是其他对象。你需要一些这样的对象，并且希望有一个相似的操作方式来操作它们。</p>

<p>例如，如果你有一组要绘制到屏幕上的GameObject对象，并且他们中的每一个都有自己的位置和Texture2D，你为他们每一个写的代码都会是完全相同。虽然目前是这样，但是你还是会要写一些一样的代码来处理每个 GameObject，使你的代码变得混乱。有什么办法只需简单的让对象的集合运行一样的代码，并且可以让每一个都拥有同样方式的互动呢？</p>

<p>有 &#8212;- 解决方案就在于数组。一个数组是一个相似对象的线性集合。你可以拥有一个人和类型的数组；一个Vector数组，一个GameObject数组，一个字符串数组，或者其他任何可能并且合法的数组。</p>

<p><img src="/upload/BG_3.6.2.1pd.png" alt="" /></p>

<p>这张图显示了创建有3个GameObject元素的数组的代码顺序。你使用表明数组元素类型的类型名之后加上[]来声明一个数组。之后你使用new和[x]来初始化数组，x是你数组元素的数量。</p>

<p>如果数组中的数据类型为一个类，你必须循环遍历这个数组并且初始化每一个数组元素存储的对象。</p>

<p>一旦完成这些工作，你可以使用数组名加上[x]的方式访问数组中的每个元素，x代表了你要访问的元素，0开始代表第一个元素。因为这个指数的开始是0，调用cannonBalls[1].position会给你数组中第二个GameObject对象的position变量。</p>

<p>一个更加强大的方式来访问数组是循环，在上面的图中已经表现出来。一个for循环允许你针对所有数组中的元素运行相同的代码。你也可以使用一个foreach循环，它将被在后面的步骤中表现出来。两种方法都允许你让多个同类元素运行相同的代码。这也帮助你对已写代码的重用，而不用写更多的代码，即便数组的大小在今后得到扩展。</p></blockquote>

<p><strong>翻译二、转换一个旋转角度为速度向量。</strong></p>

<p>这是属于第四步的信息，属于数学知识，可以帮助不懂这个数学原理的朋友理解那部分代码，翻译在这里。（以下翻译由本人翻译自<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/details/6_4">这里</a>，未经允许请勿转载，转载请注明译者及翻译出处）</p>

<blockquote><p>学会这个教程的重点，你已经学会了采用弧度来传递旋转角度。然而，发射炮弹的动作需要我们使用Vector2来传递cannonball的动作。</p>

<p>Cannonball的动作应当和加农炮的角度有联系 &#8212;- 当你的加农炮转到垂直向上，你的炮弹应该垂直向上飞。同样的，当你的加农炮转到平行于地面的位置，炮弹应该平行于地面飞行。</p>

<p>来做出确定这个数据的唯一方法就是通过加农炮旋转角度的弧度。显然，你必须做一些转换工作，把旋转角度转换为给予炮弹的向量。</p>

<p><img src="/upload/BG_3.6.4.1pd.png" alt="" /></p>

<p>一个Vector2有两个组成部分：X坐标和Y坐标。在这个2D游戏的最终目标中，炮弹的X坐标在横轴上有怎样的动作，炮弹的Y坐标在纵轴上也有怎么样的动作。</p>

<p>在三角中，有个灯饰我们可以用来从一个角构造成一个vector。在如图所示的单位圆中，任何一个向量V可以被想象为拥有特定的从0开始的角θ。这个角度相当于我们想法中的旋转角度。为了得到向量V，也就是炮弹的速度向量，我们尝试着去发现，你可以使用下面的规则从θ中得到X和Y.</p>

<p>V = (cos(θ), sin(θ))</p>

<p>这些数学方程式,sine和cosine,代表任何一个有θ大小的角的X和Y的数据。为了构造一个2D向量,你只需要知道X和Y.所以sine和cosine方程就是我们想要的.向量的X坐标是cos(θ)，而向量的Y坐标是sin(θ)。</p>

<p>一个向量的方向使用Y和X坐标的关系来表现。（成为斜度）但是向量也具有幅度。从我们的炮弹上说，它决定了多快的速度来接近向量所指向的方向。在我们的代码中，我们使用一个常数去乘向量的方式来增长这个幅度。它同时使用相同的值去乘了X和Y坐标，确保斜度不变，但向量变得更长了 &#8212;- 这样，炮弹移动加快了。</p></blockquote>

<p>That&#8217;s all, finished~ Good luck ;)</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-15T19:23:44+08:00" pubdate data-updated="true">Jun 15<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch5-create-a-cannon/">
		
			XNA教程-2D游戏-05-添加一门加农炮</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 05 &#8211; 添加一门加农炮</strong></p>

<p>来到第五章，这一次要完成的是：建立一个类掌握你所有的游戏数据，并建立你第一个Game Object（游戏对象？还是不翻译比较好）&#8212;- 一个用户控制的加农炮，使用Xbox360手柄或者是PC键盘作为输入。完成了这一次的事情，整个程序就有交互了，就更加接近一个游戏了，其实游戏说穿了不就是一个有交互的幻灯片吗。</p>

<p>之前我们做过的东西都是一样的，所以这里就直接开始说真正的步骤了。直接看到此文的同学，相关文章里面应该可以找到之前的那些文章，从第一篇开始看吧，我想等我写完之后，会整理一个目录出来的。</p>

<p>在做所有的工作之前，我们要了解一个概念，就是屏幕的向量。一般做其他游戏的时候，包括direct3D也一样，屏幕的坐标是左上角的点为原点的。X轴正方向在朝右边，而Y轴正方向朝向下边。但是在XNA中也是这样。另外，角度却不是这个坐标系，而是右边是X轴正方向，上边才是Y轴正方向，原点因为是角度当然就无所谓了。这是说明，请大家不要被positon和rotation采取不一样的坐标系而搞混了。</p>

<p><strong>第一步 &#8212;- 建立我们的GameObject，在Game中添加这个GameObject</strong></p>

<p>GameObject是什么，究竟为什么要添加这么一个GameObject在说完具体的代码方法之后我会说，先讲直接上手的东西，因为可能有人对于概念不太感冒。我们要做的工作的前提是，你已经成功的画上了背景，那么接下去我们要加上的加农炮，让我们先添加一个GameObject吧</p>

<p><strong>1、添加GameObject</strong></p>

<p>首先就是要新建一个类，作为GameObject，具体的步骤如下。</p>

<p><strong>1.1、新建一个类。</strong>（中文版不好意思啦）</p>

<ul>
<li><p>右键单击你的Project选择Add中的New Item。（这里也可以直接选择Add，New Class）</p></li>
<li><p>选中class，然后输入类的名称，方便讲解所以和视频一样，取名为GameObject.cs，确认。</p></li>
</ul>


<p>（如下图，点击放大）</p>

<p><a href="/upload/2009-06-14_AddGameObject.jpg"><img src="/upload/2009-06-14_AddGameObject.jpg" alt="" /></a></p>

<p><strong>1.2、添加引用。</strong></p>

<ul>
<li>复制所有Game1.cs（如果你没改名字的话）的上面的using到新建的GameObject.cs文件的头部，OK</li>
</ul>


<p><strong>1.3、添加属性。</strong></p>

<p>虽然个人认为还是添加为属性比较好，不过这里全都是用了Public的成员变量，那么权且这么用着，不讨论工程范畴的事情了。代码如下。</p>

<pre><code>public Texture2D sprite;
public Vector2 position;
public float rotation;
public Vector2 center;
</code></pre>

<p>分别是一个Texture2D，我们全部要画的图像信息；Vector2，物体的具体位置；float，旋转的角度；Vector2，旋转中心的位置。有了这些信息，基本上一个2D游戏里能用到的物件的所有信息都在了，起码一个加农炮都在了。</p>

<p><strong>1.4、添加方法。</strong></p>

<p>这里我们只需要添加一个构造方法。代码如下：</p>

<pre><code>public GameObject(Texture2D loadedTexture)
{
    rotation = 0.0f;
    position = Vector2.Zero;
    sprite = loadedTexture;
    center = new Vector2(sprite.Width / 2, sprite.Height / 2);
}
</code></pre>

<p>传入一个Texture2D作为GameObject中的Texture2D sprite，并且初始化角度为0，位置为0，旋转中心为sprite的中心点。中心点可不是一定的，看下图，我们的中心点刚好是Sprite的二分之一高度二分之一宽度的地方，如果不是，那么要根据具体情况重新决定。</p>

<p><a href="/upload/2009-06-14_OriginalCannon.jpg"><img src="/upload/2009-06-14_OriginalCannon.jpg" alt="" /></a></p>

<p><strong>2、在Game1中载入加农炮。</strong></p>

<p>之后要在Game1中用到刚才的GameObject，并且把它初始化成加农炮。那么我们来吧，具体步骤如下。</p>

<p><strong>2.1、声明一个GameObject。</strong></p>

<p>在Game1.cs中，你声明了backgroundTexture的位置的附近加上新的声明代码，声明一个GameObject并且命名为cannon，这就是我们的加农炮了，具体代码如下。</p>

<pre><code>GameObject cannon;
</code></pre>

<p><strong>2.2、加载Content资源，并初始化位置。</strong></p>

<p>和背景的方法一样，让它读取我们的cannon.tga就好了，在Content Pipline中被自动命名为cannon（去掉后缀）的就是了。同样在你添加背景的LoadContent()方法，加入以下两行代码，载入资源，并把加农炮的初始位置放在距离屏幕右侧120像素，距离屏幕底端80像素的位置。</p>

<pre><code>cannon = new GameObject(Content.Load&lt;Texture2D&gt;(
    @"Spritescannon"));
cannon.position = new Vector2(
    120, graphics.GraphicsDevice.Viewport.Height - 80);
</code></pre>

<p>至此，第一步就做完了，我们已经实现并且实例化了一个GameObject，并且把实例化的GameObject整成了cannon加农炮放到了需要的位置上，接下去就可以加入相应对它的操作了。</p>

<hr />

<p><strong>第二步、添加玩家的控制，是加农炮可以旋转</strong></p>

<p>我们会使用Gamepad类和Keyboard类分别来接受Xbox360的手柄和PC键盘的控制。另外，我们用到一个MaxHelper类来实现简单的工作，而避免添加过多繁杂的代码。要做的依然很简单，所有的代码都在Update这个方法中完成，所以你只要找到Update方法，并且把代码加入到// TODO: Add your update logic here附近base.Update(gameTime);之前就好了。</p>

<p><strong>1、添加Xbox360手柄的控制。</strong></p>

<p>这个步骤相当的简单，我们可以看到在Update前部已经加上了一个类似的控制，就是为了使得游戏可以在Xbox360中退出的，可以关注一下它的实现，至于我们这里怎么做还要稍微讲一讲。</p>

<pre><code>GamePadState gamePadState = GamePad.GetState(PlayerIndex.One);
cannon.rotation += gamePadState.ThumbSticks.Left.X * 0.1f;
</code></pre>

<p>如果你无视360，那么请直接看2好了，不过这里要稍微对这个代码解释一下。</p>

<p>GetState(PlayerIndex.One)是获取的操作是第一个玩家。因为采用无线手柄，所以X360会对玩家的手柄进行排序，最多四个玩家，也就是最多接4个手柄，分别为PlayIndex这个枚举类型下的One Two Three Four。这里也就是说默认的操作全部来自于One，就是所谓的1P，第一个玩家。</p>

<p>ThumbStick.Left就是XBOX左侧的类比遥感，这个东西不是简单的上下左右就好了，它是矢量的，就是说你打左的程度也会成为控制的一个信息，而不是简单的boolean。那么在这里的代码是怎么回事呢？首先，你要知道，ThumbSticks.Left.X这是一个Vector2（也重载了其他情况比如Vector3），也就是一个向量，相当于把摇杆所在的范围看作一个坐标系。这样一来这行代码的意思就非常的明显了，往左的程度越多×0.1f，加到角度（旋转角度也是一个向量）上，那么越往左就是越往逆时针旋转。这样理解下来的话，这句话的意思也可以写成：</p>

<pre><code>cannon.rotation -= gamePadState.ThumbSticks.Right.X * 0.1f;
</code></pre>

<p>这样其实我们控制的效果和键盘是不一样的，也就是说扳动类比遥感的角度越大，旋转速度就会越大。</p>

<p><strong>2、添加PC键盘的控制。</strong></p>

<p>相对于XBOX，这里的代码量要稍微多一点，不过反而好理解一点。只要读取左右按键是否按下，按下就相应的产生操作就好了。因为update是每一帧都会来读取的内容，所以虽然一次只读键盘一次，但是其实一直按住的连续操作也是会被接受的，不理解的朋友可以留言，因为初学者可能不知道update和draw两个方法在游戏主循环里会不停的调用的。代码如下：</p>

<pre><code>#if !XBOX
KeyboardState keyboardState = Keyboard.GetState();
if(keyboardState.IsKeyDown(Keys.Left))
{
    cannon.rotation -= 0.1f;
}
if(keyboardState.IsKeyDown(Keys.Right))
{
    cannon.rotation += 0.1f;
}
#endif
</code></pre>

<p>注意一下#if和#endif之前的代码，!XBOX的意思就是如果不是XBOX360的话，就会在编译的时候编译这一段代码，否则就不编译了，因为360是没有键盘的哦。</p>

<p>代码没有什么特别值得解释的东西。如果按键被按下，是左边就减去向量角度，是右边就加上向量角度。</p>

<p><strong>3、限制加农炮旋转角度。</strong></p>

<p>已经对加农炮的旋转进行了操作，可是还存在什么问题么？是的，现在我们的加农炮是可以360度回旋的，转啊转啊大风车一样，可是我们只能让他转在朝着屏幕右上角的90度里面怎么办？很简单，利用XNA提供的一个MathHelper类。名字取得很好听，&#8221;数学助手&#8221;，如果数学不过关那么就用它吧。不过这里我们只是限定一个范围，那么其实用if也完全可以完成，MathHelper帮我们减少了代码量，功德无量啊。代码也很简单，一行：</p>

<pre><code>cannon.rotation = MathHelper.Clamp(
cannon.rotation, -MathHelper.PiOver2, 0);
</code></pre>

<p>加农炮的旋转角度来接收返回值。返回值一定不是最大值就是最小值了吧。</p>

<p>看看MathHelper.Clamp传入了什么？</p>

<ul>
<li><p><strong>第一个参数</strong>：需要被限定的变量，那么我们要限定的就是加农炮的旋转角度 &#8212;- cannon.rotation。</p></li>
<li><p><strong>第二个参数</strong>：最小值，我们旋转角度的最小值。显然，我们传入的最小的是-MathHelper.PiOver2，这有点像个宏，其实是MathHelper的另一个重要功能，帮我们记录一些常数。PiOver就是90度，Pi/2，这个学过向量应该知道，不知道的就可以补习数学去了。（下文会对这个东西详细的讲解）</p></li>
<li><p><strong>第三个参数</strong>：最大值，就是0，就是说它最大的旋转角度在0，也就是水平线往右，X正方向，这个角度就可以了。</p></li>
</ul>


<p>至此，我们第二步的工作就宣告完成了～ 接下去就是最令人兴奋的部分了，把我们已经加载的，并且可以操作的加农炮显示到屏幕上，把它画出来！其实我们它已经存在了，只是我们还看不见，所以，第三步就是让我们看见他！</p>

<hr />

<p><strong>第三步、绘制加农炮</strong></p>

<p>无聊了，看了这么久写了这么久为什么运行的时候都不变？当然，因为没有画出来啊，接下来就是要在Draw方法里画了，方法也异常简单。</p>

<p>找到上次画了背景的那个地方， 也就是Draw方法，在画背景的那一行的下面加入如下代码。</p>

<pre><code>spriteBatch.Draw(
    cannon.sprite,
    cannon.position,
    null,
    Color.White,
    cannon.rotation,
    cannon.center,
    1.0f,
    SpriteEffects.None,
    0);
</code></pre>

<p>没错，其实和画背景一样，我们只是调用了SpriteBatch类的Draw方法，只是这一次我们使用了另外一个重载而已。只是这一次使用了参数比较多的那一个，一个一个的讲解过来吧。</p>

<ul>
<li><p><strong>第一个参数</strong>：Texture2D，也就是要画的纹理，这样我们全部要画的就是这个cannon.sprite这个Texture2D了。没错～</p></li>
<li><p><strong>第二个参数</strong>：Vector2D，向量，也就是我们放的位置。我们传入了cannon.position，还记得吗？当时设定的是(120,高度-80)这个向量。</p></li>
<li><p><strong>第三个参数</strong>：Rectangle，矩形，是指在我们的Texture2D上面的裁剪，有经验的一定知道，很多的动画都是通过这样的方式实现的，每一帧画在一张texture上，一次载入之后，以后每一次都只要变化这个参数来读取不一样的位置就好了。这里我们传入了null，意思就是默认为不进行任何的裁剪。可以尝试把第三个参数改成new Rectangle(0, cannon.sprite.Height / 2, cannon.sprite.Width, cannon.sprite.Height)绘制一半。</p></li>
<li><p><strong>第四个参数</strong>：Color，传入颜色，和之前画背景一样，就是我们的色彩过滤。White代表不进行任何过滤。</p></li>
<li><p><strong>第五个参数</strong>：float，传入的是旋转的值，它指的是向量的角度，就是屏幕的坐标系上的角度。我们传入的是0，那么就是X正方向，也就是不进行任何旋转，加农炮朝着屏幕左边。</p></li>
<li><p><strong>第六个参数</strong>：Vector2，是图像的中心点的位置，这里要注意一下，这个中心会根据你绘制的图形重新定义，如果你画的东西不是整个的，那就会发生变化了。这里我们绘制了全部的内容，所以没问题。如果之前一样你只绘制一半，就惨了。也就是说在这个方法内部，是先切割，决定画的部分，再决定中心点，而不是先根据你传入的Texture2D决定中心点，再切割的。</p></li>
<li><p><strong>第七个参数</strong>：float，这个是指图形缩放的倍数，如果要实现平滑的缩放，那么简单的Update里调整这个数值就可以了。我们这里的1.0f就是1倍，1 / 1，不缩放的意思。</p></li>
<li><p><strong>第八个参数</strong>：SpriteEffects枚举，这个枚举也只有三个成员，FlipHorizontally，FlipVertically和None。也是2D游戏的除旋转、缩放意外非常重要的特效&#8212;-翻转。一个是纵向的一个是横向的翻转。应该很好理解。我们传入None，就是不翻转。</p></li>
<li><p><strong>第九个参数</strong>：Int32，也就是int了，这是指深度，0和1之间。2D游戏经常会有深度这个概念，Depth，往往，Sprite会自动对这些深度排序，这样可以实现一些角色挡住丛林，或者丛林挡住角色的变化。这是2D游戏很重要的一个参数。当然如果要让这个参数有效，你必须先设置SpriteSortMode，在这里就不多加讨论了，总之我们这里传入了0。</p></li>
</ul>


<p>这样我们就画好了加农炮。运行一下吧，你已经在游戏上面做了一个可以转动的加农炮了。然后修改一下之前的一些代码看看有什么不同的变化～比如旋转的角度限定注释掉，炮会很可爱的。</p>

<p><a href="/upload/2009-06-14_RunTime.jpg"><img src="/upload/2009-06-14_RunTime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=152"><img src="/upload/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>之前也说到了，一些问题会在最后讨论一下，其实这就是两段在官网上也特别罗列出来要讲的东西，于是放上这两段的翻译。</p>

<p><strong>一、为什么要创建自己的类？</strong></p>

<p>我们在代码过程中，创建了一个GameObject，并且实例化为Cannon，可是为什么要自己创建一个GameObject呢？不是简单的把四个变量放到Game1里面就可以了吗？来看看下面这段翻译。（下文由本人翻译自<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/details/5_1">这里</a>，转载请注明翻译作者Arthraim，并表明出处，尊重我的劳动成功）</p>

<blockquote><p><a href="/upload/BG_3.5.1.1pd_a.png"><img src="/upload/BG_3.5.1.1pd_a.png" alt="" /></a></p>

<p>目前为止，你已经使用过了一段时间XNA Framework中的一些实现定义好的类（代码层面的对象，包含了数据和针对数据的操作的方法）了。</p>

<p>你已经修改了一些包含在Game1这个类中的一些方法，添加了一些新的类的声明，诸如SpriteBatch和Texture2D，并且在类中使用了他们。</p>

<p>然而，创建GameObject类完全是一种新的操作：创建一个你自己的包含了数据和方法的类的过程叫做定义一个类。乍一看，创建一个新的类文件，并且定义一些能像在Game1里面定义了一样，能够被简单的使用的数据和变量，也许需要非常多的工作。</p>

<p>例如，在GameObject中，一个被叫做position的数据成员Vector2。你可以简单的在Game1中定义一个包含位置数据的Vector2，因为一个就可以记录想让你追踪位置的对象了。但是还有旋转，速率，和其他活动的变量。当你考虑可以添加更多对象到屏幕上，而需要的都是一样的数据的时候，加入Game1的变量的数目就会开始向着无法工作的庞大的数据增长。</p>

<p>另外，如果你需要对这些数据进行一些运算操作，你就必须对每个变量采取相同的计算操作，一个接着一个。最终你的代码量将会非常的庞大并且没有效率。</p>

<p>类的目标是重用。综合一类你可能要用到多次的数据和方法到一个单独的&#8221;代码对象&#8221;，这样一个小单元，比一些独立的数据对象更加容易操作。</p>

<p>就像你可以在图中看到的一样，使用一个类，显著的减少了你需要在Game1.cs里要添加的声明，并且保持数据有序。当你要开始使用数列（相似并且可以按序操作的数据集合）声明一些对象，即游戏中对象变得更多的时候，这个概念会显得更加重要，没有类，数据会变得难以追踪。</p></blockquote>

<p>其实这只是一个简单的面向对象的概念，不应该放到游戏编程这里来说，就像视频里其实没必要讲一些VS的用法，因为虽然讲了，但是根本对不会用VS的人没有帮助。一样的，对不懂OO的人来说，讲这么一段东西对于他们的思维来说也不能产生什么变化。所以说，无论是VS的用法，还是C#的语法，或是这里提到的OO思想，都是需要慢慢积累，或是在别的地方补课的，而不是通过这个简单的教程。</p>

<p><strong>二、Game Studio中的角</strong></p>

<p>（下文由本人翻译自<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/details/5_2">这里</a>，转载请注明翻译作者Arthraim，并表明出处，尊重我的劳动成功）</p>

<blockquote><p>开发游戏中经常会需要你传递一个表示一个角的数值。2D对象的旋转只是你使用角的开始，还会有很多角的使用，比如在3D对象中，不同对象间反射的角，还有更多其他的。</p>

<p>有很多不同的方式去传递角。一个标准的方法就是用角度。意思是，把一个圆圈分为360个部分，每一个被称为一度。90度是四分之一个圆，180度是半个圆，等等。</p>

<p>然而，在计算机图形和XNA Game Studio中，更多的采用弧度来传递一个角。弧度采用和角度不一样的方法去切割一个圆 &#8212;- 代替360度代表一个圆周的方法，是用2倍的π或2π代表一个圆周。这个值被存储在MathHelper类当中，只需简单的调用MathHelper.TwoPi。半圆则就是这个值的一半，或是简单的用π表示，也就是MathHelper.Pi。你可以继续细分来得到其他角度。90度则是MathHelper.PiOver2。</p>

<p><a href="/upload/BG_3.5.2.1pd_a.png"><img src="/upload/BG_3.5.2.1pd_a.png" alt="" /></a></p>

<p>当使用SpriteBatch.Draw画一个Sprite，或者当你创建一些用来旋转的矩阵的时候，你需要弧度来传入旋转的值。但是如果你觉得角度更加方便的话，你可以在游戏中继续使用它，只要你在调用一些XNA Framework中需要传入弧度的方法的时候把它们转换成弧度就可以了。你可以使用MathHelper.ToRadians来完成这个工作，只要传入你要转换的角度即可。</p></blockquote>

<p>这也是之前说到的会详细说的内容。最后我再补上一张图，方便大家学习吧。</p>

<p><a href="/upload/2009-06-14_CordinateSystem.jpg"><img src="/upload/2009-06-14_CordinateSystem.jpg" alt="" /></a></p>

<p>画是画的难看一点。</p>

<ul>
<li><p>我们在设置position的时候，使用的是最外面黄色箭头表示的这个坐标系的，就是X正方向朝左，Y正方向朝下。</p></li>
<li><p>在设置center的时候，这个向量也是使用一样的方向的，只是坐标原点换成了Sprite的左上角，就比如我图例那个粉红色的框框的左上角（好像有些圆了 ;)）。</p></li>
<li><p>而在设置初始旋转的时候，我们设置了0，那么就是像图例的弧度这张图一样，是摆正的。就是Y轴方向是和屏幕坐标系相反的。（但是弧度这个概念可是不受限于坐标系的，只是rotation这个参数默认的0度是在这样的一个坐标系里面的。）</p></li>
</ul>


<p>好了我觉得该说的都说过了，那么就是这样。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-15T03:56:33+08:00" pubdate data-updated="true">Jun 15<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>

<nav id="pagenavi">
    
        <a href="/blog/page/14/" class="prev">Prev</a>
    
    
        <a href="/blog/page/16/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2012

    Arthur Wang

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>