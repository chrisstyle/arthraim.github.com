
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Artoirus</title>
	<meta name="author" content="Arthur Wang">

	
	<meta name="description" content="在3D的地表上添加了可以控制的炮塔，接下去要让他向整个3D空间里自由的发射导弹。这次我们真正的要接触到Update这个方法了，另外知道在游戏循环中处理一些按键的逻辑。和2D一样，发射出去的导弹也是GameObject，那么一样的我们还是要用到它，并且要用到它的集合，来管理多枚屏幕中的导弹。 &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Artoirus" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>

<body>
	<header id="header" class="inner"><h1><a href="/">Artoirus</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:artori.us">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:artori.us">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch7-create-missiles/">
		
			XNA教程-3D游戏-07-添加导弹</a>
	</h2>
	<div class="entry-content">
		<p>在3D的地表上添加了可以控制的炮塔，接下去要让他向整个3D空间里自由的发射导弹。这次我们真正的要接触到Update这个方法了，另外知道在游戏循环中处理一些按键的逻辑。和2D一样，发射出去的导弹也是GameObject，那么一样的我们还是要用到它，并且要用到它的集合，来管理多枚屏幕中的导弹。</p>

<p>这一部分官方把视频分为了6段之多，不过其实内容基本上和2D差不多，那么还是一步一步看下去，其实分的越细致，越容易理解的。</p>

<p><strong>第一步、扩展GameObject</strong></p>

<p>正如前面说到的，这一次要用GameObject来描述导弹，那么它就应该具有所有导弹需要的属性，和2D类似，需要的是一个Vector3记录初速度， 和一个bool记录模型是否存活。</p>

<p>添加这样两行到GameObject类中～</p>

<pre><code>public Vector3 velocity = Vector3.Zero;
public bool alive = false;
</code></pre>

<ul>
<li><p>velocity：Vector3，记录速度（速率和方向），初始化为0；</p></li>
<li><p>alive：bool，记录是否存活，初始化为false。</p></li>
</ul>


<hr />

<p><strong>第二步、添加missiles数组</strong></p>

<p>拥有了为导弹扩展之后的GameObject类，现在就要添加一定数量的导弹了，所以我们用到了一个GameObject数组，来记录所有游戏中出现及没有出现的导弹。</p>

<p><strong>1、声明：</strong>还是要先添加声明，一个const int记录数组大小，即最多的同屏导弹数。在Game1类的头部添加代码：</p>

<pre><code>const int numMissiles = 20;
GameObject[] missiles;
</code></pre>

<p><strong>2、初始化：</strong>在LoadContent中用循环来初始化数组中所有的GameObject。找到LoadContent()：</p>

<pre><code>missiles = new GameObject[numMissiles];
for (int i = 0; i &lt; numMissiles; i++)
{
    missiles[i] = new GameObject();
    missiles[i].model = Content.Load&lt;Model&gt;(
    @"Modelsmissile");
    missiles[i].scale = 3.0f;
}
</code></pre>

<p>实例化missiles数组为20个GameObject。</p>

<p>循环使用for，遍历每一个，并实例化 ，载入模型为missile，缩放大小为3倍，因为模型比较小的缘故吧。</p>

<hr />

<p><strong>第三步、导弹发射输入</strong></p>

<p>这一步要编写控制导弹发射的逻辑，和2D一模一样，除了命名不一样。一样从声明和Update代码两部分看。</p>

<p><strong>1、声明：</strong></p>

<pre><code>GamePadState previousState;
#if !XBOX
KeyboardState previousKeyboardState;
#endif
</code></pre>

<h1>if和#endif在之前控制炮台转动的教程中已经出现过。</h1>

<p>这里为什么用到这样两个变量，在文章最后为加上翻译的资料。</p>

<p><strong>2、Update代码：</strong></p>

<pre><code>missileLauncherHead.rotation.Y = MathHelper.Clamp(
missileLauncherHead.rotation.Y,
-MathHelper.PiOver4,
MathHelper.PiOver4);
missileLauncherHead.rotation.X = MathHelper.Clamp(
    missileLauncherHead.rotation.X,
    0,
    MathHelper.PiOver4);
if (gamePadState.Buttons.A == ButtonState.Pressed &amp;&amp;
    previousState.Buttons.A == ButtonState.Released)
{
    FireMissile();
}
#if !XBOX
if(keyboardState.IsKeyDown(Keys.Space) &amp;&amp;
    previousKeyboardState.IsKeyUp(Keys.Space))
{
    FireMissile();
}
#endif
previousState = gamePadState;
#if !XBOX
previousKeyboardState = keyboardState;
#endif
</code></pre>

<p>这里的代码看上去挺多，但逻辑其实很清晰。都是在上一次按键放下的前提下，看下的话，就调用FireMissile方法。这样就不能按住案件连续发射了。</p>

<p>FireMissile方法正是下一步要完成的内容。</p>

<hr />

<p><strong>第四步、发射导弹</strong></p>

<p>在Update方法里的FireMissile就是更新导弹的一个重要步骤，我们应该在这里让导弹活过来，并且给予初速度。</p>

<p>这里不向2D获取速度、位置那么简单，因为要知道我们是三维的，所以我们用了一些新的方法来得到我们想要的，看下去吧。</p>

<p><strong>1、完成FireMissile方法。</strong></p>

<pre><code>void FireMissile()
{
    foreach (GameObject missile in missiles)
    {
        if (!missile.alive)
        {
            missile.velocity = GetMissileMuzzleVelocity();
            missile.position = GetMissileMuzzlePosition();
            missile.rotation = missileLauncherHead.rotation;
            missile.alive = true;
            break;
        }
    }
}
</code></pre>

<p>我就说微软工程师都是天才，先直接写了FireMissile方法，然后现在又无中生有了两个方法。不去管它，逻辑比较简单，foreach遍历所有的数组中的GameObject，如果不存活就让他活过来。</p>

<p>要活过来的话，先要给速度，再给初始位置，再给初始旋转为炮塔转到的角度。然后设置alive为真，break跳出。跳出保证每次只发射一颗子弹。</p>

<p><strong>2、声明两个新变量。</strong></p>

<p>这里我们需要声明两个新的变量，在Game1头部加上两行代码：</p>

<pre><code>const float launcherHeadMuzzleOffset = 20.0f;
const float missilePower = 20.0f;
</code></pre>

<p>两个浮点的常量。命名有些奇怪，但其实意思很简单</p>

<ul>
<li><p>launcherHeadMuzzleOffset，发射器头部炮口偏移量，翻译过来就是这个意思，就是指炮管的长度，也就是导弹刚刚射出的时候距离模型中心的长度。这个值得问做模型的美工啦～</p></li>
<li><p>missilePower，导弹的威力，就是指每一次更新导弹的位移，也就是速率。导弹的威力取决于速度？也许在这个游戏中是的吧。</p></li>
</ul>


<p>这是一个准备工作，为的是完成天才们预留的两个方法。</p>

<p><strong>3、GetMissileMuzzleVelocity方法。</strong></p>

<pre><code>Vector3 GetMissileMuzzleVelocity()
{
    Matrix rotationMatrix =
         Matrix.CreateFromYawPitchRoll(
             missileLauncherHead.rotation.Y,
             missileLauncherHead.rotation.X,
             0);
    return Vector3.Normalize(
        Vector3.Transform(Vector3.Forward,
        rotationMatrix)) * missilePower;
}
</code></pre>

<p>这里首先创建了一个rotationMatrix，用的就是CreateFromYawPitchRoll，之前也使用到过。从初始化的代码来看，得到的就是炮台的旋转情况，因为Z轴的旋转，也就是翻转（roll） 是不存在的，所以传给其0就可以了。</p>

<p>之后的步骤有些复杂，拆开来看。</p>

<ul>
<li><p>首先是调用了Vector3.Transform()这个方法，这个方法是把一个旋转矩阵转换成一个向量。</p>

<ul>
<li><p>第一个参数为一个Vector3，也就是参考的方向向量。</p></li>
<li><p>第二个参数是一个Matrix，也就是旋转矩阵。</p></li>
</ul>
</li>
</ul>


<p>方法会得到相对于第一个参数的向量的，当前Matrix的旋转情况。</p>

<ul>
<li><p>其次是调用了Vector3.Normalize这个方法，这个方法是把一个向量转换成一个单位向量。唯一的参数就是一个Vector3。相当于只保留了向量对方向的表达性，而去掉了速率的表达性。这样为最后一个工作作了铺垫。</p></li>
<li><p>最后把单位向量乘上missilePower，也就是位移量，这样给返回的Vector3加上了速率的信息。</p></li>
</ul>


<p>得到Velocity的过程就是这样，有了方向和速率，速度就这样完整了。</p>

<p><strong>4、GetMissileMuzzlePosition方法。</strong></p>

<p>得到了速度，这里要给他一个位置信息。因为是在FireMissile方法中被调用，那么其实就是起始位置，所以来看看代码。</p>

<pre><code>Vector3 GetMissileMuzzlePosition()
{
    return missileLauncherHead.position +
        (Vector3.Normalize(
            GetMissileMuzzleVelocity()) *
            launcherHeadMuzzleOffset);
}
</code></pre>

<p>很简单的直接返回。一样是一句复杂的语句，拆开来看看。</p>

<ul>
<li><p>首先调用了GetMissileMuzzleVelocity()方法，得到上一个方法完成的速度Vector3。</p></li>
<li><p>然后调用了Vector3.Normalize()方法，只取得它的方向信息，去除速率信息。</p></li>
<li><p>最后乘上launcherHeadMuzzleOffset，使得导弹出现的第一个位置是炮管的顶端，而不是模型的中心。</p></li>
</ul>


<p>意思很明了，前两个调用相当于是得到炮塔在按键的一刹那的方向。换句话说，用GetMissileMuzzleVelocity方法里的逻辑也不难得到。</p>

<hr />

<p><strong>第五步、更新导弹</strong></p>

<p>因为3D的缘故，第四步稍稍显得有些复杂了，有一些新的方法。</p>

<p>当然在完成了这些工作后，现在就显得简单的多了，这一步，只要让导弹在每次更新是移动一定的距离，并且在移动到一定距离后就消失。</p>

<p><strong>1、编写一个UpdateMissile方法。</strong></p>

<p>首先要写一个UpdateMissile的方法来管理所有的Missile的移动。</p>

<pre><code>void UpdateMissiles()
{
    foreach (GameObject missile in missiles)
    {
        if (missile.alive)
        {
            missile.position += missile.velocity;
            if (missile.position.Z &lt; -6000.0f)
            {
                missile.alive = false;
            }
        }
    }
}
</code></pre>

<ul>
<li><p>不需要返回值。</p></li>
<li><p>遍历所有的导弹，如果它存活着就更新他的位置。</p></li>
<li><p>原来的位置加上速度就是现在的位置。</p></li>
<li><p>如果导弹的Z坐标小于-6000，即，深入屏幕6000，那么就让他死掉，准备再一次的发射。</p></li>
</ul>


<p>以上就是所有的逻辑。</p>

<p><strong>2、调用UpdateMissile方法。</strong></p>

<p>写完方法当然要调用（这次到不是先调用再写了）。在Update方法中，previousState = gamePadState;这一行之前插入一行代码。</p>

<blockquote><p>UpdateMissiles();</p></blockquote>

<p>就是这样。</p>

<hr />

<p><strong>第六步、绘制导弹</strong></p>

<p>最后一步每次都是这样子，就是完成之前逻辑后，把它画出来，习惯了这系列的教程就非常明白了。</p>

<p>相对于前面调用DrawGameObject来说，这一次只是要用一个foreach循环调用很多遍而已。</p>

<pre><code>foreach (GameObject missile in missiles)
{
    if (missile.alive)
    {
        DrawGameObject(missile);
    }
}
</code></pre>

<p>最后，编译，运行～(点击放大，导弹太小，难以察觉，不如调整一下参数啊～)</p>

<p><a href="/images/uploads/zb/2009-07-08_runtime.jpg"><img src="/images/uploads/zb/2009-07-08_runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=162"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>之前说过，处理输入的那一步存在的一些疑问。（其实2D里也一样吧～）为什么要记录上一步的操作状态。究竟起到了什么作用，那么这一段解释非常非常的清楚。</p>

<p>（以下文字翻译自XNA Create Club网站，未经允许禁止转载。由于本人水平有限，所以有任何错误希望高手更正。）</p>

<p><strong>什么是上一步操作状态，为什么需要记录它？</strong></p>

<blockquote><p>要理解对应游戏的输入，很有必要退一步看看更加普通的输入。控制器的输入信号一般只是简单的电流信号，它被一种称为驱动软件的低级软件系统分析解释。信号以一定的频率传入分析它们的软件。</p>

<p>有些软件把输入的解析表现出来，反映出很多用户使用这个输入设备做出的动作，并且把这些动作存入缓冲记忆体中等待被读取或释放。这种类型的输入处理被称为&#8221;缓冲模式输入&#8221;(buffered-mode input)。</p>

<p>另一种输入处理不使用缓冲。取而代之的，是提供索取信号是的当前状态。没有提供参数来标识一定时间内所做出的特定动作。取而代之的，是程序员可以在任何时间自由的访问控制器的当前状态，包括所有的轴的位置以及按键的情况。程序员可以自由存储和操作相关的信息。这种输入处理被称为&#8221;立即模式输入&#8221;( immediate-mode input)。</p>

<p>XNA Framework使用立即模式输入，并且支持全部三种输入方式&#8212;-Xbox360控制器，键盘以及鼠标。这意味着，对于任意一种输入设备，你都可以在任何时间查询输入设备的当前状态信息。然而，你却不能查询任何过去的设备状态，除非你明确的把它存储在其他地方。</p>

<p>为什么要查询过去的输入状态呢？举个强烈依赖玩家快速按键的游戏作为例子。在这样的游戏中，长按按键不会有什么效果，只有重复的连打才能奏效。</p>

<p>由于立即模式输入处理的这一特性，每一次输入状态被查询，一个长按的按钮表现为&#8221;被按下&#8221;（Pressed）。不检查过去的状态是否是&#8221;被释放&#8221;（Released），就没有办法来区分按键是刚刚被按下还是长按了一段时间。</p>

<p>存储上一次状态缓解了这个问题。每一次循环到达更新（Update），正常的处理输入，但是在循环的末尾，存储当前状态为一个变量。这个变量就成为上一次状态。要检查按键是否是被一次按下还不是长按着，检查当前按键状态为&#8221;已按下&#8221;(Pressed)，并且上一次按键状态为&#8221;已释放&#8221;（Released）。</p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-08T23:38:32+08:00" pubdate data-updated="true">Jul 8<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch6-finish-missile-launcher/">
		
			XNA教程-3D游戏-06-完成炮台</a>
	</h2>
	<div class="entry-content">
		<p>之前完成了GameObject类的一些基础工作，也因此，我们可以使得terrain和missle launcher base利用GameObject绘制在了屏幕上。应该记得，我们添加发射塔的时候说明了，这只是一个基座（base），至于炮塔部分其实是没有被添加的，而这就是我们这次要完成的工作。不但要完成这个发射塔，还要使得它可以被用户控制，对用户输入产生反应，那么现在开始吧。</p>

<p><strong>第一步、绘制炮塔的GameObject</strong></p>

<p>这一步的当然是非常的简单，我们只是把没有画上去的那一半处理好就可以了，添加一个新的GameObject，步骤还是声明和初始化。</p>

<p><strong>1、声明。</strong>找到声明部分，在已经添加的两个GameObject下面添加一个新的GameObject的声明，代码如下：</p>

<pre><code>GameObject missileLauncherHead = new GameObject();
</code></pre>

<p>代码很简单。</p>

<p><strong>2、初始化。</strong>找到LoadContent方法，在初始化另外两个GameObject的代码下面添加以下代码：</p>

<pre><code>missileLauncherHead.model = Content.Load&lt;Model&gt;(
    @"Modelslauncher_head");
missileLauncherHead.scale = 0.2f;
missileLauncherHead.position = missileLauncherBase.position +
    new Vector3(0.0f, 20.0f, 0.0f);
</code></pre>

<p>讲解一下：</p>

<ol>
<li><p>首先是载入asset，没有什么问题。</p></li>
<li><p>定义比例为0.2f，即和base一样。</p></li>
<li><p>下面初始化position的位置，实在原有的Base位置上加了(0, 20, 0)这样一个向量，意味着炮塔比基座升高了20。</p></li>
</ol>


<p>这里不妨先完成第三步，看看效果。不过按照之前的习惯，都是完成了逻辑代码之后再绘制的。（微软的工程师都是天才，囧）</p>

<p><img src="/images/uploads/zb/2009-07-07_151248.jpg" alt="" /><img src="/images/uploads/zb/2009-07-07_151225.jpg" alt="" /></p>

<p>不难看出变化吧～</p>

<hr />

<p><strong>第二步、加入输入控制</strong></p>

<p>这一步我们要让这个炮台可以被我们控制，方法很简单，和2D的非常的类似，如果你有2D基础那么就非常容易理解这个部分的内容了，如果没有我下面可能还会讲一下，你也可以回顾一下<a href="http://arthraim.cn/post/2009/06/65.html">2D教程</a>中相似的内容，讲解对应XBOX360手柄GamePad类的一些坐标系的说明。</p>

<p><strong>1、添加XBOX360的控制代码。</strong></p>

<pre><code>GamePadState gamePadState = GamePad.GetState(PlayerIndex.One);
missileLauncherHead.rotation.Y -=
    gamePadState.ThumbSticks.Left.X * 0.1f;
missileLauncherHead.rotation.X +=
    gamePadState.ThumbSticks.Left.Y * 0.1f;
</code></pre>

<p>GamePadState类用来获取手柄的操作情况，GamePad.GetState方法来决定获取哪个手柄的操作。因为XBOX360可以连接多个最多4个手柄，所以PlayerIndex这个枚举中分别由One,Two,Three,Four四个值，对应1P 2P 3P 4P手柄。</p>

<p>gamePadState.ThumbSticks.Left对应XBOX360手柄的左边的类比摇杆（传统游戏机上的方向键，microsoft用摇杆替代了方向键，顺应欧美玩家的习惯）。另外相对还有一个Right，当然是在右边。X轴决定左右，Y轴决定上下。</p>

<p>那么手柄的左右，决定了围绕Y轴（纵向轴）的旋转；上下决定了围绕X轴（横向轴）的旋转。还有个Z轴的旋转我们没有用到，如果是飞行模拟游戏里，一般左右控制Z轴，而另外L,R键来控制X轴。</p>

<p><strong>2、添加键盘的控制代码。</strong></p>

<pre><code>#if !XBOX
KeyboardState keyboardState = Keyboard.GetState();
if(keyboardState.IsKeyDown(Keys.Left))
{
    missileLauncherHead.rotation.Y += 0.05f;
}
if(keyboardState.IsKeyDown(Keys.Right))
{
    missileLauncherHead.rotation.Y -= 0.05f;
}
if(keyboardState.IsKeyDown(Keys.Up))
{
    missileLauncherHead.rotation.X += 0.05f;
}
if(keyboardState.IsKeyDown(Keys.Down))
{
    missileLauncherHead.rotation.X -= 0.05f;
}
#endif
</code></pre>

<h1>if和#endif之间表示如果不在XBOX情况下。</h1>

<p>其他代码非常的相似，0.05f是个幻数，其实表示了增加量。 这个值是固定的，使得用键盘操作和手柄操作产生了一些差别。</p>

<p>上下左右分别控制两个轴的变化，比手柄更易理解。</p>

<p><strong>3、限定旋转角度。</strong></p>

<p>炮塔的旋转不能任意，不太符合逻辑，所以要把它限定一下，使用MathHelper类，一样在2D教程中详细的讲解了这个类，从3D开始看教程的可以看一下<a href="http://arthraim.cn/post/2009/06/65.html">这篇文章</a>的第二步第3小节和末尾对角度的讲解。</p>

<p>这里要写的代码如下：</p>

<pre><code>missileLauncherHead.rotation.Y = MathHelper.Clamp(
    missileLauncherHead.rotation.Y,
    -MathHelper.PiOver4,
    MathHelper.PiOver4);
missileLauncherHead.rotation.X = MathHelper.Clamp(
    missileLauncherHead.rotation.X,
    0,
    MathHelper.PiOver4);
</code></pre>

<ul>
<li><p>第一次调用限定了rotation的Y轴，也就是左右的范围在-45度到45度之间。</p></li>
<li><p>第二次调用限定了rotation的X轴，也就是上下的范围在0度到45度之间。</p></li>
</ul>


<p>如果你添加了Draw部分的代码，那么现在已经完成了，没有添加，那就是我们下面要做的工作。</p>

<hr />

<p><strong>第三步、绘制炮台</strong></p>

<p>正如之前所说，非常简单的第三步，就是在Draw方法中插入一行代码，和之前的terrain和missleLauncherBase类似的代码。如果你是从第一步跳跃过来的，那么也一样，马上会有效果。</p>

<p>在另外两个GameObject的操作的下面插入代码：</p>

<pre><code>DrawGameObject(missileLauncherHead);
</code></pre>

<p>OK，编译、运行～</p>

<p><a href="/images/uploads/zb/2009-07-07_Runtime.jpg"><img src="/images/uploads/zb/2009-07-07_Runtime.jpg" alt="" /></a></p>

<p>大功告成，炮台可以旋转，并且在一定的范围之内了，试着变化这个范围DIY一下。</p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=161"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>特别说明：</strong>这段翻译，讲解了3D物体在游戏空间中的旋转情况，也就是pitch, yaw, roll三种情况。一样的，在翻译这三个单词的时候带来了一些困扰，权衡后决定翻译成您现在看到的样子，尤其是pitch不太贴切。</p>

<p>（以下文字翻译自XNA Creator Club网站，未经允许禁止转载。由于本人水平有限，所以有任何错误希望高手更正。）</p>

<p><strong>3D空间中的旋转：欧拉旋转</strong></p>

<blockquote><p>任意世界变换矩阵的一个重要组成部分就是旋转。旋转对应了一个对象相对于特定的轴的角度方向。</p>

<p>最终，一个物体的旋转将使用一个级联了&#8221;转换&#8221;（translation）矩阵和&#8221;比例&#8221;（scale）矩阵而约束的世界变化矩阵来决定。</p>

<p>我们在这个教程中使用的方法包括了一系列被叫做欧拉旋转的中间旋转。想象欧拉旋转为一系列的3个不同弧度的角，从0到2π，分别在不同的三个轴上。这些轴（X轴,Y轴,Z轴）可以被想象为低头、偏转、翻转轴（pitch, yaw and roll axes）。</p>

<p><a href="/images/uploads/zb/BG_4.6.2.1pd.png"><img src="/images/uploads/zb/BG_4.6.2.1pd.png" alt="" /></a></p>

<p>低头（picth），根据X轴测量，可以被想象为飞机头的方向向上或向下。</p></blockquote>

<pre><code>    偏转（yaw），根据Y轴测量，使得飞机从一边摆向（swing）另一边。

    翻转（roll），根据Z轴测量，可以想象为飞机翻向（banking）左边或右边。

    （英文中中西表述方式不同，难以理解，图片非常说明问题）
</code></pre>

<blockquote><p>在XNA Framework中使用欧拉旋转来创建世界变换矩阵中的旋转部分，使用Matrix.CreateFromYawPitchRoll方法，传入适当的旋转角度。它确定了一个你可以用来级联&#8221;转换矩阵&#8221;和&#8221;比例矩阵&#8221;的&#8221;旋转矩阵&#8221;，来确定最终&#8221;世界变换矩阵&#8221;。</p></blockquote>

<p><strong>补充说明：</strong>中西方人在操作上存在一些不同的习惯，（当然这不全是因为中西差异决定的，个别人之间也存在习惯的问题。）旋转的控制上也许会不同，所以很多游戏都设置了&#8221;反转X轴&#8221;，&#8221;反转Y轴&#8221;这样的选项。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-08T00:20:07+08:00" pubdate data-updated="true">Jul 8<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch5-render-gameobject/">
		
			XNA教程-3D游戏-05-绘制GameObject</a>
	</h2>
	<div class="entry-content">
		<p>从2D的意识转换到3D游戏的意识之后（也许还有直接接触3D的），之后的工作就和2D一样简单了，想想教程的例子要有什么——加农炮、UFO、炮弹，就是全部了。我们要一个一个的添加到游戏中，但是和2D一样，我们一定会有大量重复的工作，所以我们需要把这些代码封装，所以我们将创建一个具有一般性的类GameObject，来代替所有的加农炮、UFO等等物件的凌乱的代码。</p>

<p><strong>第一步、创建GameObject类</strong></p>

<p>GameObject类究竟有什么好处，烦请大家看下<a href="http://arthraim.cn/view.asp?id=65">这里</a>的末尾《为什么要创建自己的类》这一部分，当然，有过任何OO语言基础的人也知道为什么要封装一个类。</p>

<p>写这个类和2D的如出一辙，一样的我们需要有他的模型Model（sprite）、位置Position、旋转rotation。再加上一个scale属性。至于scale是哪一种，我们这里只是用来缩放模型大小的最最简单的。</p>

<blockquote><p>右键单击工程 -> Add -> New Class -> 命名为GameObject.cs</p></blockquote>

<p>然后修改类为如下代码：</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using Microsoft.Xna.Framework.Net;
using Microsoft.Xna.Framework.Storage;
namespace YourNamespace // 注意修改
{
    class GameObject
    {
        public Model model = null;
        public Vector3 position = Vector3.Zero;
        public Vector3 rotation = Vector3.Zero;
        public float scale = 1.0f;
    }
}
</code></pre>

<p>这样一个通用的GameObject类就简简单单写完了。</p>

<ul>
<li><p>Model为null，防止没有被实例化的情况。</p></li>
<li><p>两个Vector3都为Zero，位置在原点，没有方向。</p></li>
<li><p>scale为1.0f，表示1.0倍的大小。</p></li>
</ul>


<hr />

<p><strong>第二步、应用GameObject到terrain</strong></p>

<p>既然有了GameObject类，我们就应该把它应用到所有的要加入我们的3D世界的模型中，那么terrain也不例外。所以这一步我们稍稍花点时间，把之前写的terrain的代码修改一下，应用GameObject类。之前有3处地方要写，那么现在就有3处地方要改，声明、初始化、绘制。因为绘制还要做其他的修改，所以我们这里先修改声明和初始化部分。</p>

<p>（注释为原先的代码，其他为新编写的代码）</p>

<p><strong>1、声明。</strong>Game1类刚刚开始的地方，声明很多变量的地方。</p>

<pre><code>//Model terrainModel;
//Vector3 terrainPosition = Vector3.Zero;
GameObject terrain = new GameObject();
</code></pre>

<p><strong>2、初始化 。</strong>找到LoadContent()中和terrain有关的部分。</p>

<pre><code>//terrainModel = Content.Load&lt;Model&gt;(@"Modelsterrain");
terrain.model = Content.Load&lt;Model&gt;(@"Modelsterrain");
</code></pre>

<p>这样，terrain就成为了第一个GameObject的应用。接下去。</p>

<hr />

<p><strong>第三步、创建新GameObject，MissleLauncherBase</strong></p>

<p>MissleLauncherBase就是指加农炮的基座，基座是不动的，放在一个固定的位置，我们还是要使用GameObject类来创建他，和terrain是一样的。</p>

<p><strong>1、声明</strong>。Game1类刚刚开始的地方，声明很多变量的地方。</p>

<pre><code>GameObject missleLauncherBase = new GameObject();
</code></pre>

<p><strong>2、初始化 。</strong>找到LoadContent()中和terrain有关的部分。</p>

<pre><code>missleLauncherBase.model = Content.Load&lt;Model&gt;(@"Modelslauncher_base");
missileLauncherBase.scale = 0.2f;
</code></pre>

<p>加上scale的属性，确定缩放。一样把绘制部分交给最后一步统一完成。</p>

<hr />

<p><strong>第四步、绘制GameObject</strong></p>

<p>之前我们绘制过terrain，但是我们使用的是terrainModel这个Model类，和terrainPosition这个Vector3类。现在我们已经将GameObject引入了我们的游戏中，所以我们要重新修改DrawModel方法，我们不需要一个模型一个模型的画，只需要把GameObject这样一个通用的对象，采用一种通用的方法画就可以了。</p>

<p>所以找到DrawModel方法，我们重新写一个DrawGameObject方法（DrawModel方法当然一定用不着了，删掉也行），入参为GameObject。很好，代码如下。</p>

<pre><code>void DrawGameObject(GameObject gameobject)
{
    foreach (ModelMesh mesh in gameobject.model.Meshes)
    {
         foreach (BasicEffect effect in mesh.Effects)
         {
             effect.EnableDefaultLighting();
             effect.PreferPerPixelLighting = true;
             effect.World =
                 Matrix.CreateFromYawPitchRoll(
                     gameobject.rotation.Y,
                     gameobject.rotation.X,
                     gameobject.rotation.Z) *
                 Matrix.CreateScale(gameobject.scale) *
                 Matrix.CreateTranslation(gameobject.position);
             effect.Projection = cameraProjectionMatrix;
             effect.View = cameraViewMatrix;
         }
         mesh.Draw();
    }
}
</code></pre>

<p>不难发现我们对effect.World的初始化发生了一些变化，原本我们只是使用了Matrix.CreateTranslation方法，而现在还添加了两个方法，并且取了三个方法的乘积。这其实就像我<a href="http://arthraim.cn/post/2009/07/74.html">上一章</a>提到过的所有的变化都可以转换为多个变换矩阵的乘积。于是在代码里我们把表示旋转、缩放、位移的三个矩阵相乘，来完成所有这样三个的变化（下面资料中将详细讲解，这三个矩阵被翻译成旋转、比例、转换，其实旋转、缩放、位移更加易于理解）。另外，下一章中，加入加农炮的发射塔，这些参数将变得可控（虽然当前的terrain和missleLauncherBase都是不变的），所以这里依然使用了这样的方式，为了这个方法的通用性。（之后关于此内容还将有官方说明内容）</p>

<p>完成对这个方法的修改，只需要修改Draw方法中的代码就可以了。</p>

<pre><code>DrawGameObject(terrain);
DrawGameObject(missileLauncherBase);
</code></pre>

<p>就这样取代之前的DrawModel的调用，加上两行，每一个GameObject只需要一行的调用。这样绘制工作就算完成了。</p>

<p>运行一下，看看实际效果吧！</p>

<p><a href="/images/uploads/zb/2009-07-05_Runtime.jpg"><img src="/images/uploads/zb/2009-07-05_Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=160"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>特别说明</strong>：这段翻译，其实讲的就是世界变换的3个矩阵的情况，因为rotation scale translation这三个词中文的叫法是什么我不太清楚，所以这里权且翻译成旋转、比例、转换这样子，尤其是转换这个词不太好，不过因为translation真正完成的工作其实就是平移矩阵，相当于坐标轴的转换，所以只取了转换两个字，希望不会对大家理解上产生困扰。</p>

<p>（以下文字翻译自这里，未经允许禁止转载。由于本人水平有限，所以有任何错误希望高手更正。）</p>

<p><strong>翻译：构造世界的变换</strong></p>

<blockquote><p>3D模型由3D建模软件创建。在这些软件包中，美工们创建了3D世界中的模型。这个世界有一个中心，叫做原点，并且模型根据它来创建。位置、旋转和比例都和相对原点相关联，并且当游戏载入一个模型，会保留他的位置、旋转和比例关系。这样，这个模型被称作在“对象空间”或“模型空间”中。</p>

<p>当一个游戏绘制一个模型时，它连接了模型空间中的原点和游戏世界中的原点。如果这个模型在3D建模软件中存储的中心位置正好是模型空间的原点，那在游戏中绘制的时候他就会出现在游戏世界的原点。</p>

<p>当在你的游戏中绘制一个3D模型，你需要把3个变换应用到你的3D模型上。三者中的第一个，“世界转换”，定义如何转换你的模型的初始位置、方向和比例（对象空间）到游戏世界中的某个位置、方向和比例。</p>

<p>一个标准的世界转换分别由三个矩阵组成（旋转、比例和转换），所有的都将被整合成一个世界变换矩阵。</p>

<p>  *</p>

<p>&#8211; “旋转”（rotatiton）变化模型角度的方向——你可以把它想象成在空间中根据一点朝不同的方向旋转模型。有很多计算和存储旋转数值的方法，一种最常用的就是欧拉角，围绕三个轴旋转一个对象，X轴、Y轴和Z轴。（下一节会解释和说明欧拉角）。创建一个旋转矩阵，你可以使用Matrix.CreateFromYawPitchRoll方法，传入围绕各个轴的旋转角度。要存储游戏对象的这些角度，Vector3类是一个很好的选择。</p>

<p>  *</p>

<p>&#8211; “比例”（scale）变化模型的尺寸，使它能更大或更小。因为它可以让模型沿着任意轴拉伸，它更多的被应用到统一的比例，使得整个模型缩小或放大。要创建一个比例矩阵，使用Matrix.CreateScale方法，传入你要缩小或放大模型的因数。你可以存储游戏对象的比例因数为一个简单的float类型。</p>

<p>  *</p>

<p>&#8211; “转换”（translatiton）沿着3D世界的3个轴移动整个模型。想象成到处平移模型：左右移动（X轴），上下移动（Y轴），前后移动（Z轴）。创建一个转换矩阵，使用Matrix.CreateTranslation方法，传入你要沿着各个轴移动的数据。存储转换的数值可以使用Vector3。</p>

<p>一旦你创建了这些矩阵，你必须把它们组合成为一个单独的世界变换矩阵。这个工作被称为级联（concatenation）。在XNA Game Studio中，级联一个矩阵和另一个矩阵，使用乘法符号（*）。你必须使用正确的顺序级联这些矩阵。</p>

<p><em>世界变换 = 旋转 × 比例 × 转换。</em></p></blockquote>

<pre><code>    _World Transformation = Rotation * Scale * Translation_
</code></pre>

<blockquote><p>级联的顺序十分重要。因为矩阵惩罚是没有交换律的，所以用错误的顺序相乘会产生预期之外的结果——比如意外的在旋转之前转换坐标系，相对世界原点旋转了坐标系转换后的模型，使模型到了比起简单的正常旋转后的世界空间中的位置非常非常遥远的其他位置，</p>

<p>修改几次每个独立的变换矩阵传入的数值，你可以是物体在世界中穿过（转换），在空间中旋转（旋转），平滑的缩小或放大，或者三个的组合效果。</p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-05T19:48:03+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch4-render-3d-titan/">
		
			XNA教程-3D游戏-04-绘制3D地表</a>
	</h2>
	<div class="entry-content">
		<p>安装好环境、建立了XNA工程、添加了要用到的模型以及贴图，那么接下来要做的就是实际的代码了，而一上来就和2D大为不同的是，我们要直接创建我们的&#8221;宇宙环境&#8221;。要知道，在2D游戏中，我们游戏的&#8221;世界&#8221;是整个一张图，就是背景，简单的2D游戏就是这样。而3D则不然，即便是这个环境，那么也是需要我们用模型自己创建的，而这将会是一个非常复杂的工作，究竟如何复杂，看到下面的所有内容你就明白了。</p>

<p>从2D到3D，应该说当前我们在做的是一个非常困难的转换时期，我们要完成第一个3D的绘制，那么就必须了解很多很多只有在3D游戏中才会出现的概念。但是，简单的说，在代码上我们要完成的工作还是类似的，比如2D中，我们先声明了sprite；然后loadContent，或者load确定它的位置等信息；最后我们draw把它绘制出来。那么一样的，3D也是声明、初始化、绘制三个工作。只是2D中无论是初始化还是绘制都是相对简单的，3D就要复杂的多的多，跟着步骤走吧。</p>

<hr />

<p><strong>第一步、创建模型，确定视角</strong></p>

<p>似乎看了标题就有些茫然，有很多的概念要讲，不过和2D教程一样，先直接说代码怎么写，回头再讲大道理。（本文后面将会有官方解释的翻译内容）</p>

<p><strong>1、声明场景模型</strong></p>

<p>代码找到Game1类中最前面，SpriteBatch spriteBatch;这一行的下方，在这里我们先插入这样两行代码。</p>

<pre><code>Model terrainModel;
Vector3 terrainPosition = Vector3.Zero;
</code></pre>

<p>这里用到了XNA Framework提供的Model类，以及Vector类。</p>

<p>显然，terrainModel这样的命名让人比较容易理解，就是场景模型，这是我们的场景或者说是地面模型，都一样，就是我们的大环境。</p>

<p>而terrainPostision就更加容易理解了，是terrain的位置，究竟整个地表是怎样的一个位置。这里我们用Vector3这个类来描述。Vector3是一个3维的向量，就像Vector2是X,Y两个轴的向量一样，Vector3实质上就是把Vector2扩展到X,Y,Z，3个轴的向量。初始化为Vector3.Zero，即在整个3维坐标系的原点上。</p>

<p>和2D游戏不同，我们2D游戏所有涉及到的坐标都是在屏幕范围内的。我们知道屏幕向右是X轴正方向，向下是Y轴正方向，所以所有的坐标都是在这样一个坐标系上想象的。而3D游戏则不同，我们必须把这些位置都想象在自己的脑海中，因为屏幕看见的什么只是你3D世界的一角，你必须在整个思维中存在你的自己的一个三维世界，它所在的一个三维坐标系和它的所有坐标。然后我们再讨论从什么视角（什么坐标）去看这个世界。</p>

<p><strong>2、声明镜头</strong></p>

<p>说明一下，这里的镜头英文应当是camera，翻译成相机这样子比较好。不过也许很多像我一样的游戏玩家会知道，一般我们评价一个游戏，会说镜头能控制不能控制等等，所以我想这个词会更加容易被接受。我的文章里的镜头，指的就是camera。可以想象你的眼睛就是你看这个现实世界的camera。</p>

<p>在刚才两行代码下面，继续写以下内容。</p>

<pre><code>Vector3 cameraPosition = new Vector3(0.0f, 60.0f, 160.0f);
Vector3 cameraLookAt= new Vector3(0.0f, 50.0f, 0.0f);
Matrix cameraProjectionMatrix;
Matrix cameraViewMatrix;
</code></pre>

<p>详细说一下我们做了什么。</p>

<ul>
<li><p>cameraPosition：这是镜头所在的位置，比如我们的眼睛在脸上这样的描述。这里是(0, 60, 160)这样一个位置。</p></li>
<li><p>cameraLookAt：镜头的焦点。可以想象一下terrain被放在Y轴也就是高度轴的0上，镜头被放在Z轴也就是深度轴的160的位置，高度是60的位置，而它看着Y轴上50的那点，连成的直线就是你的视线了。</p></li>
<li><p>cameraProjectionMatrix：镜头投影矩阵。</p></li>
<li><p>cameraViewMatrix：镜头视角矩阵。关于两个矩阵，先不详细讲了。图形学中涉及到了任意点的变换可以使用矩阵，矩阵变换是一个图形学非常重要的概念。稍微讲一下。</p></li>
</ul>


<p>矩阵变换一般情况下有平移、缩放、旋转。各种复杂的变化都可以由很多这样的操作完成。其他还有诸如投影、切割等等。所有的变化都可以最终表示成为一个矩阵，这就是变换矩阵。不详细讲，举3个例子。</p>

<p><strong>例一</strong>：平移 W(wx,wy,wz)</p>

<p><img src="/images/uploads/zb/2009-07-03_Matrix1.jpg" alt="" /></p>

<p><strong>例二</strong>：缩放 T(tx,ty,tz)</p>

<p><img src="/images/uploads/zb/2009-07-03_Matrix2.jpg" alt="" /></p>

<p><strong>例三</strong>：绕X轴旋转alpha度</p>

<p><img src="/images/uploads/zb/2009-07-03_Matrix3.jpg" alt="" /></p>

<p>当然在XNA framework里封装的Matrix类不是一个简单的矩阵的实现了，还加上了很多智能的功能，当然也包括变换，至于如何使用这样一个Matrix，以及我们声明的Matrix是做什么样的变换的，看下去。</p>

<p><strong>3、初始化变换矩阵</strong></p>

<p>我们要初始化声明的资源，那么就要找到LoadContent()方法，在其中TODO的位置加上这样两句。</p>

<pre><code>cameraViewMatrix = Matrix.CreateLookAt(
    cameraPosition,
    cameraLookAt,
    Vector3.Up);
cameraProjectionMatrix = Matrix.CreatePerspectiveFieldOfView(
    MathHelper.ToRadians(45.0f),
    graphics.GraphicsDevice.Viewport.AspectRatio,
    1.0f,
    10000.0f);
</code></pre>

<p>这里做的工作是实例化两个Matrix，但是这里用到了Matrix类中的CreateLookAt和CreatePerspectiveFieldOfView方法。说下参数的意思。</p>

<ul>
<li><p>CreateLookAt：</p>

<ul>
<li><p>cameraPosition：Vector3，镜头所在位置</p></li>
<li><p>cameraLookAt：Vector3，镜头焦点坐标</p></li>
<li><p>Vector3.Up：Vector3，按照MSDN所说传入&#8221;上&#8221;就好，当然你可以试一下其他方向……</p></li>
</ul>
</li>
<li><p>CreatePerspectiveFieldView：</p>

<ul>
<li><p>MathHelper.ToRadians(45.0f)：float，视角大小</p></li>
<li><p>graphics.GraphicsDevice.Viewport.AspectRatio：float，窗口的比率，&#8221;宽&#8221;比上&#8221;长&#8221;的比率</p></li>
<li><p>1.0f：float，镜头最小深度（近处）</p></li>
<li><p>10000.0f：float，镜头最大深度（远处）（恐怕真三国无双和GTA这样的游戏里面这个参数的体会会比较深刻）</p></li>
</ul>
</li>
</ul>


<p>初始化完毕，就可以接下去继续了。</p>

<hr />

<p><strong>第二步、编写模型绘制方法</strong></p>

<p>因为游戏中将会出现很多很多的模型，虽然每一个模型都有其特殊的地方，但是每一个模型都将拥有一个默认的绘制方式。而，即便采用默认的方式，绘制模型也将会涉及到很多操作，所以将本来可以在draw方法中完成的内容单独的写一个方法来完成。方法传入的参数为模型和其所在的位置，这样我们的方法就可以把它用一样的操作绘制出来。</p>

<p>这里涉及到一个ModelMesh的类，每一个Model都一个很多的ModelMesh的集合，因此我们需要单独绘制每一个mesh。至于ModelMesh和Model的概念，在后面会加上说明。（本文后面将会有官方解释的翻译内容）</p>

<p>具体方法是，在Game1类中重新写一个方法，当然是任意位置的，代码具体如下。</p>

<pre><code>void DrawModel(Model model, Vector3 modelPosition)
{
    foreach (ModelMesh mesh in model.Meshes)
    {
        foreach (BasicEffect effect in mesh.Effects)
        {
            effect.EnableDefaultLighting();
            effect.PreferPerPixelLighting = true;
            effect.World = Matrix.CreateTranslation(modelPosition);
            effect.Projection = cameraProjectionMatrix;
            effect.View = cameraViewMatrix;
        }
        mesh.Draw();
    }
}
</code></pre>

<p>如参正如之前所说，一个是Model类，一个是Vector3类，分别表示要绘制的模型和其所在的位置。</p>

<ul>
<li><p>第一个foreach循环是遍历Model中所有的ModelMesh，单独处理每一个。</p></li>
<li><p>第二个foreach循环是遍历ModelMesh中的Effects，单独处理每一个效果的处理。具体看看做了一些什么</p>

<ul>
<li><p>EnableDefaultLighting()：设定光源为默认光源。</p></li>
<li><p>effect.PreferPerPixelLighting = true;：在支持Pixel Shader Model 2.0的情况下，开启每个像素按光源渲染的效果。</p></li>
<li><p>effect.World = Matrix.CreateTranslation(modelPosition);：创建传入模型的矩阵变换</p></li>
<li><p>effect.Projection = cameraProjectionMatrix;：设定投影变换矩阵。</p></li>
<li><p>effect.View = cameraViewMatrix;：设定视角变换矩阵。</p></li>
</ul>
</li>
</ul>


<p>这样，我们就完成了绘制方法的编写。但是不要忘了，我们还没有加载需要绘制的模型，也没有在draw方法中调用这个方法，所以看接下去的两步，完成这两个工作。</p>

<hr />

<p><strong>第三步、加载模型</strong></p>

<p>载入模型才能画，载入模型的方法和2D的一模一样，只是一个操作的是Sprite，一个操作的是Model，但是我们知道LoadContent方法是支持范型的，那么显然我们的工作就变得非常的简单了。</p>

<p>找到LoadContent方法，在之前添加的代码下面加上如下代码。</p>

<pre><code>terrainModel = Content.Load&lt;Model&gt;(@"Modelsterrain");
</code></pre>

<p>这样，这一步就简简单单的完成了。</p>

<hr />

<p><strong>第四步、绘制模型</strong></p>

<p>之前第二步完成的工作就大大简化了这一步我们的代码了。而这一步我们就只要调用之前我们写的drawModel方法，并且传入我们的模型和位置就可以了。</p>

<p>在Draw方法的TODO处，加入以下代码：</p>

<pre><code>DrawModel(terrainModel, terrainPosition);
</code></pre>

<p>还等什么呢？现在就是编译运行的时候了！效果图。</p>

<p><a href="/images/uploads/zb/2009-07-03_Runtime.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime.jpg" alt="" /></a></p>

<p>下面加了4张修改了参数之后的图，方便理解一些参数。[点击放大]</p>

<p><a href="/images/uploads/zb/2009-07-03_Runtime_Down.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_Down.jpg" alt="" /></a> <a href="/images/uploads/zb/2009-07-03_Runtime_100CameraHeight.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_100CameraHeight.jpg" alt="" /></a> <a href="/images/uploads/zb/2009-07-03_Runtime_95Radians.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_95Radians.jpg" alt="" /></a> <a href="/images/uploads/zb/2009-07-03_Runtime_5000Depth.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_5000Depth.jpg" alt="" /></a></p>

<ul>
<li><p>cameraViewMatrix实例化，CreateLookAt时，修改第三个参数为Vector3.Down</p></li>
<li><p>cameraPosition声明并实例化时，修改为Vector3(0.0f, 100.0f, 160.0f)</p></li>
<li><p>cameraProjectionMatrix实例化，CreatePerspectiveFieldOfView时，修改第一个参数为90.0f</p></li>
<li><p>cameraProjectionMatrix实例化，CreatePerspectiveFieldOfView时，修改第四个参数为5000.0f</p></li>
</ul>


<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=159"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>那么下面就贴翻译的内容，也算是比较重要的东西了，2D和3D游戏的概念上的区别。</p>

<p>（以下翻译为本人原传，未经允许严禁转载。另外，因本人能力有限难免出错，请高手指正。原址点击<a href="http://creators.xna.com/en-US/education/gettingstarted/bg3d/details/4_1">这里</a>。）</p>

<p><strong>1、3D世界：2D游戏和3D游戏之间的区别</strong></p>

<blockquote><p>如果你学习过第一个教程（创建2D游戏），那么你已经变得习惯用2D空间来思维了。位置、方向和动作可以全都用Vector2和一个单独的旋转角度来表示。</p>

<p>这个教程介绍了在三维的概念，和其一系列的新的对象。从根本上，3D世界区别于2D世界的就是新增的第三个坐标轴&#8212;-Z轴，或者说是深度。在XNA Game Studio中，2D世界实质上是一个特殊的，受限制的3D世界的版本&#8212;-你将会在本教程读到的计算也同样在2D中可以读到。</p>

<p>在XNA Game Studio这哦你，3D的变化意味着，取代在平面世界中画静态的Texture2D对象的是绘制用Model类表示的3D模型。Model类是被叫做网络（mesh）的许多有联系的3D点的集合，在整个世界中，最终渲染在屏幕上的对象，取决于对象的位置和方向，和镜头的位置和方向。</p>

<p><a href="/images/uploads/zb/BG_4.4.1.1pd.png"><img src="/images/uploads/zb/BG_4.4.1.1pd.png" alt="" /></a>这过程也许初看十分复杂，但其实在3D世界编程，只依靠一些非常基本的元素。想象一个点在3D空间中，一个点有一个X坐标,一个Y坐标,和一个Z坐标。非常类似2D空间中的一个点，3D空间中的一个点也可以使用一个向量来移动，但是在3D空间中，我们使用包含Z坐标的Vector3类。</p>

<p>然而，使用一个叫做矩阵的数学结构体，可以使3D点做更多的事情。这些结构体，在XNA Framework中表示为Matrix类，它描述了一系列可以应用于点的变换、点的集合、或一个响亮。使用矩阵，3D对象可以移动、旋转、切割、以及（通过使用被叫做视点矩阵和投影矩阵的特殊的矩阵）绘制成一个可以显示在屏幕上的2D图像。</p>

<p>想象有一系列我们想画在屏幕上的3D世界中的点。它们拥有相对于被叫做原点的中心点的位置和方向信息。如果没有任何的变换，这些点只是存在于他们自己的空间，被叫做&#8221;对象空间&#8221;。</p>

<p>当你加载一系列的点，并且把它们添加到你的3D世界中，你可能会想给他们一个在3D世界中的位置，用来旋转或切割他们。这些行动的产物被叫做世界变换矩阵。应用了这样的矩阵的点，就被想象成在&#8221;世界空间&#8221;中（而不是对象空间中）了。</p>

<p>来渲染在用户屏幕上的点，需要一些附加的信息。没有要绘制的2D场景的角度和位置，是不可能把整个3D常见转换到2D图像的。使用一个视点是必要的，也被称作镜头，只需绘制它所看到的3D场景。在准备这次绘制时，镜头信息会被计算到一个视角矩阵中，把3D点的方向和位置都和镜头联系起来。之后，这些3D点就被想象成在&#8221;视觉空间&#8221;中了。</p>

<p>用2D绘制一个3D场景最后还需要一些其他信息。像视点的视角和领域的信息，控制着3D点如何绘制在2D计算机屏幕上。这些信息存储在一个投影矩阵中，应用之后，把3D坐标的系统中的点转换到2D坐标系统中，2D坐标系统被成为&#8221;屏幕空间&#8221;，这样点被绘制成像素。</p>

<p><a href="/images/uploads/zb/BG_4.4.1.2pd.png"><img src="/images/uploads/zb/BG_4.4.1.2pd.png" alt="" /></a></p>

<p>如果要套用这个概念到3D点的集合所组成的网络（mesh）上（可以是3D表示的任何东西，一个飞船、一个人、或一只恐龙），你只需用到一些在XNA Framework中的基本的对象来制作你的游戏&#8212;-Mesh类，Matrix类和Vector类。</p></blockquote>

<p><strong> 2、创建一个模型绘制方法</strong></p>

<blockquote><p>绘制一个3D模型到屏幕上是一个复杂的工作。它包括了庞大数据量的多边形的绘制，而它们经常被构造成许多不同的方式。有些可能是基于艺术效果的，而有些也许是倾向于程序化的。绘制同时也是必要的工作。每个游戏中可见的3D对象都是需要经过一个绘制过程的。</p>

<p>毫无悬念的，不是只有一种组织一个模型绘制方法的方式。参数、界限以及绘制算法对每个游戏来说都是不同的，取决于游戏的需求和涉及的技术。在这样的情况下，XNA Framewrok没有尝试去提供一个单独的模型绘制方法。取而代之的是提供一些元素，而把组织它们的工作留给了程序员来做。</p>

<p>一个Model类是XNA Framework中表示3D模型的一个基本对象，但是它比最初的模型要复杂许多。一个模型由一个或多个ModelMesh对象以一个集合的形式组成。每个ModelMesh对象是一系列组成网络（mesh）的顶点的集合，它们可以在同一个模型中被单独的移动。</p>

<p>一个坦克的模型是一个很好的例子。坦克的身体也许是一个ModelMesh，坦克的炮台也许是另外一个。虽然你绘制的是整个坦克，但是你可能需要分开移动坦克的不同部分。你可以使用ModelMesh对象的集合来移动不同的部分。</p>

<p>ModelMesh包含了一个绘制方法。每绘制一个ModelMesh到屏幕上需要调用这个方法一次。然而如果你没有实现设定变换和MedelMesh上的光的属性，那么你什么也看不到。</p>

<p>变换（决定了ModelMesh在世界中的定向，并且最终，物体是否出现或是出现在屏幕的哪里）和光（）没有被应用到ModelMesh层面。相对的，每个ModelMesh有一些Effect和它联系在一起。一个Effect对象可以想成提供给可视设备的说明，关于如何绘制一个ModelMesh。</p>

<p>在很多游戏中，Effect对象是由很多复杂的顶点和像素遮罩（shader）组成的。在XNA Game Studio中也可以实现，并且对于高级图形效果来说十分重要。但是在简单的渲染中，XNA Framework Content Pipline（内容管道）提供了一个简单的机制来完成基本的光和绘制效果 &#8212;- BasicEffect类。</p>

<p>每个通过content pipline加载的ModelMesh接受了一个或多个BasicEffect对象，它们可以在不处理像素或顶点遮罩（shader）的情况下简单的处理变换和光源效果。所有这些BasicEffect类需要一系列表示世界（World）矩阵，视点（View）矩阵和投影（Projection）矩阵的Matrix类，和一些光照的参数。可以调用BasicEffect.EnableDefaultLighting()方法获得默认的参数。</p>

<p>在BasicEffect的参数被设置后，剩下的就只有调用ModelMesh.Draw方法，使用之前为BasicEffect设置的参数，来绘制ModelMesh到屏幕上了。</p>

<p><a href="/images/uploads/zb/BG_4.4.2.1pd.png"><img src="/images/uploads/zb/BG_4.4.2.1pd.png" alt="" /></a></p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-04T03:50:05+08:00" pubdate data-updated="true">Jul 4<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch3-add-assets/">
		
			XNA教程-3D游戏-03-添加Asset</a>
	</h2>
	<div class="entry-content">
		<p>到了这里其实还是和2D的教程是重叠的，这里我们要做的是添加asset们。所以这里你要问自己三个问题：</p>

<ol>
<li><p>你已经建立了工程（project）了吗？&#8212;- <a href="http://arthraim.cn/post/2009/06/72.html">点我补课</a></p></li>
<li><p>你已经下载了上一部分要求下载的资源了吗？&#8212;- <a href="http://creators.xna.com/downloads/?id=157">点我下载</a></p></li>
<li><p>你知道什么是asset吗？你看过之前2D教程的添加asset内容吗？&#8212;- <a href="http://arthraim.cn/post/2009/06/63.html">点我补课</a>（重点浏览链接指向的文章的后半部分，讲解什么是asset）</p></li>
</ol>


<p>三个问题过关的，再来看我的这里的屁话。放假回家，所以把编译一个XNA游戏都要3分钟的windows xp给格掉了（关注我的twitter的一定知道了），所以把windows 7的引导也格掉了。因为找不到之前安装windows 7的那张光盘，所以一下子没有修复引导，所以这一次的教程就先用XP完成了。装了3、4的系统，终于把一个一个的东西下载下来给装上了，现在可以继续了。</p>

<p>OK言归正传，看看这一次要做的是如何简单。和2D类似的右键添加等等工作，就能完成了。</p>

<p><strong>第一步、添加models到工程的content中</strong></p>

<p>Content中的asset可以在content pipeline中被我们调用。这是一个非常方便的设计，当然这也使得我们这一步的工作显得非常重要，你可以从磁盘去读取一些你需要的资源，但是让他在content管道中，会大大方便你的管理。</p>

<p>2D教程中，我们加入一些.tga资源到Content/Sprites中，我们右键新建文件夹，然后添加存在的资源等等这样完成了这部工作，那么这一次和视频一样，我们偷懒一下。直接把解压缩出来的models文件夹拖到VS2008的树状Solution Explorer的Content目录上，来完成这一步工作。</p>

<p>添加进来之后，我们看到了一些.fbx文件和.tga文件，fbx就是我们的模型，而tga是这些模型对应的贴图，不会被我们实际的工作主动调用到，他们只要在他们应该在的磁盘位置上就可以了，在我们调用模型的时候，相关联的贴图会自动被寻找，所以把他们排除我们的工程吧。右键选择所有的.tga文件，选择&#8221;Exclude From Project&#8221;将其排除工程。</p>

<p><a href="/images/uploads/zb/2009-07-01_ExcludeTgas.JPG"><img src="/images/uploads/zb/2009-07-01_ExcludeTgas.JPG" alt="" /></a></p>

<p><strong>第二步、添加audio到工程的content中</strong></p>

<p>这还分成两步看起来有点傻，一样的，把解压缩出来的audio文件夹也一并拖到Solution Explorer的Content目录上。展开Audio文件夹，右键点击Waves目录，选择&#8221;Exlude From Project&#8221;，把这些.wav文件全部排除在工程之内。因为对于声音的asset处理会有很大的不同，所以这里我们暂时先这样处理就好。</p>

<p>准备就绪之后，就可以开始代码阶段的工作了。</p>

<p>【官方工程下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=158"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-02T00:17:14+08:00" pubdate data-updated="true">Jul 2<span>nd</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch2-create-solution/">
		
			XNA教程-3D游戏-02-创建游戏工程</a>
	</h2>
	<div class="entry-content">
		<p>进行了之前的工作，搭建了环境之后，现在就要进入实际开发过程了。我想过程和2D也许存在着一些区别，但是还是相对比较依赖2D教程的，尤其像这一章和3D的确是别无二致，不过我这里还是按照步骤说一下。（参考：<a href="http://arthraim.cn/post/2009/06/62.html">《XNA教程-2D游戏-Chapter2-创建游戏工程》</a>）</p>

<p>使用GS3.1+VS2008是基于.NET Framework 3.5的，否则一些新特性将不会被用到，如果你的开发使用其他环境，那么也许会不一样。</p>

<p>具体涉及到一些可能和2D教程重复的东西，看过2D的直接跳过就好。</p>

<p><strong>第一步、Visual Studio简单介绍</strong></p>

<p>安装高于Visual Studio 2005 Express的版本，并且装好XNA Game Studio（2.0以上）。那么如果安装成功的话，在VS的新建对话框中应该可以看到这么几项（GS3.1+VS2008，不保证其他版本有一样的工程）</p>

<p><a href="/images/uploads/zb/2009-06-27_NewProject.jpg"><img src="/images/uploads/zb/2009-06-27_NewProject.jpg" alt="" /></a></p>

<blockquote><ul>
<li><p>Windows Game (3.1) &#8212;- XNA Game For Windows游戏的开发，很多游戏打着这个标志</p></li>
<li><p>Windows Game Library (3.1) &#8212;- Windows游戏类库</p></li>
<li><p>Xbox 360 Game (3.1) &#8212;- Xbox360游戏</p></li>
<li><p>Xbox 360 Game Library (3.1) &#8212;- Xbox360游戏类库</p></li>
<li><p>Zune Game (3.1) &#8212;- Zune游戏</p></li>
<li><p>Zune Game Library (3.1) &#8212;- Zune游戏类库</p></li>
<li><p>Content Pipeline Extension Library (3.1) &#8212;- Content管道扩展库</p></li>
<li><p>Platformer Starter Kit (3.1) &#8212;- 一个游戏示例（提供windows x360 zune三种版本都有）</p></li>
</ul>
</blockquote>

<p><strong>第二步、新建工程，获取资源</strong></p>

<p>根据刚才介绍的新建，建立相应的工程。</p>

<p>比如我新建一个Windows Game (3.1)工程，并且取名为TChapter2，那么我们可以得到一些IDE为我们创建的文件，具体情况如下。</p>

<blockquote><ul>
<li><p>Content &#8212;- 就是一切我们需要的游戏资源，在XNA中存在Content Pipeline这个概念，而这里的所有资源可以之后在Content管道中直接调用加载。</p></li>
<li><p>Game1.cs &#8212;- 游戏逻辑代码。</p></li>
<li><p>Game.ico &#8212;- 不用多说，一个Xbox360的手柄样式的ico图标。</p></li>
<li><p>GameThumbnail.png &#8212;- 正如他的名字，是一个缩略图，当然要你自己画的啦。</p></li>
<li><p>Program.cs &#8212;- 就是程序的入口Main方法了。</p></li>
</ul>
</blockquote>

<p><strong>第三步、下载资源</strong></p>

<p>接下去本章很重要的一部就是下载必须的游戏素材。这里提供官方链接，下载解压缩后就可以看到我们本教程的例子要用到的全部素材了。</p>

<p><a href="/images/uploads/zb/2009-06-27_files1.JPG"><img src="/images/uploads/zb/2009-06-27_files1.JPG" alt="" /></a> &#8230;/Audio/Waves/</p>

<p><a href="/images/uploads/zb/2009-06-27_files2.JPG"><img src="/images/uploads/zb/2009-06-27_files2.JPG" alt="" /></a> &#8230;/Models/</p>

<p>【点击下载官方素材】</p>

<p><a href="http://creators.xna.com/downloads/?id=157"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-27T10:08:42+08:00" pubdate data-updated="true">Jun 27<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch1-introduction/">
		
			XNA教程-3D游戏-01-3D游戏教程简介</a>
	</h2>
	<div class="entry-content">
		<p>在之前，我把所有的2D视频教程都用文字重新写了一遍，也完成了2D教程中完成的那个例子，应该说，如果是XNA变成从无到有的话，那收获已经颇为丰富了。并且，教程中所有的More Details（原视频教程的页面）我也都进行了翻译，一部分还加上了一些自己的说明。应该说，无论是机械的完成代码学会技能，还是了解一些XNA提供的实质性内容，都起到了很大的作用。</p>

<p>之后正好面临我的期末考试，一个学期也就这么几天读书的，总要成全我吧。所以加上复习和考试，暂停了那么几天博客的更新，也算是之前一星期之后的小小的休息吧。现在回家放暑假，休息了几天之后，我决定继续开始3D的教程了，利用之前在2D学到的东西，我们应该可以轻松的进入3D的学习了。</p>

<p>在3D的教程中，我们将完成一个2D教程中的demo中的3D版本。我们要完成一些类似的东西，也会接触一些新的东西。</p>

<ol>
<li><p>建立自己的3D环境 &#8212;- 毕竟是3D游戏了，所以不单单是像2D一样画一个背景就好了，我们需要建造自己的3D外太空环境。</p></li>
<li><p>添加加农炮 &#8212;- 同样内容相似的，我们需要一个可以旋转的加农炮，只是这次的旋转是在3D环境中了。</p></li>
<li><p>添加炮弹 &#8212;- 加农炮设计的炮弹，也将在3D环境中处理，当然其实也就是初速度稍许不同，接触到之后就会发觉到2D教程的作用了。</p></li>
<li><p>添加敌方UFO &#8212;- 还是类似的，UFO从屏幕的远端向近端飞来，而不是右侧飞到左侧了哦。</p></li>
<li><p>碰撞检测 &#8212;- 3D的碰撞检测。</p></li>
<li><p>添加声效 &#8212;- 之前2D的游戏是没有声音的，这一次的3D中我们将加入声音，者是新的内容，会十分有趣的。</p></li>
</ol>


<p>大致的内容就是这样。当然，如果你没有看2D的教程，直接开始3D的也是可以的，只是和2D对比的部分直接略去就可以了。另外，本教程使用XNA Game Studio 3.1开发，如果你是使用的是之前的版本，或者是未来的某个版本，那么其中也许会有一些不同之处。如果你刚刚开始，那么就赶快装上Game Studio开始吧。</p>

<p><strong>相关链接：</strong></p>

<ul>
<li><p><a href="http://arthraim.cn/post/2009/06/61.html">XNA教程-2D游戏-索引</a></p></li>
<li><p><a href="http://creators.xna.com/en-US/education/gettingstarted/bg3d/chapter1">XNA Creators Club 教程原址</a></p></li>
<li><p><a href="http://creators.xna.com/en-us/news/xnagamestudio3.1">XNA Game Studio 3.1 介绍及下载地址</a></p></li>
<li><p><a href="http://arthraim.cn/post/2009/06/60.html">环境配置及安装的简单介绍请看《XNA Game Studio 3.1 Available》</a></p></li>
</ul>


<p><strong>Demo效果图：</strong></p>

<p><a href="/images/uploads/zb/2009-06-27_Glance.jpg"><img src="/images/uploads/zb/2009-06-27_Glance.jpg" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-25T22:47:25+08:00" pubdate data-updated="true">Jun 25<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-index/">
		
			XNA教程-2D游戏-目录索引</a>
	</h2>
	<div class="entry-content">
		<p><a href="/images/uploads/zb/XNA_logo.jpg"><img src="/images/uploads/zb/XNA_logo.jpg" alt="" /></a></p>

<p><strong>2011-01-16更新：换了域名和URL，更新一下链接~</strong></p>

<p>XNA GameStudio 3.1，微软XNA Creators Club Online上2D游戏视频教程文字版索引。</p>

<p><strong>XNA游戏教程.2D</strong></p>

<ol>
<li><p><a href="/xna-tutorial-2d-ch1-introduction/">2D游戏教程简介</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch2-create-solution/">创建游戏工程</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch3-add-assets/">添加Asset</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch4-rending-backgrounds/">绘制背景</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch5-create-a-cannon/">添加一门加农炮</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch6-launch-missiles/">发射炮弹</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch7-create-enemy-ufo/">添加敌人UFO</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch8-destroy-ufo/">摧毁UFO</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch9-record-scores/">记录分数</a></p></li>
<li><p>其他扩展：<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/ExtraCredit">Extra Credit - Community Tutorials</a></p></li>
</ol>


<p><strong>相关知识点链接</strong>（在各个章节中涉及到的知识点，基本上都在文章的末尾）：</p>

<ol>
<li><p><a href="/xna-tutorial-2d-ch3-add-assets/">什么是Asset？</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch4-rending-backgrounds/">Content Pipeline是如何工作的？</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch4-rending-backgrounds/">Sprites，Sprites绘制，和SpriteBatch。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch5-create-a-cannon/">为什么要创建GameObject类？</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch5-create-a-cannon/">XNA Game Studio中表示的角。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch6-launch-missiles/">使用数组。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch6-launch-missiles/">转化一个旋转角度为速度向量。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch7-create-enemy-ufo/">随机数和线性插入方法Lerp。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch8-destroy-ufo/">使用Rectangle的2D碰撞检测。</a></p></li>
</ol>


<p><strong>原视频教程链接</strong>：<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/chapter1">这里</a></p>

<p><strong>系列3D教程目录索引</strong>：<a href="/xna-tutorial-3d-index/">这里</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-19T08:18:48+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch9-record-scores/">
		
			XNA教程-2D游戏-09-记录分数</a>
	</h2>
	<div class="entry-content">
		<p>游戏基本上已经什么都有了，不过接下去还有一些工作 &#8212;- 记分。通过击毁UFO来获得分数，这是一个简单的功能，不过还是什么必要的，因为我们不单单是记住分数，还要把它显示在屏幕上，所以如何在屏幕上显示字符才是关键所在。如果你愿意，可以显示一些其他信息，比如常见fps等等。</p>

<p>那么接下来，介绍方法。</p>

<p><strong>第一步、添加Font到Content中</strong></p>

<p><strong>一、添加SpriteFont的Content资源。</strong></p>

<p>要在Content pipline中添加SpriteFont（字体）的内容。</p>

<ol>
<li><p><strong>Content中添加一个Fonts文件夹</strong>。</p>

<p>   <img src="/images/uploads/zb/2009-06-19_AddFontToContent.jpg" alt="" /></p></li>
<li><p><strong>在Fonts中添加一个GameFont对象</strong>。</p>

<p>   [<img src="/images/uploads/zb/2009-06-19_AddSpriteFont.jpg" alt="" /></p>

<p>   ](/images/uploads/zb/2009-06-19_AddSpriteFont.jpg)</p></li>
<li><p><strong>修改XML文件</strong>。具体参照如下代码，字体和字体大小的修改。</p></li>
</ol>


<pre><code>&lt;FontName&gt;Arial&lt;/FontName&gt;
&lt;Size&gt;18&lt;/Size&gt;
</code></pre>

<p>好了，这样准备工作就完成了，我们可以在之后的Content的相关操作中使用这个font了。</p>

<p><strong>二、声明一些新变量</strong></p>

<p>声明一个int型的分数。</p>

<p>声明一个SpriteFont对象当作字体。</p>

<p>声明一个Vector2来记录分数显示的位置（百分比）。</p>

<pre><code>int score;
SpriteFont font;
Vector2 scoreDrawPoint = new Vector2(0.1f, 0.1f);
</code></pre>

<p>就像之前说的，微软的大大们都有强大逻辑，可以在开始写程序的时候声明出所有的变量。</p>

<p><strong>三、Content载入字体</strong></p>

<p>在LoadContent方法中载入我们感概添加和修改的字体。</p>

<pre><code>font = Content.Load&lt;SpriteFont&gt;(@"FontsGameFont");
</code></pre>

<p>这样，我们就可以自由的使用了。</p>

<hr />

<p><strong>第二步、添加记分逻辑</strong></p>

<p>视频中的逻辑是击毁一个UFO加一分，所以在判断碰撞的地方加上score++就好。</p>

<p>我设计的逻辑击毁加2分，漏掉一个（飞出屏幕）扣一分。</p>

<p>当然你可以设计更加复杂的功能，比如距离远速度快的3分等等，总之分数不是关键。</p>

<hr />

<p><strong>第三步、绘制分数</strong></p>

<p>绘制我们记分的结果，在Draw这个方法的SpriteBatch.End()之前加入绘制字符串的代码。</p>

<pre><code>spriteBatch.DrawString(
    font,
    "Score:" + score.ToString(),
    new Vector2(
        scoreDrawPoint.X * viewportRect.Width,
        scoreDrawPoint.Y * viewportRect.Height),
    Color.White);
</code></pre>

<p>看一下参数。</p>

<ol>
<li><p>SpriteFont，要求传入一个SpriteFont，我们这里传入了之前创建的font。</p></li>
<li><p>string，传入要显示的字符串，这里是得分。</p></li>
<li><p>Vector2，传入一个显示位置（左上角）的Vector2，这里我们利用之前创建的百分比和屏幕大小计算出一个新的Vector2</p></li>
<li><p>Color，传入一个字形的颜色。</p></li>
</ol>


<p>好了，这样我们的游戏就完整的完成了。放一张运行时的截图。</p>

<p><a href="/images/uploads/zb/2009-06-19_Chapter9_Runtime.jpg"><img src="/images/uploads/zb/2009-06-19_Chapter9_Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=156"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-19T08:03:20+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch8-destroy-ufo/">
		
			XNA教程-2D游戏-08-摧毁UFO</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 08 &#8211; 摧毁UFO</strong></p>

<p>这一次要做的是很NB的事情，碰撞检测（Collision Detection），具体到我们的例子，具象一点的，那么就是摧毁UFO，当然在无数游戏中，碰撞检测都是至关重要的东西，和随机比起来不相上下吧。无论是什么游戏类型，物体和物体之间的接触都是要处理的，尚且不说加上什么物理特性，光是这个例子里的子弹碰UFO总要有点反应吧。更不用说什么火星撞地球了………………</p>

<p>具体代码很简单，找到UpdateCannonBalls方法，在更新的时候，添加一种杀掉UFO和炮弹的情况，就是两者碰撞的时候。</p>

<p>大致的思路为：</p>

<ol>
<li><p>确定每个炮弹的范围大小和UFO的范围大小。</p></li>
<li><p>遍历每个炮弹。</p></li>
<li><p>遍历中每个炮弹再要遍历每个UFO。如果发生碰撞就同时摧毁两个（alive = false）</p></li>
</ol>


<p>这里我们要用到的碰撞检测，直接使用XNA的Rectangle的intersect方法。以下是代码，添加在判断是否出屏幕的下面。</p>

<pre><code>Rectangle cannonBallRect = new Rectangle(
    (int)ball.position.X,
    (int)ball.position.Y,
    ball.sprite.Width,
    ball.sprite.Height);
foreach(GameObject enemy in enemies)
{
    Rectangle enemyRect = new Rectangle(
        (int)enemy.position.X,
        (int)enemy.position.Y,
    enemy.sprite.Width,
    enemy.sprite.Height);
    if(cannonBallRect.Intersects(enemyRect))
    {
        ball.alive = false;
        enemy.alive = false;
        break;
    }
}
</code></pre>

<p>首先获得当前遍历到的cannonBall的范围，循环。循环中得到当前UFO的范围，检测是否和cannonBall相交（哪一方都一样）。碰撞了，就两个对象的alive都为false，然后break出UFO的循环。</p>

<p>执行结果（其实截图看不出来效果唉）</p>

<p><a href="/images/uploads/zb/2009-06-18_Chapter8Runtime.jpg"><img src="/images/uploads/zb/2009-06-18_Chapter8Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=155"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>翻译：使用Rectangle的2D碰撞检测</strong></p>

<p>（以下文字由本博客翻译自这里，转载请注明出处）</p>

<blockquote><p>图片创建的Sprite从一创建就必然是一个长方形。你可以使用遮盖(Mask)，来绘制Sprite中的一部分像素，这样就产生了Sprite不是一个长方形的视觉效果。Sprite可能呈现为一个圆形的物体，或者更加复杂的形状。但是所有的sprite一创建就都是矩形的。</p>

<p>Sprite的这一特性在非常基本的碰撞检测中很实用，XNA Framework提供了一个Rectangle类，自己就拥有碰撞帮助的方法：ectangle.Intersects，和Rectangle.Contains。</p>

<p>在基本的常识中，碰撞检测是基于相交检测的 &#8212;- 两块几何图形是否相交。如果两个几何图形相交，他们可以说是碰撞，游戏逻辑可以根据碰撞的物体产生适当的反应。</p>

<p>在我们的2D游戏中，我们关心加农炮是不是和地方UFO相交。如果加农炮的sprite的rectangle相交于敌人sprite的rectangle，那我们的游戏逻辑检测到了一个碰撞，并且同时摧毁两个物体。</p>

<p>Rectangle很容易创建。Rectangle类初始化时需要4个参数 &#8212;- 矩形左上角的点的X和Y坐标，以及矩形的宽度和高度。所有矩形的其他点都会有这些信息计算出来。</p>

<p>创建sprite占用的rectangle之间的碰撞，设置X和Y的值为游戏世界中的sprite的X和Y值，GameObject.position.X和GameObject.position.Y。设置宽度和高度为sprite中的Texture2D的宽度和高度，GameObject.sprite.Width和GameObject.sprite.Height。</p>

<p>凭借两种游戏直接中sprite的rectangle对象的创建和调用Rectangle.Intersects方法，你可以知道两个物体是否碰撞。这可能不是最精确的碰撞。包括还有其他的缺点，如果是屏幕上已经画了的一个旋转过的sprite，rectangle对象的定义就不再符合sprite在屏幕上绘制的样子了。然而这是一个简单高效的方法来做碰撞检测。</p>

<p>一个类似的有用的方法是Rectangle.Contains。在我们的2D游戏中，使用一个rectangle来表示整个屏幕，我们可以定义什么时候GameObject离开了屏幕的边界。我们在比较屏幕rectangle和对象rectangle的时候，使用检查Rectangle.Contains的值是否为false的方法来判断是否离开屏幕。</p>

<p>下面的图表列出了Rectangle.Intersects和Rectangle.Contains两个不同的矩形成员的不同输出情况。</p>

<p><img src="/images/uploads/zb/BG_3.8.1.1pd_a.png" alt="" /></p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-19T06:13:16+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>

<nav id="pagenavi">
    
        <a href="/blog/page/14/" class="prev">Prev</a>
    
    
        <a href="/blog/page/16/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2012

    Arthur Wang

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'artorius';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-8352384-7']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>