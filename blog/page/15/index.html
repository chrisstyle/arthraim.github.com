
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Artoirus</title>
	<meta name="author" content="Arthur Wang">

	
	<meta name="description" content="从2D的意识转换到3D游戏的意识之后（也许还有直接接触3D的），之后的工作就和2D一样简单了，想想教程的例子要有什么——加农炮、UFO、炮弹，就是全部了。我们要一个一个的添加到游戏中，但是和2D一样，我们一定会有大量重复的工作，所以我们需要把这些代码封装， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Artoirus" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>

<body>
	<header id="header" class="inner"><h1><a href="/">Artoirus</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:artori.us">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:artori.us">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch5-render-gameobject/">
		
			XNA教程-3D游戏-05-绘制GameObject</a>
	</h2>
	<div class="entry-content">
		<p>从2D的意识转换到3D游戏的意识之后（也许还有直接接触3D的），之后的工作就和2D一样简单了，想想教程的例子要有什么——加农炮、UFO、炮弹，就是全部了。我们要一个一个的添加到游戏中，但是和2D一样，我们一定会有大量重复的工作，所以我们需要把这些代码封装，所以我们将创建一个具有一般性的类GameObject，来代替所有的加农炮、UFO等等物件的凌乱的代码。</p>

<p><strong>第一步、创建GameObject类</strong></p>

<p>GameObject类究竟有什么好处，烦请大家看下<a href="http://arthraim.cn/view.asp?id=65">这里</a>的末尾《为什么要创建自己的类》这一部分，当然，有过任何OO语言基础的人也知道为什么要封装一个类。</p>

<p>写这个类和2D的如出一辙，一样的我们需要有他的模型Model（sprite）、位置Position、旋转rotation。再加上一个scale属性。至于scale是哪一种，我们这里只是用来缩放模型大小的最最简单的。</p>

<blockquote><p>右键单击工程 -> Add -> New Class -> 命名为GameObject.cs</p></blockquote>

<p>然后修改类为如下代码：</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using Microsoft.Xna.Framework.Net;
using Microsoft.Xna.Framework.Storage;
namespace YourNamespace // 注意修改
{
    class GameObject
    {
        public Model model = null;
        public Vector3 position = Vector3.Zero;
        public Vector3 rotation = Vector3.Zero;
        public float scale = 1.0f;
    }
}
</code></pre>

<p>这样一个通用的GameObject类就简简单单写完了。</p>

<ul>
<li><p>Model为null，防止没有被实例化的情况。</p></li>
<li><p>两个Vector3都为Zero，位置在原点，没有方向。</p></li>
<li><p>scale为1.0f，表示1.0倍的大小。</p></li>
</ul>


<hr />

<p><strong>第二步、应用GameObject到terrain</strong></p>

<p>既然有了GameObject类，我们就应该把它应用到所有的要加入我们的3D世界的模型中，那么terrain也不例外。所以这一步我们稍稍花点时间，把之前写的terrain的代码修改一下，应用GameObject类。之前有3处地方要写，那么现在就有3处地方要改，声明、初始化、绘制。因为绘制还要做其他的修改，所以我们这里先修改声明和初始化部分。</p>

<p>（注释为原先的代码，其他为新编写的代码）</p>

<p><strong>1、声明。</strong>Game1类刚刚开始的地方，声明很多变量的地方。</p>

<pre><code>//Model terrainModel;
//Vector3 terrainPosition = Vector3.Zero;
GameObject terrain = new GameObject();
</code></pre>

<p><strong>2、初始化 。</strong>找到LoadContent()中和terrain有关的部分。</p>

<pre><code>//terrainModel = Content.Load&lt;Model&gt;(@"Modelsterrain");
terrain.model = Content.Load&lt;Model&gt;(@"Modelsterrain");
</code></pre>

<p>这样，terrain就成为了第一个GameObject的应用。接下去。</p>

<hr />

<p><strong>第三步、创建新GameObject，MissleLauncherBase</strong></p>

<p>MissleLauncherBase就是指加农炮的基座，基座是不动的，放在一个固定的位置，我们还是要使用GameObject类来创建他，和terrain是一样的。</p>

<p><strong>1、声明</strong>。Game1类刚刚开始的地方，声明很多变量的地方。</p>

<pre><code>GameObject missleLauncherBase = new GameObject();
</code></pre>

<p><strong>2、初始化 。</strong>找到LoadContent()中和terrain有关的部分。</p>

<pre><code>missleLauncherBase.model = Content.Load&lt;Model&gt;(@"Modelslauncher_base");
missileLauncherBase.scale = 0.2f;
</code></pre>

<p>加上scale的属性，确定缩放。一样把绘制部分交给最后一步统一完成。</p>

<hr />

<p><strong>第四步、绘制GameObject</strong></p>

<p>之前我们绘制过terrain，但是我们使用的是terrainModel这个Model类，和terrainPosition这个Vector3类。现在我们已经将GameObject引入了我们的游戏中，所以我们要重新修改DrawModel方法，我们不需要一个模型一个模型的画，只需要把GameObject这样一个通用的对象，采用一种通用的方法画就可以了。</p>

<p>所以找到DrawModel方法，我们重新写一个DrawGameObject方法（DrawModel方法当然一定用不着了，删掉也行），入参为GameObject。很好，代码如下。</p>

<pre><code>void DrawGameObject(GameObject gameobject)
{
    foreach (ModelMesh mesh in gameobject.model.Meshes)
    {
         foreach (BasicEffect effect in mesh.Effects)
         {
             effect.EnableDefaultLighting();
             effect.PreferPerPixelLighting = true;
             effect.World =
                 Matrix.CreateFromYawPitchRoll(
                     gameobject.rotation.Y,
                     gameobject.rotation.X,
                     gameobject.rotation.Z) *
                 Matrix.CreateScale(gameobject.scale) *
                 Matrix.CreateTranslation(gameobject.position);
             effect.Projection = cameraProjectionMatrix;
             effect.View = cameraViewMatrix;
         }
         mesh.Draw();
    }
}
</code></pre>

<p>不难发现我们对effect.World的初始化发生了一些变化，原本我们只是使用了Matrix.CreateTranslation方法，而现在还添加了两个方法，并且取了三个方法的乘积。这其实就像我<a href="http://arthraim.cn/post/2009/07/74.html">上一章</a>提到过的所有的变化都可以转换为多个变换矩阵的乘积。于是在代码里我们把表示旋转、缩放、位移的三个矩阵相乘，来完成所有这样三个的变化（下面资料中将详细讲解，这三个矩阵被翻译成旋转、比例、转换，其实旋转、缩放、位移更加易于理解）。另外，下一章中，加入加农炮的发射塔，这些参数将变得可控（虽然当前的terrain和missleLauncherBase都是不变的），所以这里依然使用了这样的方式，为了这个方法的通用性。（之后关于此内容还将有官方说明内容）</p>

<p>完成对这个方法的修改，只需要修改Draw方法中的代码就可以了。</p>

<pre><code>DrawGameObject(terrain);
DrawGameObject(missileLauncherBase);
</code></pre>

<p>就这样取代之前的DrawModel的调用，加上两行，每一个GameObject只需要一行的调用。这样绘制工作就算完成了。</p>

<p>运行一下，看看实际效果吧！</p>

<p><a href="/images/uploads/zb/2009-07-05_Runtime.jpg"><img src="/images/uploads/zb/2009-07-05_Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=160"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>特别说明</strong>：这段翻译，其实讲的就是世界变换的3个矩阵的情况，因为rotation scale translation这三个词中文的叫法是什么我不太清楚，所以这里权且翻译成旋转、比例、转换这样子，尤其是转换这个词不太好，不过因为translation真正完成的工作其实就是平移矩阵，相当于坐标轴的转换，所以只取了转换两个字，希望不会对大家理解上产生困扰。</p>

<p>（以下文字翻译自这里，未经允许禁止转载。由于本人水平有限，所以有任何错误希望高手更正。）</p>

<p><strong>翻译：构造世界的变换</strong></p>

<blockquote><p>3D模型由3D建模软件创建。在这些软件包中，美工们创建了3D世界中的模型。这个世界有一个中心，叫做原点，并且模型根据它来创建。位置、旋转和比例都和相对原点相关联，并且当游戏载入一个模型，会保留他的位置、旋转和比例关系。这样，这个模型被称作在“对象空间”或“模型空间”中。</p>

<p>当一个游戏绘制一个模型时，它连接了模型空间中的原点和游戏世界中的原点。如果这个模型在3D建模软件中存储的中心位置正好是模型空间的原点，那在游戏中绘制的时候他就会出现在游戏世界的原点。</p>

<p>当在你的游戏中绘制一个3D模型，你需要把3个变换应用到你的3D模型上。三者中的第一个，“世界转换”，定义如何转换你的模型的初始位置、方向和比例（对象空间）到游戏世界中的某个位置、方向和比例。</p>

<p>一个标准的世界转换分别由三个矩阵组成（旋转、比例和转换），所有的都将被整合成一个世界变换矩阵。</p>

<p>  *</p>

<p>&#8211; “旋转”（rotatiton）变化模型角度的方向——你可以把它想象成在空间中根据一点朝不同的方向旋转模型。有很多计算和存储旋转数值的方法，一种最常用的就是欧拉角，围绕三个轴旋转一个对象，X轴、Y轴和Z轴。（下一节会解释和说明欧拉角）。创建一个旋转矩阵，你可以使用Matrix.CreateFromYawPitchRoll方法，传入围绕各个轴的旋转角度。要存储游戏对象的这些角度，Vector3类是一个很好的选择。</p>

<p>  *</p>

<p>&#8211; “比例”（scale）变化模型的尺寸，使它能更大或更小。因为它可以让模型沿着任意轴拉伸，它更多的被应用到统一的比例，使得整个模型缩小或放大。要创建一个比例矩阵，使用Matrix.CreateScale方法，传入你要缩小或放大模型的因数。你可以存储游戏对象的比例因数为一个简单的float类型。</p>

<p>  *</p>

<p>&#8211; “转换”（translatiton）沿着3D世界的3个轴移动整个模型。想象成到处平移模型：左右移动（X轴），上下移动（Y轴），前后移动（Z轴）。创建一个转换矩阵，使用Matrix.CreateTranslation方法，传入你要沿着各个轴移动的数据。存储转换的数值可以使用Vector3。</p>

<p>一旦你创建了这些矩阵，你必须把它们组合成为一个单独的世界变换矩阵。这个工作被称为级联（concatenation）。在XNA Game Studio中，级联一个矩阵和另一个矩阵，使用乘法符号（*）。你必须使用正确的顺序级联这些矩阵。</p>

<p><em>世界变换 = 旋转 × 比例 × 转换。</em></p></blockquote>

<pre><code>    _World Transformation = Rotation * Scale * Translation_
</code></pre>

<blockquote><p>级联的顺序十分重要。因为矩阵惩罚是没有交换律的，所以用错误的顺序相乘会产生预期之外的结果——比如意外的在旋转之前转换坐标系，相对世界原点旋转了坐标系转换后的模型，使模型到了比起简单的正常旋转后的世界空间中的位置非常非常遥远的其他位置，</p>

<p>修改几次每个独立的变换矩阵传入的数值，你可以是物体在世界中穿过（转换），在空间中旋转（旋转），平滑的缩小或放大，或者三个的组合效果。</p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-05T19:48:03+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch4-render-3d-titan/">
		
			XNA教程-3D游戏-04-绘制3D地表</a>
	</h2>
	<div class="entry-content">
		<p>安装好环境、建立了XNA工程、添加了要用到的模型以及贴图，那么接下来要做的就是实际的代码了，而一上来就和2D大为不同的是，我们要直接创建我们的&#8221;宇宙环境&#8221;。要知道，在2D游戏中，我们游戏的&#8221;世界&#8221;是整个一张图，就是背景，简单的2D游戏就是这样。而3D则不然，即便是这个环境，那么也是需要我们用模型自己创建的，而这将会是一个非常复杂的工作，究竟如何复杂，看到下面的所有内容你就明白了。</p>

<p>从2D到3D，应该说当前我们在做的是一个非常困难的转换时期，我们要完成第一个3D的绘制，那么就必须了解很多很多只有在3D游戏中才会出现的概念。但是，简单的说，在代码上我们要完成的工作还是类似的，比如2D中，我们先声明了sprite；然后loadContent，或者load确定它的位置等信息；最后我们draw把它绘制出来。那么一样的，3D也是声明、初始化、绘制三个工作。只是2D中无论是初始化还是绘制都是相对简单的，3D就要复杂的多的多，跟着步骤走吧。</p>

<hr />

<p><strong>第一步、创建模型，确定视角</strong></p>

<p>似乎看了标题就有些茫然，有很多的概念要讲，不过和2D教程一样，先直接说代码怎么写，回头再讲大道理。（本文后面将会有官方解释的翻译内容）</p>

<p><strong>1、声明场景模型</strong></p>

<p>代码找到Game1类中最前面，SpriteBatch spriteBatch;这一行的下方，在这里我们先插入这样两行代码。</p>

<pre><code>Model terrainModel;
Vector3 terrainPosition = Vector3.Zero;
</code></pre>

<p>这里用到了XNA Framework提供的Model类，以及Vector类。</p>

<p>显然，terrainModel这样的命名让人比较容易理解，就是场景模型，这是我们的场景或者说是地面模型，都一样，就是我们的大环境。</p>

<p>而terrainPostision就更加容易理解了，是terrain的位置，究竟整个地表是怎样的一个位置。这里我们用Vector3这个类来描述。Vector3是一个3维的向量，就像Vector2是X,Y两个轴的向量一样，Vector3实质上就是把Vector2扩展到X,Y,Z，3个轴的向量。初始化为Vector3.Zero，即在整个3维坐标系的原点上。</p>

<p>和2D游戏不同，我们2D游戏所有涉及到的坐标都是在屏幕范围内的。我们知道屏幕向右是X轴正方向，向下是Y轴正方向，所以所有的坐标都是在这样一个坐标系上想象的。而3D游戏则不同，我们必须把这些位置都想象在自己的脑海中，因为屏幕看见的什么只是你3D世界的一角，你必须在整个思维中存在你的自己的一个三维世界，它所在的一个三维坐标系和它的所有坐标。然后我们再讨论从什么视角（什么坐标）去看这个世界。</p>

<p><strong>2、声明镜头</strong></p>

<p>说明一下，这里的镜头英文应当是camera，翻译成相机这样子比较好。不过也许很多像我一样的游戏玩家会知道，一般我们评价一个游戏，会说镜头能控制不能控制等等，所以我想这个词会更加容易被接受。我的文章里的镜头，指的就是camera。可以想象你的眼睛就是你看这个现实世界的camera。</p>

<p>在刚才两行代码下面，继续写以下内容。</p>

<pre><code>Vector3 cameraPosition = new Vector3(0.0f, 60.0f, 160.0f);
Vector3 cameraLookAt= new Vector3(0.0f, 50.0f, 0.0f);
Matrix cameraProjectionMatrix;
Matrix cameraViewMatrix;
</code></pre>

<p>详细说一下我们做了什么。</p>

<ul>
<li><p>cameraPosition：这是镜头所在的位置，比如我们的眼睛在脸上这样的描述。这里是(0, 60, 160)这样一个位置。</p></li>
<li><p>cameraLookAt：镜头的焦点。可以想象一下terrain被放在Y轴也就是高度轴的0上，镜头被放在Z轴也就是深度轴的160的位置，高度是60的位置，而它看着Y轴上50的那点，连成的直线就是你的视线了。</p></li>
<li><p>cameraProjectionMatrix：镜头投影矩阵。</p></li>
<li><p>cameraViewMatrix：镜头视角矩阵。关于两个矩阵，先不详细讲了。图形学中涉及到了任意点的变换可以使用矩阵，矩阵变换是一个图形学非常重要的概念。稍微讲一下。</p></li>
</ul>


<p>矩阵变换一般情况下有平移、缩放、旋转。各种复杂的变化都可以由很多这样的操作完成。其他还有诸如投影、切割等等。所有的变化都可以最终表示成为一个矩阵，这就是变换矩阵。不详细讲，举3个例子。</p>

<p><strong>例一</strong>：平移 W(wx,wy,wz)</p>

<p><img src="/images/uploads/zb/2009-07-03_Matrix1.jpg" alt="" /></p>

<p><strong>例二</strong>：缩放 T(tx,ty,tz)</p>

<p><img src="/images/uploads/zb/2009-07-03_Matrix2.jpg" alt="" /></p>

<p><strong>例三</strong>：绕X轴旋转alpha度</p>

<p><img src="/images/uploads/zb/2009-07-03_Matrix3.jpg" alt="" /></p>

<p>当然在XNA framework里封装的Matrix类不是一个简单的矩阵的实现了，还加上了很多智能的功能，当然也包括变换，至于如何使用这样一个Matrix，以及我们声明的Matrix是做什么样的变换的，看下去。</p>

<p><strong>3、初始化变换矩阵</strong></p>

<p>我们要初始化声明的资源，那么就要找到LoadContent()方法，在其中TODO的位置加上这样两句。</p>

<pre><code>cameraViewMatrix = Matrix.CreateLookAt(
    cameraPosition,
    cameraLookAt,
    Vector3.Up);
cameraProjectionMatrix = Matrix.CreatePerspectiveFieldOfView(
    MathHelper.ToRadians(45.0f),
    graphics.GraphicsDevice.Viewport.AspectRatio,
    1.0f,
    10000.0f);
</code></pre>

<p>这里做的工作是实例化两个Matrix，但是这里用到了Matrix类中的CreateLookAt和CreatePerspectiveFieldOfView方法。说下参数的意思。</p>

<ul>
<li><p>CreateLookAt：</p>

<ul>
<li><p>cameraPosition：Vector3，镜头所在位置</p></li>
<li><p>cameraLookAt：Vector3，镜头焦点坐标</p></li>
<li><p>Vector3.Up：Vector3，按照MSDN所说传入&#8221;上&#8221;就好，当然你可以试一下其他方向……</p></li>
</ul>
</li>
<li><p>CreatePerspectiveFieldView：</p>

<ul>
<li><p>MathHelper.ToRadians(45.0f)：float，视角大小</p></li>
<li><p>graphics.GraphicsDevice.Viewport.AspectRatio：float，窗口的比率，&#8221;宽&#8221;比上&#8221;长&#8221;的比率</p></li>
<li><p>1.0f：float，镜头最小深度（近处）</p></li>
<li><p>10000.0f：float，镜头最大深度（远处）（恐怕真三国无双和GTA这样的游戏里面这个参数的体会会比较深刻）</p></li>
</ul>
</li>
</ul>


<p>初始化完毕，就可以接下去继续了。</p>

<hr />

<p><strong>第二步、编写模型绘制方法</strong></p>

<p>因为游戏中将会出现很多很多的模型，虽然每一个模型都有其特殊的地方，但是每一个模型都将拥有一个默认的绘制方式。而，即便采用默认的方式，绘制模型也将会涉及到很多操作，所以将本来可以在draw方法中完成的内容单独的写一个方法来完成。方法传入的参数为模型和其所在的位置，这样我们的方法就可以把它用一样的操作绘制出来。</p>

<p>这里涉及到一个ModelMesh的类，每一个Model都一个很多的ModelMesh的集合，因此我们需要单独绘制每一个mesh。至于ModelMesh和Model的概念，在后面会加上说明。（本文后面将会有官方解释的翻译内容）</p>

<p>具体方法是，在Game1类中重新写一个方法，当然是任意位置的，代码具体如下。</p>

<pre><code>void DrawModel(Model model, Vector3 modelPosition)
{
    foreach (ModelMesh mesh in model.Meshes)
    {
        foreach (BasicEffect effect in mesh.Effects)
        {
            effect.EnableDefaultLighting();
            effect.PreferPerPixelLighting = true;
            effect.World = Matrix.CreateTranslation(modelPosition);
            effect.Projection = cameraProjectionMatrix;
            effect.View = cameraViewMatrix;
        }
        mesh.Draw();
    }
}
</code></pre>

<p>如参正如之前所说，一个是Model类，一个是Vector3类，分别表示要绘制的模型和其所在的位置。</p>

<ul>
<li><p>第一个foreach循环是遍历Model中所有的ModelMesh，单独处理每一个。</p></li>
<li><p>第二个foreach循环是遍历ModelMesh中的Effects，单独处理每一个效果的处理。具体看看做了一些什么</p>

<ul>
<li><p>EnableDefaultLighting()：设定光源为默认光源。</p></li>
<li><p>effect.PreferPerPixelLighting = true;：在支持Pixel Shader Model 2.0的情况下，开启每个像素按光源渲染的效果。</p></li>
<li><p>effect.World = Matrix.CreateTranslation(modelPosition);：创建传入模型的矩阵变换</p></li>
<li><p>effect.Projection = cameraProjectionMatrix;：设定投影变换矩阵。</p></li>
<li><p>effect.View = cameraViewMatrix;：设定视角变换矩阵。</p></li>
</ul>
</li>
</ul>


<p>这样，我们就完成了绘制方法的编写。但是不要忘了，我们还没有加载需要绘制的模型，也没有在draw方法中调用这个方法，所以看接下去的两步，完成这两个工作。</p>

<hr />

<p><strong>第三步、加载模型</strong></p>

<p>载入模型才能画，载入模型的方法和2D的一模一样，只是一个操作的是Sprite，一个操作的是Model，但是我们知道LoadContent方法是支持范型的，那么显然我们的工作就变得非常的简单了。</p>

<p>找到LoadContent方法，在之前添加的代码下面加上如下代码。</p>

<pre><code>terrainModel = Content.Load&lt;Model&gt;(@"Modelsterrain");
</code></pre>

<p>这样，这一步就简简单单的完成了。</p>

<hr />

<p><strong>第四步、绘制模型</strong></p>

<p>之前第二步完成的工作就大大简化了这一步我们的代码了。而这一步我们就只要调用之前我们写的drawModel方法，并且传入我们的模型和位置就可以了。</p>

<p>在Draw方法的TODO处，加入以下代码：</p>

<pre><code>DrawModel(terrainModel, terrainPosition);
</code></pre>

<p>还等什么呢？现在就是编译运行的时候了！效果图。</p>

<p><a href="/images/uploads/zb/2009-07-03_Runtime.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime.jpg" alt="" /></a></p>

<p>下面加了4张修改了参数之后的图，方便理解一些参数。[点击放大]</p>

<p><a href="/images/uploads/zb/2009-07-03_Runtime_Down.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_Down.jpg" alt="" /></a> <a href="/images/uploads/zb/2009-07-03_Runtime_100CameraHeight.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_100CameraHeight.jpg" alt="" /></a> <a href="/images/uploads/zb/2009-07-03_Runtime_95Radians.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_95Radians.jpg" alt="" /></a> <a href="/images/uploads/zb/2009-07-03_Runtime_5000Depth.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_5000Depth.jpg" alt="" /></a></p>

<ul>
<li><p>cameraViewMatrix实例化，CreateLookAt时，修改第三个参数为Vector3.Down</p></li>
<li><p>cameraPosition声明并实例化时，修改为Vector3(0.0f, 100.0f, 160.0f)</p></li>
<li><p>cameraProjectionMatrix实例化，CreatePerspectiveFieldOfView时，修改第一个参数为90.0f</p></li>
<li><p>cameraProjectionMatrix实例化，CreatePerspectiveFieldOfView时，修改第四个参数为5000.0f</p></li>
</ul>


<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=159"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>那么下面就贴翻译的内容，也算是比较重要的东西了，2D和3D游戏的概念上的区别。</p>

<p>（以下翻译为本人原传，未经允许严禁转载。另外，因本人能力有限难免出错，请高手指正。原址点击<a href="http://creators.xna.com/en-US/education/gettingstarted/bg3d/details/4_1">这里</a>。）</p>

<p><strong>1、3D世界：2D游戏和3D游戏之间的区别</strong></p>

<blockquote><p>如果你学习过第一个教程（创建2D游戏），那么你已经变得习惯用2D空间来思维了。位置、方向和动作可以全都用Vector2和一个单独的旋转角度来表示。</p>

<p>这个教程介绍了在三维的概念，和其一系列的新的对象。从根本上，3D世界区别于2D世界的就是新增的第三个坐标轴&#8212;-Z轴，或者说是深度。在XNA Game Studio中，2D世界实质上是一个特殊的，受限制的3D世界的版本&#8212;-你将会在本教程读到的计算也同样在2D中可以读到。</p>

<p>在XNA Game Studio这哦你，3D的变化意味着，取代在平面世界中画静态的Texture2D对象的是绘制用Model类表示的3D模型。Model类是被叫做网络（mesh）的许多有联系的3D点的集合，在整个世界中，最终渲染在屏幕上的对象，取决于对象的位置和方向，和镜头的位置和方向。</p>

<p><a href="/images/uploads/zb/BG_4.4.1.1pd.png"><img src="/images/uploads/zb/BG_4.4.1.1pd.png" alt="" /></a>这过程也许初看十分复杂，但其实在3D世界编程，只依靠一些非常基本的元素。想象一个点在3D空间中，一个点有一个X坐标,一个Y坐标,和一个Z坐标。非常类似2D空间中的一个点，3D空间中的一个点也可以使用一个向量来移动，但是在3D空间中，我们使用包含Z坐标的Vector3类。</p>

<p>然而，使用一个叫做矩阵的数学结构体，可以使3D点做更多的事情。这些结构体，在XNA Framework中表示为Matrix类，它描述了一系列可以应用于点的变换、点的集合、或一个响亮。使用矩阵，3D对象可以移动、旋转、切割、以及（通过使用被叫做视点矩阵和投影矩阵的特殊的矩阵）绘制成一个可以显示在屏幕上的2D图像。</p>

<p>想象有一系列我们想画在屏幕上的3D世界中的点。它们拥有相对于被叫做原点的中心点的位置和方向信息。如果没有任何的变换，这些点只是存在于他们自己的空间，被叫做&#8221;对象空间&#8221;。</p>

<p>当你加载一系列的点，并且把它们添加到你的3D世界中，你可能会想给他们一个在3D世界中的位置，用来旋转或切割他们。这些行动的产物被叫做世界变换矩阵。应用了这样的矩阵的点，就被想象成在&#8221;世界空间&#8221;中（而不是对象空间中）了。</p>

<p>来渲染在用户屏幕上的点，需要一些附加的信息。没有要绘制的2D场景的角度和位置，是不可能把整个3D常见转换到2D图像的。使用一个视点是必要的，也被称作镜头，只需绘制它所看到的3D场景。在准备这次绘制时，镜头信息会被计算到一个视角矩阵中，把3D点的方向和位置都和镜头联系起来。之后，这些3D点就被想象成在&#8221;视觉空间&#8221;中了。</p>

<p>用2D绘制一个3D场景最后还需要一些其他信息。像视点的视角和领域的信息，控制着3D点如何绘制在2D计算机屏幕上。这些信息存储在一个投影矩阵中，应用之后，把3D坐标的系统中的点转换到2D坐标系统中，2D坐标系统被成为&#8221;屏幕空间&#8221;，这样点被绘制成像素。</p>

<p><a href="/images/uploads/zb/BG_4.4.1.2pd.png"><img src="/images/uploads/zb/BG_4.4.1.2pd.png" alt="" /></a></p>

<p>如果要套用这个概念到3D点的集合所组成的网络（mesh）上（可以是3D表示的任何东西，一个飞船、一个人、或一只恐龙），你只需用到一些在XNA Framework中的基本的对象来制作你的游戏&#8212;-Mesh类，Matrix类和Vector类。</p></blockquote>

<p><strong> 2、创建一个模型绘制方法</strong></p>

<blockquote><p>绘制一个3D模型到屏幕上是一个复杂的工作。它包括了庞大数据量的多边形的绘制，而它们经常被构造成许多不同的方式。有些可能是基于艺术效果的，而有些也许是倾向于程序化的。绘制同时也是必要的工作。每个游戏中可见的3D对象都是需要经过一个绘制过程的。</p>

<p>毫无悬念的，不是只有一种组织一个模型绘制方法的方式。参数、界限以及绘制算法对每个游戏来说都是不同的，取决于游戏的需求和涉及的技术。在这样的情况下，XNA Framewrok没有尝试去提供一个单独的模型绘制方法。取而代之的是提供一些元素，而把组织它们的工作留给了程序员来做。</p>

<p>一个Model类是XNA Framework中表示3D模型的一个基本对象，但是它比最初的模型要复杂许多。一个模型由一个或多个ModelMesh对象以一个集合的形式组成。每个ModelMesh对象是一系列组成网络（mesh）的顶点的集合，它们可以在同一个模型中被单独的移动。</p>

<p>一个坦克的模型是一个很好的例子。坦克的身体也许是一个ModelMesh，坦克的炮台也许是另外一个。虽然你绘制的是整个坦克，但是你可能需要分开移动坦克的不同部分。你可以使用ModelMesh对象的集合来移动不同的部分。</p>

<p>ModelMesh包含了一个绘制方法。每绘制一个ModelMesh到屏幕上需要调用这个方法一次。然而如果你没有实现设定变换和MedelMesh上的光的属性，那么你什么也看不到。</p>

<p>变换（决定了ModelMesh在世界中的定向，并且最终，物体是否出现或是出现在屏幕的哪里）和光（）没有被应用到ModelMesh层面。相对的，每个ModelMesh有一些Effect和它联系在一起。一个Effect对象可以想成提供给可视设备的说明，关于如何绘制一个ModelMesh。</p>

<p>在很多游戏中，Effect对象是由很多复杂的顶点和像素遮罩（shader）组成的。在XNA Game Studio中也可以实现，并且对于高级图形效果来说十分重要。但是在简单的渲染中，XNA Framework Content Pipline（内容管道）提供了一个简单的机制来完成基本的光和绘制效果 &#8212;- BasicEffect类。</p>

<p>每个通过content pipline加载的ModelMesh接受了一个或多个BasicEffect对象，它们可以在不处理像素或顶点遮罩（shader）的情况下简单的处理变换和光源效果。所有这些BasicEffect类需要一系列表示世界（World）矩阵，视点（View）矩阵和投影（Projection）矩阵的Matrix类，和一些光照的参数。可以调用BasicEffect.EnableDefaultLighting()方法获得默认的参数。</p>

<p>在BasicEffect的参数被设置后，剩下的就只有调用ModelMesh.Draw方法，使用之前为BasicEffect设置的参数，来绘制ModelMesh到屏幕上了。</p>

<p><a href="/images/uploads/zb/BG_4.4.2.1pd.png"><img src="/images/uploads/zb/BG_4.4.2.1pd.png" alt="" /></a></p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-04T03:50:05+08:00" pubdate data-updated="true">Jul 4<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch3-add-assets/">
		
			XNA教程-3D游戏-03-添加Asset</a>
	</h2>
	<div class="entry-content">
		<p>到了这里其实还是和2D的教程是重叠的，这里我们要做的是添加asset们。所以这里你要问自己三个问题：</p>

<ol>
<li><p>你已经建立了工程（project）了吗？&#8212;- <a href="http://arthraim.cn/post/2009/06/72.html">点我补课</a></p></li>
<li><p>你已经下载了上一部分要求下载的资源了吗？&#8212;- <a href="http://creators.xna.com/downloads/?id=157">点我下载</a></p></li>
<li><p>你知道什么是asset吗？你看过之前2D教程的添加asset内容吗？&#8212;- <a href="http://arthraim.cn/post/2009/06/63.html">点我补课</a>（重点浏览链接指向的文章的后半部分，讲解什么是asset）</p></li>
</ol>


<p>三个问题过关的，再来看我的这里的屁话。放假回家，所以把编译一个XNA游戏都要3分钟的windows xp给格掉了（关注我的twitter的一定知道了），所以把windows 7的引导也格掉了。因为找不到之前安装windows 7的那张光盘，所以一下子没有修复引导，所以这一次的教程就先用XP完成了。装了3、4的系统，终于把一个一个的东西下载下来给装上了，现在可以继续了。</p>

<p>OK言归正传，看看这一次要做的是如何简单。和2D类似的右键添加等等工作，就能完成了。</p>

<p><strong>第一步、添加models到工程的content中</strong></p>

<p>Content中的asset可以在content pipeline中被我们调用。这是一个非常方便的设计，当然这也使得我们这一步的工作显得非常重要，你可以从磁盘去读取一些你需要的资源，但是让他在content管道中，会大大方便你的管理。</p>

<p>2D教程中，我们加入一些.tga资源到Content/Sprites中，我们右键新建文件夹，然后添加存在的资源等等这样完成了这部工作，那么这一次和视频一样，我们偷懒一下。直接把解压缩出来的models文件夹拖到VS2008的树状Solution Explorer的Content目录上，来完成这一步工作。</p>

<p>添加进来之后，我们看到了一些.fbx文件和.tga文件，fbx就是我们的模型，而tga是这些模型对应的贴图，不会被我们实际的工作主动调用到，他们只要在他们应该在的磁盘位置上就可以了，在我们调用模型的时候，相关联的贴图会自动被寻找，所以把他们排除我们的工程吧。右键选择所有的.tga文件，选择&#8221;Exclude From Project&#8221;将其排除工程。</p>

<p><a href="/images/uploads/zb/2009-07-01_ExcludeTgas.JPG"><img src="/images/uploads/zb/2009-07-01_ExcludeTgas.JPG" alt="" /></a></p>

<p><strong>第二步、添加audio到工程的content中</strong></p>

<p>这还分成两步看起来有点傻，一样的，把解压缩出来的audio文件夹也一并拖到Solution Explorer的Content目录上。展开Audio文件夹，右键点击Waves目录，选择&#8221;Exlude From Project&#8221;，把这些.wav文件全部排除在工程之内。因为对于声音的asset处理会有很大的不同，所以这里我们暂时先这样处理就好。</p>

<p>准备就绪之后，就可以开始代码阶段的工作了。</p>

<p>【官方工程下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=158"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-02T00:17:14+08:00" pubdate data-updated="true">Jul 2<span>nd</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch2-create-solution/">
		
			XNA教程-3D游戏-02-创建游戏工程</a>
	</h2>
	<div class="entry-content">
		<p>进行了之前的工作，搭建了环境之后，现在就要进入实际开发过程了。我想过程和2D也许存在着一些区别，但是还是相对比较依赖2D教程的，尤其像这一章和3D的确是别无二致，不过我这里还是按照步骤说一下。（参考：<a href="http://arthraim.cn/post/2009/06/62.html">《XNA教程-2D游戏-Chapter2-创建游戏工程》</a>）</p>

<p>使用GS3.1+VS2008是基于.NET Framework 3.5的，否则一些新特性将不会被用到，如果你的开发使用其他环境，那么也许会不一样。</p>

<p>具体涉及到一些可能和2D教程重复的东西，看过2D的直接跳过就好。</p>

<p><strong>第一步、Visual Studio简单介绍</strong></p>

<p>安装高于Visual Studio 2005 Express的版本，并且装好XNA Game Studio（2.0以上）。那么如果安装成功的话，在VS的新建对话框中应该可以看到这么几项（GS3.1+VS2008，不保证其他版本有一样的工程）</p>

<p><a href="/images/uploads/zb/2009-06-27_NewProject.jpg"><img src="/images/uploads/zb/2009-06-27_NewProject.jpg" alt="" /></a></p>

<blockquote><ul>
<li><p>Windows Game (3.1) &#8212;- XNA Game For Windows游戏的开发，很多游戏打着这个标志</p></li>
<li><p>Windows Game Library (3.1) &#8212;- Windows游戏类库</p></li>
<li><p>Xbox 360 Game (3.1) &#8212;- Xbox360游戏</p></li>
<li><p>Xbox 360 Game Library (3.1) &#8212;- Xbox360游戏类库</p></li>
<li><p>Zune Game (3.1) &#8212;- Zune游戏</p></li>
<li><p>Zune Game Library (3.1) &#8212;- Zune游戏类库</p></li>
<li><p>Content Pipeline Extension Library (3.1) &#8212;- Content管道扩展库</p></li>
<li><p>Platformer Starter Kit (3.1) &#8212;- 一个游戏示例（提供windows x360 zune三种版本都有）</p></li>
</ul>
</blockquote>

<p><strong>第二步、新建工程，获取资源</strong></p>

<p>根据刚才介绍的新建，建立相应的工程。</p>

<p>比如我新建一个Windows Game (3.1)工程，并且取名为TChapter2，那么我们可以得到一些IDE为我们创建的文件，具体情况如下。</p>

<blockquote><ul>
<li><p>Content &#8212;- 就是一切我们需要的游戏资源，在XNA中存在Content Pipeline这个概念，而这里的所有资源可以之后在Content管道中直接调用加载。</p></li>
<li><p>Game1.cs &#8212;- 游戏逻辑代码。</p></li>
<li><p>Game.ico &#8212;- 不用多说，一个Xbox360的手柄样式的ico图标。</p></li>
<li><p>GameThumbnail.png &#8212;- 正如他的名字，是一个缩略图，当然要你自己画的啦。</p></li>
<li><p>Program.cs &#8212;- 就是程序的入口Main方法了。</p></li>
</ul>
</blockquote>

<p><strong>第三步、下载资源</strong></p>

<p>接下去本章很重要的一部就是下载必须的游戏素材。这里提供官方链接，下载解压缩后就可以看到我们本教程的例子要用到的全部素材了。</p>

<p><a href="/images/uploads/zb/2009-06-27_files1.JPG"><img src="/images/uploads/zb/2009-06-27_files1.JPG" alt="" /></a> &#8230;/Audio/Waves/</p>

<p><a href="/images/uploads/zb/2009-06-27_files2.JPG"><img src="/images/uploads/zb/2009-06-27_files2.JPG" alt="" /></a> &#8230;/Models/</p>

<p>【点击下载官方素材】</p>

<p><a href="http://creators.xna.com/downloads/?id=157"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-27T10:08:42+08:00" pubdate data-updated="true">Jun 27<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch1-introduction/">
		
			XNA教程-3D游戏-01-3D游戏教程简介</a>
	</h2>
	<div class="entry-content">
		<p>在之前，我把所有的2D视频教程都用文字重新写了一遍，也完成了2D教程中完成的那个例子，应该说，如果是XNA变成从无到有的话，那收获已经颇为丰富了。并且，教程中所有的More Details（原视频教程的页面）我也都进行了翻译，一部分还加上了一些自己的说明。应该说，无论是机械的完成代码学会技能，还是了解一些XNA提供的实质性内容，都起到了很大的作用。</p>

<p>之后正好面临我的期末考试，一个学期也就这么几天读书的，总要成全我吧。所以加上复习和考试，暂停了那么几天博客的更新，也算是之前一星期之后的小小的休息吧。现在回家放暑假，休息了几天之后，我决定继续开始3D的教程了，利用之前在2D学到的东西，我们应该可以轻松的进入3D的学习了。</p>

<p>在3D的教程中，我们将完成一个2D教程中的demo中的3D版本。我们要完成一些类似的东西，也会接触一些新的东西。</p>

<ol>
<li><p>建立自己的3D环境 &#8212;- 毕竟是3D游戏了，所以不单单是像2D一样画一个背景就好了，我们需要建造自己的3D外太空环境。</p></li>
<li><p>添加加农炮 &#8212;- 同样内容相似的，我们需要一个可以旋转的加农炮，只是这次的旋转是在3D环境中了。</p></li>
<li><p>添加炮弹 &#8212;- 加农炮设计的炮弹，也将在3D环境中处理，当然其实也就是初速度稍许不同，接触到之后就会发觉到2D教程的作用了。</p></li>
<li><p>添加敌方UFO &#8212;- 还是类似的，UFO从屏幕的远端向近端飞来，而不是右侧飞到左侧了哦。</p></li>
<li><p>碰撞检测 &#8212;- 3D的碰撞检测。</p></li>
<li><p>添加声效 &#8212;- 之前2D的游戏是没有声音的，这一次的3D中我们将加入声音，者是新的内容，会十分有趣的。</p></li>
</ol>


<p>大致的内容就是这样。当然，如果你没有看2D的教程，直接开始3D的也是可以的，只是和2D对比的部分直接略去就可以了。另外，本教程使用XNA Game Studio 3.1开发，如果你是使用的是之前的版本，或者是未来的某个版本，那么其中也许会有一些不同之处。如果你刚刚开始，那么就赶快装上Game Studio开始吧。</p>

<p><strong>相关链接：</strong></p>

<ul>
<li><p><a href="http://arthraim.cn/post/2009/06/61.html">XNA教程-2D游戏-索引</a></p></li>
<li><p><a href="http://creators.xna.com/en-US/education/gettingstarted/bg3d/chapter1">XNA Creators Club 教程原址</a></p></li>
<li><p><a href="http://creators.xna.com/en-us/news/xnagamestudio3.1">XNA Game Studio 3.1 介绍及下载地址</a></p></li>
<li><p><a href="http://arthraim.cn/post/2009/06/60.html">环境配置及安装的简单介绍请看《XNA Game Studio 3.1 Available》</a></p></li>
</ul>


<p><strong>Demo效果图：</strong></p>

<p><a href="/images/uploads/zb/2009-06-27_Glance.jpg"><img src="/images/uploads/zb/2009-06-27_Glance.jpg" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-25T22:47:25+08:00" pubdate data-updated="true">Jun 25<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-index/">
		
			XNA教程-2D游戏-目录索引</a>
	</h2>
	<div class="entry-content">
		<p><a href="/images/uploads/zb/XNA_logo.jpg"><img src="/images/uploads/zb/XNA_logo.jpg" alt="" /></a></p>

<p><strong>2011-01-16更新：换了域名和URL，更新一下链接~</strong></p>

<p>XNA GameStudio 3.1，微软XNA Creators Club Online上2D游戏视频教程文字版索引。</p>

<p><strong>XNA游戏教程.2D</strong></p>

<ol>
<li><p><a href="/xna-tutorial-2d-ch1-introduction/">2D游戏教程简介</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch2-create-solution/">创建游戏工程</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch3-add-assets/">添加Asset</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch4-rending-backgrounds/">绘制背景</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch5-create-a-cannon/">添加一门加农炮</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch6-launch-missiles/">发射炮弹</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch7-create-enemy-ufo/">添加敌人UFO</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch8-destroy-ufo/">摧毁UFO</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch9-record-scores/">记录分数</a></p></li>
<li><p>其他扩展：<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/ExtraCredit">Extra Credit - Community Tutorials</a></p></li>
</ol>


<p><strong>相关知识点链接</strong>（在各个章节中涉及到的知识点，基本上都在文章的末尾）：</p>

<ol>
<li><p><a href="/xna-tutorial-2d-ch3-add-assets/">什么是Asset？</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch4-rending-backgrounds/">Content Pipeline是如何工作的？</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch4-rending-backgrounds/">Sprites，Sprites绘制，和SpriteBatch。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch5-create-a-cannon/">为什么要创建GameObject类？</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch5-create-a-cannon/">XNA Game Studio中表示的角。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch6-launch-missiles/">使用数组。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch6-launch-missiles/">转化一个旋转角度为速度向量。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch7-create-enemy-ufo/">随机数和线性插入方法Lerp。</a></p></li>
<li><p><a href="/xna-tutorial-2d-ch8-destroy-ufo/">使用Rectangle的2D碰撞检测。</a></p></li>
</ol>


<p><strong>原视频教程链接</strong>：<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/chapter1">这里</a></p>

<p><strong>系列3D教程目录索引</strong>：<a href="/xna-tutorial-3d-index/">这里</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-19T08:18:48+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch9-record-scores/">
		
			XNA教程-2D游戏-09-记录分数</a>
	</h2>
	<div class="entry-content">
		<p>游戏基本上已经什么都有了，不过接下去还有一些工作 &#8212;- 记分。通过击毁UFO来获得分数，这是一个简单的功能，不过还是什么必要的，因为我们不单单是记住分数，还要把它显示在屏幕上，所以如何在屏幕上显示字符才是关键所在。如果你愿意，可以显示一些其他信息，比如常见fps等等。</p>

<p>那么接下来，介绍方法。</p>

<p><strong>第一步、添加Font到Content中</strong></p>

<p><strong>一、添加SpriteFont的Content资源。</strong></p>

<p>要在Content pipline中添加SpriteFont（字体）的内容。</p>

<ol>
<li><p><strong>Content中添加一个Fonts文件夹</strong>。</p>

<p>   <img src="/images/uploads/zb/2009-06-19_AddFontToContent.jpg" alt="" /></p></li>
<li><p><strong>在Fonts中添加一个GameFont对象</strong>。</p>

<p>   [<img src="/images/uploads/zb/2009-06-19_AddSpriteFont.jpg" alt="" /></p>

<p>   ](/images/uploads/zb/2009-06-19_AddSpriteFont.jpg)</p></li>
<li><p><strong>修改XML文件</strong>。具体参照如下代码，字体和字体大小的修改。</p></li>
</ol>


<pre><code>&lt;FontName&gt;Arial&lt;/FontName&gt;
&lt;Size&gt;18&lt;/Size&gt;
</code></pre>

<p>好了，这样准备工作就完成了，我们可以在之后的Content的相关操作中使用这个font了。</p>

<p><strong>二、声明一些新变量</strong></p>

<p>声明一个int型的分数。</p>

<p>声明一个SpriteFont对象当作字体。</p>

<p>声明一个Vector2来记录分数显示的位置（百分比）。</p>

<pre><code>int score;
SpriteFont font;
Vector2 scoreDrawPoint = new Vector2(0.1f, 0.1f);
</code></pre>

<p>就像之前说的，微软的大大们都有强大逻辑，可以在开始写程序的时候声明出所有的变量。</p>

<p><strong>三、Content载入字体</strong></p>

<p>在LoadContent方法中载入我们感概添加和修改的字体。</p>

<pre><code>font = Content.Load&lt;SpriteFont&gt;(@"FontsGameFont");
</code></pre>

<p>这样，我们就可以自由的使用了。</p>

<hr />

<p><strong>第二步、添加记分逻辑</strong></p>

<p>视频中的逻辑是击毁一个UFO加一分，所以在判断碰撞的地方加上score++就好。</p>

<p>我设计的逻辑击毁加2分，漏掉一个（飞出屏幕）扣一分。</p>

<p>当然你可以设计更加复杂的功能，比如距离远速度快的3分等等，总之分数不是关键。</p>

<hr />

<p><strong>第三步、绘制分数</strong></p>

<p>绘制我们记分的结果，在Draw这个方法的SpriteBatch.End()之前加入绘制字符串的代码。</p>

<pre><code>spriteBatch.DrawString(
    font,
    "Score:" + score.ToString(),
    new Vector2(
        scoreDrawPoint.X * viewportRect.Width,
        scoreDrawPoint.Y * viewportRect.Height),
    Color.White);
</code></pre>

<p>看一下参数。</p>

<ol>
<li><p>SpriteFont，要求传入一个SpriteFont，我们这里传入了之前创建的font。</p></li>
<li><p>string，传入要显示的字符串，这里是得分。</p></li>
<li><p>Vector2，传入一个显示位置（左上角）的Vector2，这里我们利用之前创建的百分比和屏幕大小计算出一个新的Vector2</p></li>
<li><p>Color，传入一个字形的颜色。</p></li>
</ol>


<p>好了，这样我们的游戏就完整的完成了。放一张运行时的截图。</p>

<p><a href="/images/uploads/zb/2009-06-19_Chapter9_Runtime.jpg"><img src="/images/uploads/zb/2009-06-19_Chapter9_Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=156"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-19T08:03:20+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch8-destroy-ufo/">
		
			XNA教程-2D游戏-08-摧毁UFO</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 08 &#8211; 摧毁UFO</strong></p>

<p>这一次要做的是很NB的事情，碰撞检测（Collision Detection），具体到我们的例子，具象一点的，那么就是摧毁UFO，当然在无数游戏中，碰撞检测都是至关重要的东西，和随机比起来不相上下吧。无论是什么游戏类型，物体和物体之间的接触都是要处理的，尚且不说加上什么物理特性，光是这个例子里的子弹碰UFO总要有点反应吧。更不用说什么火星撞地球了………………</p>

<p>具体代码很简单，找到UpdateCannonBalls方法，在更新的时候，添加一种杀掉UFO和炮弹的情况，就是两者碰撞的时候。</p>

<p>大致的思路为：</p>

<ol>
<li><p>确定每个炮弹的范围大小和UFO的范围大小。</p></li>
<li><p>遍历每个炮弹。</p></li>
<li><p>遍历中每个炮弹再要遍历每个UFO。如果发生碰撞就同时摧毁两个（alive = false）</p></li>
</ol>


<p>这里我们要用到的碰撞检测，直接使用XNA的Rectangle的intersect方法。以下是代码，添加在判断是否出屏幕的下面。</p>

<pre><code>Rectangle cannonBallRect = new Rectangle(
    (int)ball.position.X,
    (int)ball.position.Y,
    ball.sprite.Width,
    ball.sprite.Height);
foreach(GameObject enemy in enemies)
{
    Rectangle enemyRect = new Rectangle(
        (int)enemy.position.X,
        (int)enemy.position.Y,
    enemy.sprite.Width,
    enemy.sprite.Height);
    if(cannonBallRect.Intersects(enemyRect))
    {
        ball.alive = false;
        enemy.alive = false;
        break;
    }
}
</code></pre>

<p>首先获得当前遍历到的cannonBall的范围，循环。循环中得到当前UFO的范围，检测是否和cannonBall相交（哪一方都一样）。碰撞了，就两个对象的alive都为false，然后break出UFO的循环。</p>

<p>执行结果（其实截图看不出来效果唉）</p>

<p><a href="/images/uploads/zb/2009-06-18_Chapter8Runtime.jpg"><img src="/images/uploads/zb/2009-06-18_Chapter8Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=155"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>翻译：使用Rectangle的2D碰撞检测</strong></p>

<p>（以下文字由本博客翻译自这里，转载请注明出处）</p>

<blockquote><p>图片创建的Sprite从一创建就必然是一个长方形。你可以使用遮盖(Mask)，来绘制Sprite中的一部分像素，这样就产生了Sprite不是一个长方形的视觉效果。Sprite可能呈现为一个圆形的物体，或者更加复杂的形状。但是所有的sprite一创建就都是矩形的。</p>

<p>Sprite的这一特性在非常基本的碰撞检测中很实用，XNA Framework提供了一个Rectangle类，自己就拥有碰撞帮助的方法：ectangle.Intersects，和Rectangle.Contains。</p>

<p>在基本的常识中，碰撞检测是基于相交检测的 &#8212;- 两块几何图形是否相交。如果两个几何图形相交，他们可以说是碰撞，游戏逻辑可以根据碰撞的物体产生适当的反应。</p>

<p>在我们的2D游戏中，我们关心加农炮是不是和地方UFO相交。如果加农炮的sprite的rectangle相交于敌人sprite的rectangle，那我们的游戏逻辑检测到了一个碰撞，并且同时摧毁两个物体。</p>

<p>Rectangle很容易创建。Rectangle类初始化时需要4个参数 &#8212;- 矩形左上角的点的X和Y坐标，以及矩形的宽度和高度。所有矩形的其他点都会有这些信息计算出来。</p>

<p>创建sprite占用的rectangle之间的碰撞，设置X和Y的值为游戏世界中的sprite的X和Y值，GameObject.position.X和GameObject.position.Y。设置宽度和高度为sprite中的Texture2D的宽度和高度，GameObject.sprite.Width和GameObject.sprite.Height。</p>

<p>凭借两种游戏直接中sprite的rectangle对象的创建和调用Rectangle.Intersects方法，你可以知道两个物体是否碰撞。这可能不是最精确的碰撞。包括还有其他的缺点，如果是屏幕上已经画了的一个旋转过的sprite，rectangle对象的定义就不再符合sprite在屏幕上绘制的样子了。然而这是一个简单高效的方法来做碰撞检测。</p>

<p>一个类似的有用的方法是Rectangle.Contains。在我们的2D游戏中，使用一个rectangle来表示整个屏幕，我们可以定义什么时候GameObject离开了屏幕的边界。我们在比较屏幕rectangle和对象rectangle的时候，使用检查Rectangle.Contains的值是否为false的方法来判断是否离开屏幕。</p>

<p>下面的图表列出了Rectangle.Intersects和Rectangle.Contains两个不同的矩形成员的不同输出情况。</p>

<p><img src="/images/uploads/zb/BG_3.8.1.1pd_a.png" alt="" /></p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-19T06:13:16+08:00" pubdate data-updated="true">Jun 19<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch7-create-enemy-ufo/">
		
			XNA教程-2D游戏-07-添加敌人UFO</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 07 &#8211; 添加敌人UFO</strong></p>

<p>这次要做的就是添加敌人 &#8212;- UFO。我们有了一个防空武器，在一个可恶的看上去非常阴沉的外星球，那我们必须要有人来入侵，这才是建造军用设施的真正目的对吧。所以，程序员真是堪比创世纪的众神了。</p>

<p>加入UFO的方法其实和子弹差不多（记住这句话，因为我后面实在是懒得讲了），它需要它的初速度向量，需要被杀掉，最后需要画在屏幕上，如果稍微改一下，我们完全可以不看教程做到了。添加UFO还涉及到了一个新的概念，就是随机数，游戏中随机是非常重要的东西，几乎没有一个游戏不用到随机概念的，前段时间刚刚过了25岁生日的俄罗斯方块也是。随机，是游戏的灵魂，而我们将用到Random来产生随机数，再使用XNA提供的方法限定我们需要的范围。OK，开始吧。</p>

<p><strong>第一步、创建UFO</strong></p>

<p>我们要声明很多的变量，可能一时半会儿不会知道有什么用。一样的，找到你声明了其他东西的地方，加农炮啦，炮弹啦，手柄和键盘的状态啦之类的，Game类的首部，添加以下代码，代码如下：</p>

<pre><code>const int maxEnemies = 3;
const float maxEnemyHeight = 0.1f;
const float minEnemyHeight = 0.5f;
const float maxEnemyVelocity = 5.0f;
const float minEnemyVelocity = 1.0f;
Random random = new Random();
GameObject[] enemies;
</code></pre>

<p>似乎有很多不明所以的东西，来看看他们都是些什么。</p>

<ol>
<li><p>最大的敌人数，3个，好吧，我一定改了你。</p></li>
<li><p>最大敌人高度，0.1f，似乎可以想到。</p></li>
<li><p>最小敌人高度，0.5f，对啊，正如之前说到的，坐标系的Y轴是越上方越小。</p></li>
<li><p>最大敌人速率，5.0f，恩，敌人的速率是可变的，不错。</p></li>
<li><p>最小敌人速率，1.0f，最小的速度。</p></li>
<li><p>随机对象，一个Random对象，看来是创建随机数用的。</p></li>
<li><p>敌人数组，一个敌人的数组，和子弹一样，只是名字不同而已吧。</p></li>
</ol>


<p>这就是我们第一步完成的事情，之前说过，微软工程师都是强大的存在，可以预见未来，他们可以在刚刚开始写代码的时候就声明好所有将来需要使用的变量。当然，这是个笑话。</p>

<p>之后要初始化这些对象，载入enemy.tga资源。找到LoadContent的位置，在初始化cannonballs的循环下面添加一个for循环。记得之前怎么做的吗？如法炮制。</p>

<pre><code>enemies = new GameObject[maxEnemies];
for (int i = 0; i &lt; maxEnemies; i++)
{
    enemies[i] = new GameObject(
    Content.Load&lt;Texture2D&gt;(@"Spriteenemy"));
}
</code></pre>

<p>不麻烦吧，只是吧cannnonballs的名字换一下就是这里的代码了。继续。</p>

<hr />

<p><strong>第二步、更新UFO位置并杀掉屏幕以外的</strong></p>

<p>第二步做的是更新他们的位置，因为也是GameObject类，所以方法和cannonball一模一样。在Update方法中找到UpdateCannonBalls();这一行，在下面加入：</p>

<pre><code>UpdateEnemies();
</code></pre>

<p>说然后在类的其他任何地方加上我们的UpdateEnemies方法。</p>

<pre><code>public void UpdateEnemies()
{
    foreach (GameObject enemy in enemies)
    {
        if (enemy.alive)
        {
            enemy.position += enemy.velocity;
            if(!viewportRect.Contains(new Point(
                (int)enemy.position.X,
                (int)enemy.position.Y)))
            {
                enemy.alive = false;
                continue;
            }
        }
    }
}
</code></pre>

<p>真的，和CannonBalls一模一样，改一下名称，采用一样的杀掉的方法，这就是UFO移动，位置更新的代码了，目前为止没什么新的东西。</p>

<hr />

<p><strong>第三步、新生UFO</strong></p>

<p>和cannonballs不同，在做cannonballs的工作的时候，先让它射击出来，也就是在按键的一刻，之后在离开屏幕的一刻把它杀掉。而enemies在被处理的时候，是先在他离开屏幕的时候杀掉，可是它从没出现过。所以这一步，我们要让他出现。</p>

<p>要新生一个enemy的GameObject我们要给他一些属性，包括alive要变成true，这是肯定的。然后要给他一个初始的position，一个velocity速度向量，velocity包括了方向，和速率。（所以我始终觉得speed更好）。</p>

<p>然后就是决定，什么时候创建它。它在离开屏幕的时候会死去，那么我们就在它死去之后马上把它救活，所以我们找到上一步的UpdateEnemies方法，在if(enemy.alive){}的后面，加上enemy.alive == false的代码，让它死掉马上活过来，并出现在屏幕的右方。</p>

<pre><code>if (enemy.alive)
{
    // ...其他代码
}
else
{
    enemy.alive = true;
    enemy.position = new Vector2(
    viewportRect.Right,
    MathHelper.Lerp(
        (float)viewportRect.Height * minEnemyHeight,
        (float)viewportRect.Height * maxEnemyHeight,
        (float)random.NextDouble()));
    enemy.velocity = new Vector2(
    MathHelper.Lerp(
        -minEnemyVelocity,
        -maxEnemyVelocity,
        (float)random.NextDouble()),
        0);
}
</code></pre>

<p>看看我们做了什么。</p>

<p>enemy.alive = true; 没错，这是出生证明，起码在某些程度上说明了它活过来了。</p>

<p>enemy.position = new Vector2(); 这当然是给他位置向量，初始化向量要X坐标Y坐标，那X坐标就是屏幕右侧，X轴最大值，viewportRect记录了屏幕大小，调用viewportRect的Right属性，就是我们要的屏幕宽度，也就是X轴最大值。而Y坐标，我们要随机产生一个高度，这样才有游戏的味道。首先，我们用random.NextDouble随机生成一个0到1之间的double类型的随机数，这就是我们得到随机数的方法。但是，它不是我们要的数字，我们需要一个高度差之间的，而不是0到1的。于是这里要讲一下MathHelper.Lerp方法，它需要3个参数，随机数的最小值，随机数的最大值，和随机数。我们使用这个方法，把我们随机产生的那个书限定到我们给的新范围里。其实做法很简单，相信大家都可以写出来，(最大值-最小值)×随机值+最小值，这得到了我们的这个数，不过XNA帮你省去了这些代码（真是细致的过分了 = =），直接帮助得到我们的数。</p>

<p>enemy.velocity = new Vector2()，一样的，也是产生一个新的向量。因为要他笔直的从右往左穿过屏幕，那Y方向没有速度，Y给个0就好了。X则是要随机在我们定下的范围里得到一个数字，方法和position的类似，只是要注意的是，因为我们逆X轴正方向飞行，所以X轴速度是负数。</p>

<p>至此，完成了UFO的全部的Update工作。</p>

<hr />

<p><strong>第四步、绘制UFO</strong></p>

<p>嘿嘿，一样，最后我要画UFO。找到Draw方法，加入一个新的SpriteBatch.draw就可以了。因为UFO不会和加农炮碰撞，所以无论放在背景以上的什么层面都好，只是我觉得起码应该遮掉子弹吧～于是添加代码，又是和cannnonballs一样。</p>

<pre><code>foreach (GameObject enemy in enemies)
{
    if (enemy.alive)
    {
        spriteBatch.Draw(
        enemy.sprite,
        enemy.position,
        Color.White);
    }
}
</code></pre>

<p>We&#8217;re done here. 运行一下看看效果。（我修改了同屏敌人数，因为我的子弹改成是10 = = 并且我发现我的子弹是可以打成一张网的，这游戏没意思了）</p>

<p><a href="/images/uploads/zb/2009-06-16_Chapter7Runtime.jpg"><img src="/images/uploads/zb/2009-06-16_Chapter7Runtime.jpg" alt="" /></a></p>

<p>画面不错。OK，下一次就是要真的用子弹杀掉敌人了～</p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=154"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>第三步的补充内容翻译。</strong></p>

<p>这段文字详细讲解了Lerp方法的成因，作用，实现方式，用法，好处等等，可以说非常的详细。</p>

<p>但我个人其实非常不理解，首先我非常不理解为什么（最大值-最小值）×随机值+最小值 这样一个计算就可以完成的事情一定要封装到framework里，虽然那个类的名字叫MaxHelper。另外不理解的地方就是为啥还要用这么多的文字来说明，看了就知道，它用了很多文字来说为什么0到1之间的数可以转化为一个范围内的数，还打了从一个数轴映射到另一个数轴的例子。</p>

<p>只是觉得很有意思而已，美国人做事情有些德国人的味道。看文字吧。</p>

<blockquote><p><strong>随机数和线性插入</strong></p>

<p>在游戏中，随机事件会添加更多的曲折。从随机出现在随机位置的玩家或敌人，到一定几率出现的奖励道具，随机事件可以保持一个游戏的挑战性和乐趣。</p>

<p>怎么才能让你使用一个随机数字来创建随机事件呢？</p>

<p>Microsoft® Visual C# 2005 Express Edition和Visual Studio 2005的包含的标准库中提供了一个实用的类&#8212;-System.Random类。它可以被实例化，也可以生成特定最大范围内的随机整数，或随机生成0到1之间的双精度小数。</p>

<p>乍看之下，产生一个随机证书似乎更管用。在某些情况下，它很管用。举个例子，随机访问你的数组索引，你需要一个整数。但是2D游戏中的数是浮点数，这意味着，他们拥有小数部分。我们需要一些不是严格的整数的数值。打个比方，5到10之间产生一个随机速率。如果我们只是用5到10之间的整数，只有6中可能的数值，这使得速率间的差异性看上去不是那么随机。</p>

<p>一个双精度浮点数之给我们更多范围内数据的变化，使可以转化为更多各种各样的表现。这非常美妙，特别是当我们屏幕上有很多对象拥有不同的位置和速度的时候。</p>

<p>然而，我们的Random类只返回0到1之间的双精度浮点值，或称为double类型的值，却对我们要随机获得5到10之间的数字不怎么实用。你当然可以做一些必要的乘法和加法来让0到1之间的数适应5到10之间这个范围，但是XNA Framework提供了更加简单的方法 &#8212;- MathHelper.Lerp。</p>

<p>Lerp是linear interpolation（线性插入）的缩写，一个数学方法，提供它一些0到1之间的数值T，并提供给它最大值和最小值，它可以计算出一个最大值和最小值之间的输出T。</p>

<p><img src="/images/uploads/zb/BG_3.7.3.1pd.png" alt="" /></p>

<p>把它想象成是在一个最小值和最大值之间的数轴上决定位置，而T是从开始的0到1之间的一条数轴上的某个位置。如果T是0.75，它应该在数轴范围的3/4的位置，在5到10的数轴上就是8.75。照着这个方法，一个0到1之间的数值可以用来在两个浮点数之间找到一个对应的浮点数。</p>

<p>Lerp方法可以用在游戏中需要以恒定速率增加或减少的任何东西。速率、动画、淡出效果或变换颜色 &#8212;- 简简单单传入一个0到1之间的数值T，一个最小值，一个最大值，Lerp会完成之后的所有事情。</p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-16T19:24:54+08:00" pubdate data-updated="true">Jun 16<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-2d-ch6-launch-missiles/">
		
			XNA教程-2D游戏-06-发射炮弹</a>
	</h2>
	<div class="entry-content">
		<p><strong>XNA教程 &#8211; 2D游戏 &#8211; 06 &#8211; 发射炮弹</strong></p>

<p>之前已经完成了很多的工作，创建了GameObject类，实例化了加农炮，并且在屏幕上画出了背景和加农炮。而且加农炮已经拥有了Update的代码，即玩家可以控制这个加农炮了。只是，距离我们的要求，这还远远不够，我们的子弹在哪里呢？加农炮打出来的炮弹呢？没错这就是这一次要完成的。我们要创建能被你发射，并且按方向穿过屏幕的炮弹了。</p>

<p>这一次的工作可谓相对有些复杂了，无论是代码量，还是概念，还是数学知识的要求都有了一定的提升。不过不用慌，我们还是跟着视频一点一点的做下来，最终我们一定能理解只是，并且做好这个东西的。OK，直接进入正题。</p>

<hr />

<p><strong>第一步、修改GameObject</strong></p>

<p>之前说过了GameObject的作用，是用来实例化不同的游戏对象的，那么他的模型应该够健壮，能够实例化各种各样的现实对象。按照我个人的习惯，当然是一个对象一个类，不过既然视频是这么处理，还是跟着做。这里我们要做的很简单，找出之前的GameObject类，我们要添加两个成员变量。</p>

<p>速率：这个速率是指炮弹具有的速度，拥有了这个速度，我们才能慢慢的把它平滑的在画面上移动。不理解没关系，先看下去。</p>

<p>生存：是否生存，我的炮弹如果出了屏幕，那么它就已经消失了，或者说死了，所以这里有个boolean类型的值记录生存或死亡。</p>

<p>当然，这个类也会生成cannon，所以这里可以看一下，加农炮的速率是什么？速率是位移 / 时间，我们的加农炮只有旋转没有位移，很好就是0。再看生存，死亡，它应该一直存在，所以一直是true就好。那么接下来看代码。</p>

<p>先声明。</p>

<pre><code>public Vector2 velocity;
public bool alive;
</code></pre>

<p>然后在构造方法里初始化。</p>

<pre><code>velocity = Vector2.Zero;
alive = false;
</code></pre>

<p>好了，这就是我们要在第一步里完成的全部工作，不用疑惑，接下去做，就知道会发生什么了。</p>

<hr />

<p><strong>第二步、创建Cannonball数组</strong></p>

<p>这里我们要完成的工作是建立一个数组，放上所有可能被发射的炮弹的GameObject，然后把它们初始化。</p>

<p>首先找到Game1.cs，你创建背景和Cannon的地方，在那些代码下面声明两个新的东西。</p>

<pre><code>const int maxCannonBalls = 3;
GameObject[] cannonBalls;
</code></pre>

<p>解释一下，第一个带有const修饰符的是一个常量，maxCannonBalls。意思很明白，就是屏幕上最多出现的子弹数，因为子弹过多会使得update拖慢，那么能进行的draw就很少，所以一上来我们定义成3比较安全。如果过多，可以想见，会出现一帧一帧很卡的效果，像幻灯片一样。而如果加入了一些安全机制，那么就变成了跳帧现象，就是不再计算和绘制。之后一个GameObject[]的数组，就是放无数GameObject用的，至于放多少，是看初始化的。好吧，下面看初始化代码。</p>

<p>找到LoadContent方法，在cannon的相关后面加上以下代码。</p>

<pre><code>cannonBalls = new GameObject[maxCannonBalls];
for (int i = 0; i &lt; maxCannonBalls; i++)
{
    cannonBalls[i] = new GameObject(Content.Load&lt;Texture2D&gt;(
        @"Spritescannonball"));
}
</code></pre>

<p>如果你熟悉C#的话看懂这个没问题，无非就是循环一下，初始化一下。其实用List&lt;>的效率肯定要高一下。但是这里是不可以使用foreach的，因为foreach肯定要求所有的对象都已经实例化了，而我们的工作就是在实例化这些对象。恩，其实这一步已经完成了，这些代码和载入其他Content都是类似的，只是这里遍历了3次而已。下一步吧！</p>

<hr />

<p><strong>第三步、更新cannonball的位置</strong></p>

<p>这一步要更新cannonBalls的每一个ball的位置，当然这里就要用到我们的速度了。只要每一次更新的时候，都加上速率值（一个向量，叫速度更合适，速度是有方向的速率没有），那么它就会自动更新到新的位置了，如果在这个时候把它画出来，就可以看到它在一帧一帧的变换中变换着自己的位置，平滑的移动了一条直线（或其他轨迹，取决于速率或者更像是速度的这个值）。我们把要更新的代码分出一个方法来，叫做UpdateCannonBalls()，如果你坚持，也可以把它们写在Update的方法里，谁都没有强制你。看代码：</p>

<pre><code>protected override void Update(GameTime gameTime)
{
    //...Other code
    UpdateCannonBalls();
    base.Update(gameTime); //必须在这一行代码之前
}
public void UpdateCannonBalls()
{
    foreach (GameObject ball in cannonBalls)
    {
        if (ball.alive)
        {
             ball.position += ball.velocity;
        }
    }
}
</code></pre>

<p>上面是Update方法里的修改，其他代码不去管它，在base.Update(gameTime);之前加上就好。至于下面的方法，就是更新了，放在Game1类中的任何位置都是没有关系的，只要是别的方法的外面，Game类的里面。这里采用了foreach的方法，每一次做一个校验，如果还alive，活着，那么就给他的位置加上速度向量。没错就是这个逻辑。这一步就是这样子。</p>

<hr />

<p><strong>第四步、发射cannonBall</strong></p>

<p>这一步要完成的工作就是发射炮弹了，要知道我们的初始向量才是关键。当然，要知道按键的那一刻，才能确定初始向量。那么首先要做的就是确定按键的相关操作。这里我们需要先声明两个变量。</p>

<pre><code>protected override void Update(GameTime gameTime)
GamePadState previousGamePadState = GamePad.GetState(PlayerIndex.One);
KeyboardState previousKeyboardState = Keyboard.GetState();
</code></pre>

<p>它们会被用来记录上一次Update时候的按键状态，这是为什么呢？看下面的代码。它们中，第一个if语句被添加在Update方法中，你之前完成的cannon.rotation += gamePadState.ThumbSticks.Left.X * 0.1f;这一行的后面。而第二个if语句，放在#if !XBOX和#endif之间的区域内，#endif的上方就可以。当然其实顺序并不是那么重要。</p>

<pre><code>protected override void Update(GameTime gameTime)
if (gamePadState.Buttons.A == ButtonState.Pressed &amp;&amp;
    previousGamePadState.Buttons.A == ButtonState.Released)
{
    FireCannonBall();
}
if (keyboardState.IsKeyDown(Keys.Space) &amp;&amp;
    previousKeyboardState.IsKeyUp(Keys.Space))
{
    FireCannonBall();
}
</code></pre>

<p>解释一下，第一个if是用来检查是否按下X360的手柄上的A键。上一次没有按键，而这一次按键的情况下，即刚刚按键的一刹那，我们实施FireCannonBall()这个方法。而连续按住则不会连续的出发这个方法。另外一个if则是键盘的操作，一样的，只有按下键盘上空格键的那一刹那才会触发。这是操作，究竟触发了，调用了FireCannonBall这个方法要做什么，来看它的实现。</p>

<pre><code>public void FireCannonBall()
{
    foreach (GameObject ball in cannonBalls)
    {
        if (!ball.alive)
        {
            ball.alive = true;
            ball.position = cannon.position - ball.center;
            ball.velocity = new Vector2(
                (float)Math.Cos(cannon.rotation),
                (float)Math.Sin(cannon.rotation)) * 5.0f;
            return;
        }
    }
}
</code></pre>

<p>来分析下代码，首先，我们遍历三个ball，因为最多只有3个，所以用这样的方法就好了（否则应该加上索引什么的，这里不讨论算法），看哪个球还活着，哪个球死了，只有死了的炮弹，我们才能让他再一次活过来，否则就要等到它死掉为止。那么显然，if(!ball.alive)校验后，留下来的就是可以活过来的炮弹，于是我们让他活过来。</p>

<ol>
<li><p>首先设置它的alive属性为ture，证明它活过来了。</p></li>
<li><p>然后设置初始化的位置，是加农炮的位置减去炮弹的中心向量。（这个也许视频里直接ball.position = cannon.position了，那样子会错位）</p></li>
<li><p>然后要设置它的速度了，方向就是当前加农炮的角度，Cos(A)和Sin(A)计算出单位1的向量确定方向，然后乘上5倍使它得到速率。这样一个速度就初始化完成了，这样每一个炮弹会沿着加农炮发射的方向前进而不管你后面的，前面的炮弹如何。至于数学计算，后面会翻译相关资料说明。但其实很容易理解，画个半径为1的圆，然后连成一个三角形，用Sin,Cos就很容易理解了。数学知识。</p></li>
</ol>


<p>还有一个重要的步骤，就是我们还需要让每一次Update后，把当前的键盘（或手柄）状态存入为上一次的键盘（或手柄）状态。代码只有两行。那个标记就不用再多做什么解释了吧，键盘的操作都包含在这个标记里，只是这次我们要重新写一个而已。把这个代码紧贴着base.Update(gameTime);的上方就可以了。</p>

<pre><code>previousGamePadState = gamePadState;
#if !XBOX
previousKeyboardState = keyboardState;
#endif
</code></pre>

<p>这样，我们炮弹的发射就做完了，每一次按键，就会把已经死掉的炮弹重新发射出来，否则就不发射。很容易理解～下一步还没有画，我们要把发出去的杀掉，否则不是我们整个游戏从头到尾只能发射三次吗？</p>

<hr />

<p><strong>第五步、杀掉cannonball</strong></p>

<p>就像刚才说的，游戏从头至尾只能发3个炮弹就太可怕了，它们按照牛顿惯性定律按照初速度朝着遥远的宇宙和未来飞去了。所以，我们要在它们飞出屏幕看不见的那一刹那，就把它们杀掉，资源回收～ 当然杀掉的策略可以有很多，比如碰撞了什么东西（比如将来的UFO），比如限定一定的时间，比如我们使用的飞出屏幕。因为飞出屏幕最符合逻辑，且只需要我们已经定义的这些信息就可以实现，所以采用这个策略。</p>

<p>在UpdateCannonBalls这个方法里，找到ball.position += ball.velocity;这一行，在其后面加上如下代码：</p>

<pre><code>if(!viewportRect.Contains(new Point(
    (int)ball.position.X,
    (int)ball.position.Y)))
{
    ball.alive = false;
    continue;
}
</code></pre>

<p>翻译成中文就是：如果ball所在的位置，转换成一个点，且这个点没有包含在代表了整个屏幕大小的矩形viewportRect当中，那么就把alive改成false，换言之杀掉它。杀掉后继续循环，生怕还有别的一起死掉而漏掉了。</p>

<p>很清晰很明白，就这么简单的三行代码，我们把飞出屏幕的炮弹杀掉了。OK，接下去最激动人心的时刻就要到了。话说微软的教程还真奇怪，一般自己写游戏都会是加一点逻辑，画一点逻辑的吧，他这个逻辑也太强了，全部想明白了再画，多辛苦啊。当然人家肯定是现成有了代码才这么干的吧。</p>

<hr />

<p><strong>第六步、画出cannonball</strong></p>

<p>要画出这写炮弹，当然就是跑到Draw方法里面去了，有了之前的经验，我们应该很容易画。只是要注意的是画完背景先画炮弹，再画炮，这样感觉炮弹是从炮筒里出来的，不然很傻哦。</p>

<pre><code>foreach (GameObject ball in cannonBalls)
{
    if (ball.alive)
    {
        spriteBatch.Draw(
        ball.sprite,
        ball.position,
        Color.White);
    }
}
</code></pre>

<p>OK这就是绘制的代码，现在编译运行一下看看效果吧。（在我运行之后感到非常不满足，于是我把子弹数字稍微的改了一下，截图如下，嘿嘿～）</p>

<p><a href="/images/uploads/zb/2009-06-15_Chapter6Runtime.jpg"><img src="/images/uploads/zb/2009-06-15_Chapter6Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=153"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>翻译一、使用数组</strong></p>

<p>这是属于第二步的信息，教你使用数组，属于C#语法范围，其实没有什么特别的意义。权且翻译在这里。（以下翻译由本人翻译自<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/details/6_2">这里</a>，未经允许请勿转载，转载请注明译者及翻译出处）</p>

<blockquote><p>教程到目前为止，你已经能熟练的使用一些预定义的类，并且为了能封装一些有规律的使用的数据，能创建一些自己的类了。</p>

<p>但是还有另外一种数据组织形式你需要知道并且学会使用。你也许需要使用大量相似的对象或足够相似的对象，事实上，它们都是同一类型的类。它们可能是GameObject，Texture2D对象，也可能是其他对象。你需要一些这样的对象，并且希望有一个相似的操作方式来操作它们。</p>

<p>例如，如果你有一组要绘制到屏幕上的GameObject对象，并且他们中的每一个都有自己的位置和Texture2D，你为他们每一个写的代码都会是完全相同。虽然目前是这样，但是你还是会要写一些一样的代码来处理每个 GameObject，使你的代码变得混乱。有什么办法只需简单的让对象的集合运行一样的代码，并且可以让每一个都拥有同样方式的互动呢？</p>

<p>有 &#8212;- 解决方案就在于数组。一个数组是一个相似对象的线性集合。你可以拥有一个人和类型的数组；一个Vector数组，一个GameObject数组，一个字符串数组，或者其他任何可能并且合法的数组。</p>

<p><img src="/images/uploads/zb/BG_3.6.2.1pd.png" alt="" /></p>

<p>这张图显示了创建有3个GameObject元素的数组的代码顺序。你使用表明数组元素类型的类型名之后加上[]来声明一个数组。之后你使用new和[x]来初始化数组，x是你数组元素的数量。</p>

<p>如果数组中的数据类型为一个类，你必须循环遍历这个数组并且初始化每一个数组元素存储的对象。</p>

<p>一旦完成这些工作，你可以使用数组名加上[x]的方式访问数组中的每个元素，x代表了你要访问的元素，0开始代表第一个元素。因为这个指数的开始是0，调用cannonBalls[1].position会给你数组中第二个GameObject对象的position变量。</p>

<p>一个更加强大的方式来访问数组是循环，在上面的图中已经表现出来。一个for循环允许你针对所有数组中的元素运行相同的代码。你也可以使用一个foreach循环，它将被在后面的步骤中表现出来。两种方法都允许你让多个同类元素运行相同的代码。这也帮助你对已写代码的重用，而不用写更多的代码，即便数组的大小在今后得到扩展。</p></blockquote>

<p><strong>翻译二、转换一个旋转角度为速度向量。</strong></p>

<p>这是属于第四步的信息，属于数学知识，可以帮助不懂这个数学原理的朋友理解那部分代码，翻译在这里。（以下翻译由本人翻译自<a href="http://creators.xna.com/en-US/education/gettingstarted/bg2d/details/6_4">这里</a>，未经允许请勿转载，转载请注明译者及翻译出处）</p>

<blockquote><p>学会这个教程的重点，你已经学会了采用弧度来传递旋转角度。然而，发射炮弹的动作需要我们使用Vector2来传递cannonball的动作。</p>

<p>Cannonball的动作应当和加农炮的角度有联系 &#8212;- 当你的加农炮转到垂直向上，你的炮弹应该垂直向上飞。同样的，当你的加农炮转到平行于地面的位置，炮弹应该平行于地面飞行。</p>

<p>来做出确定这个数据的唯一方法就是通过加农炮旋转角度的弧度。显然，你必须做一些转换工作，把旋转角度转换为给予炮弹的向量。</p>

<p><img src="/images/uploads/zb/BG_3.6.4.1pd.png" alt="" /></p>

<p>一个Vector2有两个组成部分：X坐标和Y坐标。在这个2D游戏的最终目标中，炮弹的X坐标在横轴上有怎样的动作，炮弹的Y坐标在纵轴上也有怎么样的动作。</p>

<p>在三角中，有个灯饰我们可以用来从一个角构造成一个vector。在如图所示的单位圆中，任何一个向量V可以被想象为拥有特定的从0开始的角θ。这个角度相当于我们想法中的旋转角度。为了得到向量V，也就是炮弹的速度向量，我们尝试着去发现，你可以使用下面的规则从θ中得到X和Y.</p>

<p>V = (cos(θ), sin(θ))</p>

<p>这些数学方程式,sine和cosine,代表任何一个有θ大小的角的X和Y的数据。为了构造一个2D向量,你只需要知道X和Y.所以sine和cosine方程就是我们想要的.向量的X坐标是cos(θ)，而向量的Y坐标是sin(θ)。</p>

<p>一个向量的方向使用Y和X坐标的关系来表现。（成为斜度）但是向量也具有幅度。从我们的炮弹上说，它决定了多快的速度来接近向量所指向的方向。在我们的代码中，我们使用一个常数去乘向量的方式来增长这个幅度。它同时使用相同的值去乘了X和Y坐标，确保斜度不变，但向量变得更长了 &#8212;- 这样，炮弹移动加快了。</p></blockquote>

<p>That&#8217;s all, finished~ Good luck ;)</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-06-15T19:23:44+08:00" pubdate data-updated="true">Jun 15<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>

<nav id="pagenavi">
    
        <a href="/blog/page/14/" class="prev">Prev</a>
    
    
        <a href="/blog/page/16/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2012

    Arthur Wang

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'artorius';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>