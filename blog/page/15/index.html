
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Artoirus</title>
	<meta name="author" content="Arthur Wang">

	
	<meta name="description" content="Google总是不小心冒出很多彩蛋，比如躲在doogle里的塞尔达的LOGO之类的。不过这次这个还真是很有意思。 我们知道一般来说我搜索gogle，那么他会提醒你说是不是google。 但是现在的情况呢？相信很多Google fans的人都看到过了吧，就是如果你搜索recursion这个词， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Artoirus" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>

<body>
	<header id="header" class="inner"><h1><a href="/">Artoirus</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:artori.us">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:artori.us">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/google-recursion-and-reader-ninja-easter-eggs/">
		
			Google Recursion 和 Reader Ninja 有趣的彩蛋</a>
	</h2>
	<div class="entry-content">
		<p>Google总是不小心冒出很多彩蛋，比如躲在doogle里的塞尔达的LOGO之类的。不过这次这个还真是很有意思。</p>

<p>我们知道一般来说我搜索gogle，那么他会提醒你说是不是google。</p>

<p><a href="/images/uploads/zb/2009-07-24_GoogleRecursion.jpg"><img src="/images/uploads/zb/2009-07-24_GoogleRecursion.jpg" alt="" /></a></p>

<p>但是现在的情况呢？相信很多Google fans的人都看到过了吧，就是如果你搜索recursion这个词，那么就会在纠错里问你 Did you mean: recursion。然后就陷入了永无止境的情况中。<a href="http://www.google.com/search?rlz=1C1_____enCN333CN333&amp;sourceid=chrome&amp;ie=UTF-8&amp;q=recursion">试试看</a></p>

<p><a href="/images/uploads/zb/2009-07-24_GoogleRecursion2.jpg"><img src="/images/uploads/zb/2009-07-24_GoogleRecursion2.jpg" alt="" /></a></p>

<p>那显然这个就是个bug了，我第一次看到消息的时候我也觉得挺无聊的，难免遇上bug么，不过今天在twitter上偶然有人提起，才发现自己忘了recursion这个单词的意思了吧，不就是递归、死循环吗？</p>

<p>看来这不是个bug，而是个彩蛋啊～</p>

<hr />

<p>另外还有一个彩蛋，是Google Reader的，在Reader界面中输入&#8221;上上下下左右左右BA&#8221;（不包括引号）。哈哈KONAMI的魂斗罗经典秘籍，之后被无数次的用在各种游戏中，想不到Google的developers也这么有心情，最近又是塞尔达又是KONAMI的好强大。</p>

<p>触发之后左侧会出现和Reader Shared Items主题一样的忍者背景图。这时使用like，会有一堆爱心，当然unlike就会心碎啦～</p>

<p><a href="/images/uploads/zb/2009-07-25_Reader.jpg"><img src="/images/uploads/zb/2009-07-25_Reader.jpg" alt="" /></a></p>

<p><a href="/images/uploads/zb/2009-07-25_Reader2.jpg"><img src="/images/uploads/zb/2009-07-25_Reader2.jpg" alt="" /></a></p>

<hr />

<p>话说博客换了个主题，很多地方都是半成品，大家见谅了。另外值得一提的是加上了IE6的升级提醒，不过因为我还是坚持使用Google Friend Connect 做一些必要的功能（而不是用Z-BLOG原生的），所以不得不告诉大家IE8的特殊性，留言本、回复、Google Account 的登录这些功能IE8都神奇的不兼容。Firefox3.5 要刷新一两下才有，最好就是用自家的Chrome了，自己不会扇自己耳光（虽然也有一段时间不行）。另外阅读区域的宽度差不多是接近600像素，据说好象是最适合阅读的宽度，看到长的文章不要疲劳啊～ 最后希望大家喜欢新主题～</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-25T07:12:19+08:00" pubdate data-updated="true">Jul 25<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/internet/'>internet</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/silverlight-3-and-gpu-acceleration/">
		
			Silverlight 3 和 GPU Acceleration</a>
	</h2>
	<div class="entry-content">
		<p>Silverlight3追加了很多新特性，其中不乏其特别重视的媒体支持，还有一些3D的小特性，以及这里写的GPU加速。我没有找到十足的佐证来证明打开关闭GPU加速之后究竟应用的效率发生了多少变化，事实上，这个变化也的确取决于CPU和GPU的性能，而在我有限的尝试中，没有找出非常有力的证据来证明打开GPU加速之后提高了多少效率。</p>

<p>结束掉XNA的教程，可以随便说说别的东西了，这样很有感觉。最近因为Google Reader的更新，通过新的Like功能follow了很多口味相似的朋友，更多的分享让我看到了更多感兴趣的东西。这次写Silverlight3里的GPU加速新特性，网上查了点资料想看看是怎样的，结果七零八落的，所以写一个吧。</p>

<p><strong>一、编码方法</strong></p>

<p>开启GPU加速的方法其实很简单，只需要在Object标签里设置一个属性就可以实现这一效果了，另外一些例子中提到了其他的一个辅助的属性，这里用最简单的例子讲一下。</p>

<p><strong>1、写UI</strong></p>

<p>UI元素我们简单一些，用MediaElement来播放一段视频。起初用了wmv，也可以顺利的说明这一问题，不过后来想到不如用H.264看看，也算是3的新特性了，放在一起用用，就找了个该编码的mp4视频，片子稍微有点老。</p>

<pre><code>&lt;Canvas x:Name="LayoutRoot" Background="White"&gt;
&lt;TextBlock Width="800" Height="25"
    Canvas.Top="10" Canvas.Left="10"
    Text="Arthraim.cn GPU Acceleration Demo"
    FontSize="14"/&gt;
&lt;MediaElement Width="640" Height="272"
    Canvas.Top="40" Canvas.Left="180"
    Source="http://localhost/H264_example.mp4"
    CacheMode="BitmapCache"&gt;
&lt;/MediaElement&gt;
&lt;Image Width="183" Height="272"
    Canvas.Top="40" Canvas.Left="10"
    Source="http://localhost/poster.jpg"
    Opacity="70"&gt;
    &lt;Image.Projection&gt;
        &lt;PlaneProjection RotationY="-30" GlobalOffsetX="0"/&gt;
    &lt;/Image.Projection&gt;
&lt;/Image&gt;
&lt;/Canvas&gt;
</code></pre>

<p>编译运行一下，可以看到截图如下，正常的播放着。背景是加上了白色属性的，默认的也是白色，不过不加上这个属性，背景的处理效果就不一样了，可以试试看。</p>

<p><a href="/images/uploads/zb/2009-07-20_GPUacceleration1.png"><img src="/images/uploads/zb/2009-07-20_GPUacceleration1.png" alt="" /></a></p>

<p><strong>2、修改客户端网页</strong></p>

<p>然后真正来看看如何使用GPU加速。要做的非常简单，找到使用silverlight的客户端页面，添加下面的变量。</p>

<pre><code>&lt;param name="EnableGPUAcceleration" value="true" /&gt;
</code></pre>

<p>这样还没完，光这样我们不知道究竟做了什么有价值的事情，在微软的帮助下，我们可以使用另一个属性 &#8212;- enableCacheVisualization，这名字就取得很好，意思很明了。至于编码上也是一样，加上了变量，设置为true：</p>

<pre><code>&lt;param name="EnableCacheVisualization" value="true" /&gt;
</code></pre>

<p>然后编译运行，哇，真是惨不忍睹，好好的视频怎么变成红色了，包括背景和左边的海报都一并红色了。其实这就是添加第二个属性的作用，红色的区域就是指没有应用GPU硬件加速的区域。</p>

<p><a href="/images/uploads/zb/2009-07-20_GPUacceleration2.png"><img src="/images/uploads/zb/2009-07-20_GPUacceleration2.png" alt="" /></a></p>

<p><strong>3、修改UI</strong></p>

<p>要使得硬件加速应用在对象上，那么最后还要修改UI的MediaElement。Silverlight3在UIElement中添加了一个public属性，名为CacheMode，以配合GPU加速的使用。而MediaElement 当然是可以华丽丽的使用CacheMode这个属性的。给刚才的代码修改一下。</p>

<pre><code>&lt;MediaElement Width="640" Height="272"
    Canvas.Top="40" Canvas.Left="180"
    Source="http://localhost/H264_example.mp4"
    CacheMode="BitmapCache"&gt;
</code></pre>

<p>编译运行。中间没有红色遮盖的部分，就是真正表示了被GPU加速处理的部分。</p>

<p><a href="/images/uploads/zb/2009-07-20_GPUacceleration3.png"><img src="/images/uploads/zb/2009-07-20_GPUacceleration3.png" alt="" /></a></p>

<p>值得一提的是旁边的图片（本来是做对比用的，结果恰好遇到了这种情况）变成了绿色（无论Image是否设置了CacheMode属性），我Google了会儿，在官方论坛上也没有人答出个所以然来，据说没有加速的会被tint a color，但是没说绿色和红色分别代表了什么。我是先看到这个帖子，才自己碰到这个情况的，很巧这个例子刚好可以碰到，究竟绿色是怎么回事，知道的朋友告诉我下～</p>

<hr />

<p><strong>二、简单性能测试</strong></p>

<p>我没有编写什么代码来做什么性能测试，这里只是简单的看看CPU占用率而已，想想GPU处理去了CPU总可以减负吧，但是结果应当说相当相当的不明显，不深究了。图左边的CPU使用情况那个数值是没什么作用的，那只是一个偶然的情况，我觉得看下来两者的确是有差异的，没加速的时候大部分时间看到的数字是50以上，而打开则在50左右跳动。旁边的波形图才是比较客观的反应的，放视频的几分钟监控到的情况。其中没有打开加速的时候出现一个大的波峰，是我尝试的切换最大化的IE窗口到VS08的窗口的时候发生的情况。在打开加速之后，我也切换了一次，也感到有一些卡，不过波形上表现并不十分明显。</p>

<p>另外，也不知这个所谓的GPU加速功能有没有用到CUBA技术。</p>

<p><a href="/images/uploads/zb/2009-07-20_GPUacceleration5.jpg"><img src="/images/uploads/zb/2009-07-20_GPUacceleration5.jpg" alt="" /></a></p>

<hr />

<p><strong>三、附加3D测试</strong></p>

<p>无聊试试看同一个例子下，把MediaElement 给3D处理后还能不能硬件加速，绕Y轴旋转了点角度。从红色分布的情况来看似乎是不能加速，希望有朋友能继续探究一下这个问题。</p>

<p><a href="/images/uploads/zb/2009-07-20_GPUacceleration4.png"><img src="/images/uploads/zb/2009-07-20_GPUacceleration4.png" alt="" /></a></p>

<p>简单的写到这里吧，还有很多值得深入下去，当然，关于硬件加速方面留给微软的工作恐怕也还有很多很多。这个例子很好，不但遇到了一些特殊情况，还包括了H.264和3D等新特性的应用。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-21T05:27:24+08:00" pubdate data-updated="true">Jul 21<span>st</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-index/">
		
			XNA教程-3D游戏-目录索引</a>
	</h2>
	<div class="entry-content">
		<p><a href="/images/uploads/zb/XNAGS3_1.png"><img src="/images/uploads/zb/XNAGS3_1.png" alt="" /></a></p>

<p><strong>2011-01-16更新：换了域名和URL，更新一下链接~</strong></p>

<p>XNA GameStudio 3.1，微软XNA Creators Club Online上3D游戏视频教程文字版索引。</p>

<p><strong>XNA游戏教程.3D</strong></p>

<ol>
<li><p><a href="/xna-tutorial-3d-ch1-introduction/">3D游戏教程简介</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch2-create-solution/">创建游戏工程</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch3-add-assets/">添加Asset</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch4-render-3d-titan/">绘制3D地表</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch5-render-gameobject/">绘制GameObject</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch6-finish-missile-launcher/">完成炮台</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch7-create-missiles/">添加导弹</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch9-add-audio/">添加声效</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch9-create-enemy-ufo/">添加敌方UFO</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch10-destroy-ufo/">摧毁UFO</a></p></li>
</ol>


<p><strong>相关知识点链接</strong>（在各个章节中涉及到的知识点，<em>基本上都在文章的末尾</em>）：</p>

<ol>
<li><p><a href="/xna-tutorial-3d-ch4-render-3d-titan/">2D游戏和3D游戏之间的区别</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch4-render-3d-titan/">创建一个模型绘制方法</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch5-render-gameobject/">构造世界变换</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch6-finish-missile-launcher/">欧拉旋转</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch7-create-missiles/">什么是上一步操作状态，为什么要记录它？</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch9-add-audio/">什么是XACT？</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch9-add-audio/">设计时和运行时的XACT对象</a></p></li>
<li><p><a href="/xna-tutorial-3d-ch9-add-audio/">加载一个XACT工程</a></p></li>
</ol>


<p><strong>原视频教程链接</strong>：<a href="http://creators.xna.com/en-US/education/gettingstarted/bg3d/chapter1">这里</a></p>

<p><strong>系列2D教程目录索引</strong>：<a href="/xna-tutorial-2d-index/">这里</a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-20T08:34:24+08:00" pubdate data-updated="true">Jul 20<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch10-destroy-ufo/">
		
			XNA教程-3D游戏-10-摧毁UFO</a>
	</h2>
	<div class="entry-content">
		<p>运行一下现在的样子，实在是已经相当满意了。一个terrain覆盖的世界，一个稳稳的launcher_base，一个可以在base上自由旋转的launcher_top，并且可以使用这个launcher发射无数的导弹，远处也会飞来无数的敌方UFO，看上去游戏已经非常完整了，唯独偏偏少了一点点&#8212;-导弹无法射落UFO。那么这次的教程显而易见，就是用到3D碰撞检测，来让missile和enemyship来个大碰撞。</p>

<p>这次的教程不是很复杂，所以今天心情好就赶快把他结束掉，可以让博客转入让我自由发挥的方向。那马上开始吧～</p>

<p><strong>1、修改UpdateMissiles()</strong></p>

<p>先要修改一下这个方法，在if (missile.position.Z &lt; -6000.0f) { missile.alive = false; } 后面加上一个else，然后调用一个莫须有的方法，代码如下：</p>

<pre><code>else
{
    TestCollision(missile);
}
</code></pre>

<p>当然这个方法还没有加上。</p>

<p><strong>2、写TestCollision()</strong></p>

<p>先把这个方法全部的代码贴上吧：</p>

<pre><code>void TestCollision(GameObject missile)
{
    BoundingSphere missilesphere =
        missile.model.Meshes[0].BoundingSphere;
    missilesphere.Center = missile.position;
    missilesphere.Radius *= missile.scale;
    foreach (GameObject ship in enemyShips)
    {
        if (ship.alive)
        {
            BoundingSphere shipsphere =
                ship.model.Meshes[0].BoundingSphere;
            shipsphere.Center = ship.position;
            shipsphere.Radius *= ship.scale;
            if (shipsphere.Intersects(missilesphere))
            {
                soundBank.PlayCue("explosion");
                missile.alive = false;
                ship.alive = false;
                break;
            }
        }
    }
}
</code></pre>

<p>解释一下，BoundingSphere类是记录的是一个球形，也就是3D模型最大的外轮廓。用这个类的intersects方法和其他模型的boundingsphere确定是否相交，虽然粗糙，但是基本上已经符合我们的要求了。（相信我，即便是这样，依然难度很高）要确定BoundingSphere的中心点为模型所在的position，而半径要记得乘上scale，不然就不对了。</p>

<p>那么实际检验的地方就很简单，拿到一个missile后，遍历每一个UFO（两层循环），然后检查是否相交，如果相交就杀掉双方，并且播放声音&#8212;-我们之前准备的爆炸的声音。</p>

<p>OK，编译运行，我们这个教程的最后一部分就完成了。（放效果图，不过放了也看不出碰撞）</p>

<p><a href="/images/uploads/zb/2009-07-20_Runtime.jpg"><img src="/images/uploads/zb/2009-07-20_Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=165"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-20T08:23:33+08:00" pubdate data-updated="true">Jul 20<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch9-create-enemy-ufo/">
		
			XNA教程-3D游戏-09-添加敌方UFO</a>
	</h2>
	<div class="entry-content">
		<p>应当说之前的Chapter08是插进来的一个部分，让我们的工程还没有变得非常巨大之前，在我们第一个需要声音的对象创建之后，插进如何制作音频的教程。而按照正常的逻辑，我们现在应该添加敌人，让我们的导弹&#8221;有的放矢&#8221;（有地方使）。和2D类似，UFO是我们的敌人，他从屏幕的最远端向我们靠近，而最终飞过我们的头顶后消失，其实就游戏逻辑来说和2D是一回事，只是所在空间和视角不同了。</p>

<p>惯例，在第一段之后说一些废话。最近更新的非常缓慢，不当心看了看最近博客的点击量发现这数字也是小的可怕至极。不过我不太关注那些东西的，只是自己也期待着快点把这个教程结束，然后继续我原来的博客路线。本来以为暑假可以用XNA做点东西，所以觉得写这个也挺有趣，不过最近做别的东西中，所以这个教程快快结束吧，希望能帮助到有需要的人就对了。说起来2D教程只用了一个星期啊……</p>

<p>言归正传，开始这一节的教程吧。</p>

<p><strong>第一步、初始化UFO</strong></p>

<p>和terrain以及missilelauncher的base或head一样，载入一个GameObject的典型方法也同样适用于UFO，只是不止一个UFO，所以我们还是类似2D的，使用了GameObject的数组。</p>

<p><strong>1、声明</strong></p>

<p>在Game类，你声明了一大串一大串的地方添加如下的声明。</p>

<pre><code>Random r = new Random();
const int numEnemyShips = 3;
GameObject[] enemyShips;
</code></pre>

<ul>
<li><p>r是一个Random对象，可以让我们用来随机确定UFO的初始位置及速度。</p></li>
<li><p>numEnemyShips看来是一个会被我恶搞的变量，指同屏（最大）出现的UFO数量。</p></li>
<li><p>enemyShips当然就是GameObject的数组，数量由上一个变量确定。</p></li>
</ul>


<p><strong>2、实例化</strong></p>

<p>找到LoadContent方法，在方法的最后加上实例化一个GameObject的代码。</p>

<pre><code>enemyShips = new GameObject[numEnemyShips];
for (int i = 0; i &lt; numEnemyShips; i++)
{
    enemyShips[i] = new GameObject();
    enemyShips[i].model = Content.Load&lt;Model&gt;(
        @"Modelsenemy");
    enemyShips[i].scale = 0.1f;
    enemyShips[i].rotation = new Vector3(
        0.0f, MathHelper.Pi, 0.0f);
}
</code></pre>

<p>实例化数组后，用一个 for 循环遍历这个数组。</p>

<p>每一次遍历，先实例化GameObject，然后确定模型以及缩放和旋转，还记得旋转吗？Pitch, Yaw, Roll，所以这里的初始化值是0,pi,0，yaw了180度，即朝向屏幕外的我们。</p>

<p>这里没有对其他的一些成员做初始化，它们被留到Update里面去处理。</p>

<hr />

<p><strong>第二步、更新UFO</strong></p>

<p>留了一部分工作放在Update里完成，所以Update的工作也比较大，和Missiles一样，我们写另外一个方法来处理。</p>

<p>方法命名为：UpdateEnemyShips()。把它的调用放在Game类中Update方法处理音频update的后面。</p>

<p>然后写UpdateEnemyShips方法的内容如下：</p>

<pre><code>void UpdateEnemyShips()
{
    foreach (GameObject ship in enemyShips)
    {
        if (ship.alive)
        {
            ship.position += ship.velocity;
            if (ship.position.Z &gt; 500.0f)
            {
                ship.alive = false;
            }
        }
        // next step...
    }
}
</code></pre>

<p>因为已经实例化，所以可以用foreach来遍历了。如果UFO存活，那么位置加上速度即更新为当前位置。但是也必须处理如何杀掉它，记得第一段说的，&#8221;飞过头顶的时候&#8221;杀掉，那么就是检查Z轴就可以了。</p>

<p>注释部分是留给下一步，完成第一步欠下的，UFO的一些初始化工作。</p>

<hr />

<p><strong>第三步、继续初始化UFO</strong></p>

<p>就像这一步的名字一样，继续初始化，这是第一步欠下的债。第一步没有个position和velocity初始化，因为所有的enemy的这两个属性不是一次性初始化就好了的，随着Update里的死亡，他们要重新被初始化，所以我们不把这个工作放在第一步的LoadContent方法里，而是放在Update方法里。</p>

<p><strong>1、声明</strong></p>

<p>同样的我们需要先声明几个变量，帮助我们使用随机数。在Game类内声明以下变量：</p>

<pre><code>Vector3 shipMinPosition = new Vector3(-2000.0f, 300.0f, -6000.0f);
Vector3 shipMaxPosition = new Vector3(2000.0f, 800.0f, -4000.0f);
const float shipMinVelocity = 5.0f;
const float shipMaxVelocity = 10.0f;
</code></pre>

<p>如果你看过2D教程，那么这四个变量的用意就一定知道。</p>

<p>两个Vector3把起始位置限定在了一个立方体内。X轴-2000～2000（屏幕的左右位置），Y轴300～800（屏幕的上下位置，即高度），Z轴-6000～-4000（屏幕的深度，即距离屏幕6000到4000这个距离）。</p>

<p>而velocity，即速度，因为我们的UFO走平行于Y轴的直线，所以只用float限定他在Z轴上的速率。5到10之间。</p>

<p><strong>2、继续更新UFO</strong></p>

<p>第二步的时候，我们处理了或者的UFO如何的更新，和如何杀死。现在要处理杀死的UFO，如何复活，包括游戏刚刚运行时所有的都在死掉状态的UFO如何初始化。在第二步的方法注释部分添加如下代码：</p>

<pre><code>else
{
    ship.alive = true;
    ship.position = new Vector3(
        MathHelper.Lerp(
            shipMinPosition.X,
            shipMaxPosition.X,
            (float)r.NextDouble()),
        MathHelper.Lerp(
            shipMinPosition.Y,
            shipMaxPosition.Y,
            (float)r.NextDouble()),
        MathHelper.Lerp(
            shipMinPosition.Z,
            shipMaxPosition.Z,
            (float)r.NextDouble()));
    ship.velocity = new Vector3(
        0.0f,
        0.0f,
        MathHelper.Lerp(
            shipMinVelocity,
            shipMaxVelocity,
            (float)r.NextDouble()));
}
</code></pre>

<p>代码看起来很长，但其实逻辑很简单，我们只修改了三个属性：alive、position、velocity。</p>

<p>只是我们用到了MathHelper.Lerp方法和Random.NextDouble方法嵌在代码里。Lerp限定r.NextDouble生成的一个随机的双精度浮点数的范围，分到X,Y,Z三个分量上而已。而velocity就像之前说的，只需要Z轴有速度，所以只在Z轴用了相应的方法。</p>

<p>那么处理完这些，最后一步就是绘制UFO了。</p>

<hr />

<p><strong>第四步、绘制UFO</strong></p>

<p>找到Draw方法，和missiles的画法一样，用一个foreach循环就搞定了。多亏了我们有写DrawGameObject这样的方法。</p>

<pre><code>foreach (GameObject enemyShip in enemyShips)
{
    if (enemyShip.alive)
    {
        DrawGameObject(enemyShip);
    }
}
</code></pre>

<p>好了好了，这样就没有问题了。编译、运行。（效果如图，点击放大）我承认我改了UFO数量。</p>

<p><a href="/images/uploads/zb/2009-07-19_Runtime.jpg"><img src="/images/uploads/zb/2009-07-19_Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=164"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-20T07:40:59+08:00" pubdate data-updated="true">Jul 20<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch9-add-audio/">
		
			XNA教程-3D游戏-08-添加声效</a>
	</h2>
	<div class="entry-content">
		<p>这个3D教程中，有一个对于2D也通用的，并且在之前的教程没有涉及到过的内容，就是音效，也就是这一次要完成的内容。用到了XACT来处理一些东西，那么教程就是音效的添加了，发射导弹之后的音效。当然作为XNA游戏，你也可以调用其他API来完成这个工作，不过这里讲的是标准的利用XNA的XACT来完成的步骤。</p>

<p>放假就是放假，感觉做正经事情的效率还真是很低，更不用说好好打理博客了。拖了几天，因为组织了一场初中同学会，可谓轰轰烈烈，难得可以请到那么多以前的老师，都很是感激和感动。言归正传，写程序吧。</p>

<p><strong>第一步、简介</strong></p>

<p>游戏很重要的一个因素是声音，在之前的2D教程中，却没有涉及到这个内容。在XNA中，我们使用的音效将是被包含在另一个声音工程当中的，这就要使用到XNA Game Studio中的一个工具 &#8212;- Microsoft Cross-Platform Audio Creation Tool 简称为XACT。在开始菜单中选择它，有v2或v3两个版本，这里我们和教程一样v3，大概的功能都是一样的。（参见文章后方的翻译1、什么是XACT？）</p>

<p><img src="/images/uploads/zb/2009-07-13_XACTs.jpg" alt="" /></p>

<p>打开后界面如下图所示，除了工具栏，左侧上方是一个树形视图，有一些项目已经存在。</p>

<p><a href="/images/uploads/zb/2009-07-13_XactUserInterface.jpg"><img src="/images/uploads/zb/2009-07-13_XactUserInterface.jpg" alt="" /></a></p>

<hr />

<p><strong>第二步、新建XACT工程</strong></p>

<p><strong>1、创建新工程</strong></p>

<p>类似Visual Studio的思路：选择File->New Project。</p>

<blockquote><p>&#8230;TChapter8ContentAudioTAudio.xap</p></blockquote>

<p>选择路径（比如我使用如上路径），保存为任意的名字，[确定]，这样创建就算成功了。</p>

<p><img src="/images/uploads/zb/2009-07-13_NewXactProject.jpg" alt="" /></p>

<p><strong>2、新建Wave Band</strong></p>

<p>然后在左边树形图上，WaveBand处右键->New Wave Band。新建一个Wave Band。</p>

<p><strong>3、新建Sound Band</strong></p>

<p>最后在左边树形图上，SoundBand处右键->New Sound Band。新建一个Sound Band。</p>

<p><a href="/images/uploads/zb/2009-07-13_NewWaveBand_NewSoundBand.jpg"><img src="/images/uploads/zb/2009-07-13_NewWaveBand_NewSoundBand.jpg" alt="" /></a></p>

<hr />

<p><strong>第三步、添加Wave并创建Sound</strong></p>

<p><strong>1、插入wav文件</strong></p>

<p>右键单击右侧Wave Band的子窗口空白处，选择Insert Wave Files。</p>

<p><a href="/images/uploads/zb/2009-07-13_AddWavesToWaveBand.jpg"><img src="/images/uploads/zb/2009-07-13_AddWavesToWaveBand.jpg" alt="" /></a></p>

<p>记得我们之前排除到GS游戏工程外面的那两个wav文件吗，现在把他们找到并且插入进来。一个是发射导弹的声音，一个是爆炸的声音。</p>

<p><a href="/images/uploads/zb/2009-07-13_Waves.jpg"><img src="/images/uploads/zb/2009-07-13_Waves.jpg" alt="" /></a></p>

<p>插入之后如下图所显示的，这样我们准备好了Wave了。</p>

<p><a href="/images/uploads/zb/2009-07-13_AfterAddedWaves.jpg"><img src="/images/uploads/zb/2009-07-13_AfterAddedWaves.jpg" alt="" /></a></p>

<p><strong>2、创建Sound</strong></p>

<p>这里利用一些XACT提供的便捷操作，我们很容易办到。简单的把Wave Band子窗体内的两个wav，拖拽到Sound Band子窗体的Cue区域内，这样会自动创建出我们需要的一切。</p>

<p><a href="/images/uploads/zb/2009-07-13_AddWavesToCue.jpg"><img src="/images/uploads/zb/2009-07-13_AddWavesToCue.jpg" alt="" /></a></p>

<p>Wave, Sound, Cue是XACT中涉及的重要的概念，如上图我们是这样的处理顺序，但是其实内部处理时不是这样的。（参见文章后方的翻译2、设计时与运行时的XACT对象）</p>

<p>准备就绪后，保存并且退出，之后的工作，就是在GS里完成了。</p>

<hr />

<p><strong>第四步、在GS工程中添加XACT工程</strong></p>

<p>完整的创建了一个XACT工程之后，我们就直接可以把它当作asset放进GS工程的Content中，并且在游戏中，直接可以从Content pipline去Load这些声音了。当然首先我们要把它添加进来。</p>

<p>右键单击Content下的Audio目录，选择Add->Existing Items。</p>

<p><a href="/images/uploads/zb/2009-07-13_AddXactProjectToGs.jpg"><img src="/images/uploads/zb/2009-07-13_AddXactProjectToGs.jpg" alt="" /></a></p>

<p>找到保存起来的xap工程文件，[确定]。（比如我刚才保存的是TAudio.xap，找到它）</p>

<p><img src="/images/uploads/zb/2009-07-13_AfterAddedXactProject.jpg" alt="" /></p>

<p>如上图，声音就添加成功了。</p>

<hr />

<p><strong>第五步、加载声音内容</strong></p>

<p>之前我们载入一些资源都是使用了Content.Load这个方法，那么这里载入Audio将会有些不同，我们需要一些其他的方法来调用它们。</p>

<p><strong>1、声明 </strong></p>

<p>首先在Game类声明一些需要用到的私有变量。</p>

<pre><code>AudioEngine audioEngine;
SoundBank soundBank;
WaveBank waveBank;
</code></pre>

<p>没错，这里用到了三个类，两个很熟悉，SoundBank和WaveBank，应该是和之前的对应起来的。AudioEngine顾名思义，是处理声音的引擎，究竟如何工作，看下去。</p>

<p><strong>2、加载</strong></p>

<p>加载Content中的声音文件，是一个非常特殊的步骤，代码只有三行，在LoadContent方法中，SpriteBatch那一行的下面加上这样三行代码。</p>

<pre><code>audioEngine = new AudioEngine(@"ContentAudioTAudio.xgs");
waveBank = new WaveBank(audioEngine, @"ContentAudioWave Band.xwb");
soundBank = new SoundBank(audioEngine, @"ContentAudioSound Band.xsb");
</code></pre>

<p>注意，这三行代码的特殊之处，就在于三个后缀。</p>

<p>audioEngine中，不是使用了TAudio.xap这个文件，而是使用了TAudio.xgs这样的方式。如果看过之前对Content Pipline的介绍，那么你就不会不知道，Content不是简单的一个文件夹把文件组织起来，而是会对输入asset做处理并且有相应的输出，而这里的xap作为输入，我们是无法直接获得相应的Wave Band和Sound Band的。&#8221;xgs&#8221;缩写自XACT Global Settings，它是一个告诉你XACT工程如何组织文件的文件，Content Pipline只有依靠他才能找到我们需要的各种资源。大致说来就是这样。</p>

<p>一样的WaveBand和SoundBand的构造方法中，传入的是Wave Band.xwb（代表XACT Wave Band）和Sound Band.xsb（代表XACT Sound Band），而文件名则是我们之前在XACT工程中保留默认命名的Wave Band和Sound Band，当然你可以取不一样的名字。xwb和xsb类似xgs，也是输出的结果，就像之前的texture和model我们根本不使用后缀一样。</p>

<p>如果你编译了你的工程之后，可以在Debug目录下相应的位置找到这三个文件。（参见文章后方的翻译3、加载一个XACT工程）</p>

<hr />

<p><strong>第六步、添加声音播放的代码</strong></p>

<p><strong>1、Update声音</strong></p>

<p>我们肯定要求声音跟着游戏循环播放，而不是在一帧里面放完就结束。</p>

<p>在Update方法中，找到UpdateMissiles();这行调用，在其下方插入一行。</p>

<pre><code>audioEngine.Update();
</code></pre>

<p>这个方法可以保证声音一帧一帧的更新并且播放，其实游戏中我们播放的既不是Sound也不是Wave，而只是Cue。</p>

<p><strong>2、 播放导弹发射声音</strong></p>

<p>在发射导弹的时刻播放一个missilelaunch的声音，下面来找到FireMissile()方法，在if (!missile.alive)之后插入这样一行代码。</p>

<pre><code>soundBank.PlayCue("missilelaunch");
</code></pre>

<p>编译运行，我们要的生效就出现了～</p>

<p>【官方代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=163"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>以下是一些XACT相关内容的翻译，总共有三个部分，分别对应第一步、第三步、和第五步的相关操作。</p>

<p>在翻译中涉及到了一些概念，其中经常被提到的有3个词，在原文中采用了小写，因此不是什么特有名字，但是却很难翻译成中文，这里特别提出一下。分别是wave,sound,cue这三个词。这是XACT涉及到的三个很重要的概念，它们环环相扣，所以翻译也许十分恼人。我把它们翻译成&#8221;波&#8221;、&#8221;声音&#8221;、&#8221;索引&#8221;，虽然不太贴切，但是可以保证在以下的文字中，只要出现这三个中文词，绝对就代表了这三个英文的原文单词。并且每一段文字中第一次出现这三个词的时候，都会在括号里写上相应的原文。另外设计到的一些首字母大写的专有名词都没有翻译。</p>

<p>（以下文字有本人翻译自XNA Creators Club官网，未经允许严禁转载；因本人水平有限，难免出错，望得到更正）</p>

<p><strong>1、什么是XACT？</strong></p>

<blockquote><p>教程的这一部分将介绍包含在XNA Game Sudio中的一个新的程序&#8212;-Microsoft Cross-Platform Audio Creation Tool，或者简称为XACT。</p>

<p>就像它的名字一样，XACT是一个跨平台的工具，制作音频输出用以Windows和Xbox360。XACT的设计允许音频独立于将要使用的平台来单独设计。</p>

<p>XACT由两个主要部分组成：音频设计器（在这章节教程开始时你用到的图形化工具）和音频API（教程结束部分你会用到的代码）。音频设计器旨在允许任何一个为游戏设计音频的设计者可以进行操作，即便其不熟悉音频代码。</p>

<p>音频设计者使用所有原生的波形音频文件（.wav文件，被称为波（wave））。然后设计者组织这些波到声音（sound）形式，可以被让一个或多个波在各种时间和各种设定下被播放。最后，音频设计者组织声音到索引（Cue）形式。索引代表了在代码阶段可以访问的对象，并且相比实际的音频文件，更加接近游戏事件。</p>

<p>索引是暴露给程序员的，在合适的游戏事件发生时，使用XACT API调用索引播放。音频设计者同时可以设计一些运行时的参数，来修改播放的声音的音量或说是波幅，传递这些参数给程序员，使其能转化这些参数为游戏代码中的变量。</p>

<p>虽然起初看起来似乎有些复杂，但其优势可以在音频设计者要替换波形音频文件的时候，调整音频如何播放的时候，修改索引如何播放一个声音的时候，或改变设定的参数如何修改播放的声音的时候。音频设计者可以做所有的这些工作，而不必接触游戏源代码。</p>

<p>XACT是一个快捷且灵活的工具，来添加健壮、饱满的音频到使用XNA Game Studio创建的游戏中。</p></blockquote>

<p><strong>2、设计时和运行时的XACT对象</strong></p>

<blockquote><p>XACT工程有很多的组成部分。虽然其中一些部分是可选的，但一个基本形式的XACT对象对于XACT工程组织音频到XACT API还是非常必要的。</p>

<p>每个XACT工程包含了一个或多个Wave Bank。一个Wave Bank是一些波形音频文件的集合，称为波（wave）。这些Wave Bank中的波不是由XACT API直接访问的。而是给音频设计者转换其成为声音（sound）的。</p>

<p>这些声音组织成为一个或多个Sound Bank。一个Sound Bank是一些声音的集合。声音是使用各种参数去播放一个或多个波的时候的须知（instruction），这些参数可以是控制循环，变换效果，波的随机选择，或者更多其它的。</p>

<p>Sound Bank也同样可以包含索引（cue）。索引是播放声音的须知（instruction to play sounds）。索引调用特定的声音，或随机选择声音，这取决于音频设计者如何设定这个索引。</p>

<p>当一个XACT工程已经建立，sound bank和wave bank就被编译到文件中了，一起的还有一个全局设定文件（global setting file）包含了一些工程特定的信息。这些文件在运行时使用XNA Framewrok来调用。</p>

<p>在sound bank、wave bank和全局设定文件被加载到游戏中后，程序员可以调用SoundBank.PlayCue，传入音频设计者已经定义好的索引的名字，来播放任意一个sound bank中索引。这样会按照音频设计者设计的默认方式播放这些索引，而没有任何程序员掌握的控制条件。</p>

<p>要得到播放的索引更多颗粒化的操作，包括暂停、回复和停止的功能，程序员可以调用SoundBank.GetCue并且得到一个Cue对象。然后程序员可以根据需要调用Cue.Play，Cue.Stop，CuePause，和Cue.Resume。然而，这样使用Cue对象仍然需要谨慎一些。如果你创建的一个Cue对象在声明的时候存在范围的限制（比方说只声明在一个方法中），就不要把Cue对象存储到静态化存储空间中，就像类的数组或List集合，这些Cue对象会在程序溢出这个范围之后停止并释放。</p>

<p>在一个索引被封播放之后，XACT音频引擎的任务就完成了。这取决于索引和其相关联的声音的关系，以及声音和其相关联的波的关系，然后按照音频设计者设计的那样来播放相应声音和波。</p></blockquote>

<p><strong>3、加载一个XACT工程</strong></p>

<blockquote><p>在XNA Game Studio游戏中播放音频需要加载XACT工程到XNA Framework内容管道（Content Pipline）中，编写加载XACT运行时输出文件所必要的代码，然后在游戏编译进程中XACT工程会被编译成为XACT输出文件。</p>

<p>音频内容和XNA Game Studio中大部分其他内容的形式不同。XACT处理生成的内容不像模型、贴图纹理或者字体那样在运行时使用ContentManager.Load方法加载。</p>

<p>取而代之的，是构造AudioEngine、SoundBank、和WaveBank这些XNA Framework中音频相关的类，用来加载编译后的音频文件。用正确的顺序加载这些文件，用名称和后缀定义它们都非常重要。否则，你可能会遇到错误。</p>

<p>要明白如何加载这些文件，那明白XACT工程编译后生成了什么文件就显得十分重要。</p>

<p>XACT生成的第一个文件就是XACT工程文件（.xap）。这个文件是音频设计者在用音频设计工具保存音频工程时创建的。这个文件应该放置到Solution Explorer中，即把它添加到XNA Framework内容管道（Content Pipeline）的文件列表中去编译。</p>

<p>在编译开始后，内容管道把XACT工程文件编译成为一系列XACT输出文件。第一个生成的文件是全局设定文件（Global Settings File），默认命名为XACT工程文件一样的名字，扩展名为.xgs。如果XACT工程文件的名字是MyGameAudio.xap，那全局设定文件的默认的名字就是MyGameAudio.xgs。</p>

<p>编译过程之后会生成一个或多个wave bank文件，数量取决于音频设计者在XACT工程中添加的wave bank的数量。这些wave bank文件有一个后缀.xwb，并且由音频设计者在之前命名。默认的一个wave bank的输出文件名为Wave Bank.xwb。</p>

<p>编译过程还会生成一些sound bank文件，同样取决于音频设计者在XACT工程中添加的sound bank的数量。这些Sound bank文件有一个后缀.xsb，并且由音频设计者在之前命名。默认的一个sound bank的输出文件名为Sound Bank.xsb。</p>

<p>加载这些文件是初始化当使用XNA Framework播放音频时需要的代码对象的重要部分。加载工作表现为一步一步构造所有相关联的这些代码对象。全局设定文件用来构造AudioEngine。AudioEngine对象和wave bank文件同时使用，可以初始化一个WaveBank对象，而和sound bank文件一起使用，可以初始化一个SoundBank对象。</p>

<p>下面的插图解释了文件的一些关系，从音频设计者在设计时的形式，到通过内容管道编译时的形式，最终成为运行时游戏开始后被载入的形式。</p>

<p><a href="/images/uploads/zb/BG_4.8.5.4pd.png"><img src="/images/uploads/zb/BG_4.8.5.4pd.png" alt="" /></a></p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-14T01:26:58+08:00" pubdate data-updated="true">Jul 14<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch7-create-missiles/">
		
			XNA教程-3D游戏-07-添加导弹</a>
	</h2>
	<div class="entry-content">
		<p>在3D的地表上添加了可以控制的炮塔，接下去要让他向整个3D空间里自由的发射导弹。这次我们真正的要接触到Update这个方法了，另外知道在游戏循环中处理一些按键的逻辑。和2D一样，发射出去的导弹也是GameObject，那么一样的我们还是要用到它，并且要用到它的集合，来管理多枚屏幕中的导弹。</p>

<p>这一部分官方把视频分为了6段之多，不过其实内容基本上和2D差不多，那么还是一步一步看下去，其实分的越细致，越容易理解的。</p>

<p><strong>第一步、扩展GameObject</strong></p>

<p>正如前面说到的，这一次要用GameObject来描述导弹，那么它就应该具有所有导弹需要的属性，和2D类似，需要的是一个Vector3记录初速度， 和一个bool记录模型是否存活。</p>

<p>添加这样两行到GameObject类中～</p>

<pre><code>public Vector3 velocity = Vector3.Zero;
public bool alive = false;
</code></pre>

<ul>
<li><p>velocity：Vector3，记录速度（速率和方向），初始化为0；</p></li>
<li><p>alive：bool，记录是否存活，初始化为false。</p></li>
</ul>


<hr />

<p><strong>第二步、添加missiles数组</strong></p>

<p>拥有了为导弹扩展之后的GameObject类，现在就要添加一定数量的导弹了，所以我们用到了一个GameObject数组，来记录所有游戏中出现及没有出现的导弹。</p>

<p><strong>1、声明：</strong>还是要先添加声明，一个const int记录数组大小，即最多的同屏导弹数。在Game1类的头部添加代码：</p>

<pre><code>const int numMissiles = 20;
GameObject[] missiles;
</code></pre>

<p><strong>2、初始化：</strong>在LoadContent中用循环来初始化数组中所有的GameObject。找到LoadContent()：</p>

<pre><code>missiles = new GameObject[numMissiles];
for (int i = 0; i &lt; numMissiles; i++)
{
    missiles[i] = new GameObject();
    missiles[i].model = Content.Load&lt;Model&gt;(
    @"Modelsmissile");
    missiles[i].scale = 3.0f;
}
</code></pre>

<p>实例化missiles数组为20个GameObject。</p>

<p>循环使用for，遍历每一个，并实例化 ，载入模型为missile，缩放大小为3倍，因为模型比较小的缘故吧。</p>

<hr />

<p><strong>第三步、导弹发射输入</strong></p>

<p>这一步要编写控制导弹发射的逻辑，和2D一模一样，除了命名不一样。一样从声明和Update代码两部分看。</p>

<p><strong>1、声明：</strong></p>

<pre><code>GamePadState previousState;
#if !XBOX
KeyboardState previousKeyboardState;
#endif
</code></pre>

<h1>if和#endif在之前控制炮台转动的教程中已经出现过。</h1>

<p>这里为什么用到这样两个变量，在文章最后为加上翻译的资料。</p>

<p><strong>2、Update代码：</strong></p>

<pre><code>missileLauncherHead.rotation.Y = MathHelper.Clamp(
missileLauncherHead.rotation.Y,
-MathHelper.PiOver4,
MathHelper.PiOver4);
missileLauncherHead.rotation.X = MathHelper.Clamp(
    missileLauncherHead.rotation.X,
    0,
    MathHelper.PiOver4);
if (gamePadState.Buttons.A == ButtonState.Pressed &amp;&amp;
    previousState.Buttons.A == ButtonState.Released)
{
    FireMissile();
}
#if !XBOX
if(keyboardState.IsKeyDown(Keys.Space) &amp;&amp;
    previousKeyboardState.IsKeyUp(Keys.Space))
{
    FireMissile();
}
#endif
previousState = gamePadState;
#if !XBOX
previousKeyboardState = keyboardState;
#endif
</code></pre>

<p>这里的代码看上去挺多，但逻辑其实很清晰。都是在上一次按键放下的前提下，看下的话，就调用FireMissile方法。这样就不能按住案件连续发射了。</p>

<p>FireMissile方法正是下一步要完成的内容。</p>

<hr />

<p><strong>第四步、发射导弹</strong></p>

<p>在Update方法里的FireMissile就是更新导弹的一个重要步骤，我们应该在这里让导弹活过来，并且给予初速度。</p>

<p>这里不向2D获取速度、位置那么简单，因为要知道我们是三维的，所以我们用了一些新的方法来得到我们想要的，看下去吧。</p>

<p><strong>1、完成FireMissile方法。</strong></p>

<pre><code>void FireMissile()
{
    foreach (GameObject missile in missiles)
    {
        if (!missile.alive)
        {
            missile.velocity = GetMissileMuzzleVelocity();
            missile.position = GetMissileMuzzlePosition();
            missile.rotation = missileLauncherHead.rotation;
            missile.alive = true;
            break;
        }
    }
}
</code></pre>

<p>我就说微软工程师都是天才，先直接写了FireMissile方法，然后现在又无中生有了两个方法。不去管它，逻辑比较简单，foreach遍历所有的数组中的GameObject，如果不存活就让他活过来。</p>

<p>要活过来的话，先要给速度，再给初始位置，再给初始旋转为炮塔转到的角度。然后设置alive为真，break跳出。跳出保证每次只发射一颗子弹。</p>

<p><strong>2、声明两个新变量。</strong></p>

<p>这里我们需要声明两个新的变量，在Game1头部加上两行代码：</p>

<pre><code>const float launcherHeadMuzzleOffset = 20.0f;
const float missilePower = 20.0f;
</code></pre>

<p>两个浮点的常量。命名有些奇怪，但其实意思很简单</p>

<ul>
<li><p>launcherHeadMuzzleOffset，发射器头部炮口偏移量，翻译过来就是这个意思，就是指炮管的长度，也就是导弹刚刚射出的时候距离模型中心的长度。这个值得问做模型的美工啦～</p></li>
<li><p>missilePower，导弹的威力，就是指每一次更新导弹的位移，也就是速率。导弹的威力取决于速度？也许在这个游戏中是的吧。</p></li>
</ul>


<p>这是一个准备工作，为的是完成天才们预留的两个方法。</p>

<p><strong>3、GetMissileMuzzleVelocity方法。</strong></p>

<pre><code>Vector3 GetMissileMuzzleVelocity()
{
    Matrix rotationMatrix =
         Matrix.CreateFromYawPitchRoll(
             missileLauncherHead.rotation.Y,
             missileLauncherHead.rotation.X,
             0);
    return Vector3.Normalize(
        Vector3.Transform(Vector3.Forward,
        rotationMatrix)) * missilePower;
}
</code></pre>

<p>这里首先创建了一个rotationMatrix，用的就是CreateFromYawPitchRoll，之前也使用到过。从初始化的代码来看，得到的就是炮台的旋转情况，因为Z轴的旋转，也就是翻转（roll） 是不存在的，所以传给其0就可以了。</p>

<p>之后的步骤有些复杂，拆开来看。</p>

<ul>
<li><p>首先是调用了Vector3.Transform()这个方法，这个方法是把一个旋转矩阵转换成一个向量。</p>

<ul>
<li><p>第一个参数为一个Vector3，也就是参考的方向向量。</p></li>
<li><p>第二个参数是一个Matrix，也就是旋转矩阵。</p></li>
</ul>
</li>
</ul>


<p>方法会得到相对于第一个参数的向量的，当前Matrix的旋转情况。</p>

<ul>
<li><p>其次是调用了Vector3.Normalize这个方法，这个方法是把一个向量转换成一个单位向量。唯一的参数就是一个Vector3。相当于只保留了向量对方向的表达性，而去掉了速率的表达性。这样为最后一个工作作了铺垫。</p></li>
<li><p>最后把单位向量乘上missilePower，也就是位移量，这样给返回的Vector3加上了速率的信息。</p></li>
</ul>


<p>得到Velocity的过程就是这样，有了方向和速率，速度就这样完整了。</p>

<p><strong>4、GetMissileMuzzlePosition方法。</strong></p>

<p>得到了速度，这里要给他一个位置信息。因为是在FireMissile方法中被调用，那么其实就是起始位置，所以来看看代码。</p>

<pre><code>Vector3 GetMissileMuzzlePosition()
{
    return missileLauncherHead.position +
        (Vector3.Normalize(
            GetMissileMuzzleVelocity()) *
            launcherHeadMuzzleOffset);
}
</code></pre>

<p>很简单的直接返回。一样是一句复杂的语句，拆开来看看。</p>

<ul>
<li><p>首先调用了GetMissileMuzzleVelocity()方法，得到上一个方法完成的速度Vector3。</p></li>
<li><p>然后调用了Vector3.Normalize()方法，只取得它的方向信息，去除速率信息。</p></li>
<li><p>最后乘上launcherHeadMuzzleOffset，使得导弹出现的第一个位置是炮管的顶端，而不是模型的中心。</p></li>
</ul>


<p>意思很明了，前两个调用相当于是得到炮塔在按键的一刹那的方向。换句话说，用GetMissileMuzzleVelocity方法里的逻辑也不难得到。</p>

<hr />

<p><strong>第五步、更新导弹</strong></p>

<p>因为3D的缘故，第四步稍稍显得有些复杂了，有一些新的方法。</p>

<p>当然在完成了这些工作后，现在就显得简单的多了，这一步，只要让导弹在每次更新是移动一定的距离，并且在移动到一定距离后就消失。</p>

<p><strong>1、编写一个UpdateMissile方法。</strong></p>

<p>首先要写一个UpdateMissile的方法来管理所有的Missile的移动。</p>

<pre><code>void UpdateMissiles()
{
    foreach (GameObject missile in missiles)
    {
        if (missile.alive)
        {
            missile.position += missile.velocity;
            if (missile.position.Z &lt; -6000.0f)
            {
                missile.alive = false;
            }
        }
    }
}
</code></pre>

<ul>
<li><p>不需要返回值。</p></li>
<li><p>遍历所有的导弹，如果它存活着就更新他的位置。</p></li>
<li><p>原来的位置加上速度就是现在的位置。</p></li>
<li><p>如果导弹的Z坐标小于-6000，即，深入屏幕6000，那么就让他死掉，准备再一次的发射。</p></li>
</ul>


<p>以上就是所有的逻辑。</p>

<p><strong>2、调用UpdateMissile方法。</strong></p>

<p>写完方法当然要调用（这次到不是先调用再写了）。在Update方法中，previousState = gamePadState;这一行之前插入一行代码。</p>

<blockquote><p>UpdateMissiles();</p></blockquote>

<p>就是这样。</p>

<hr />

<p><strong>第六步、绘制导弹</strong></p>

<p>最后一步每次都是这样子，就是完成之前逻辑后，把它画出来，习惯了这系列的教程就非常明白了。</p>

<p>相对于前面调用DrawGameObject来说，这一次只是要用一个foreach循环调用很多遍而已。</p>

<pre><code>foreach (GameObject missile in missiles)
{
    if (missile.alive)
    {
        DrawGameObject(missile);
    }
}
</code></pre>

<p>最后，编译，运行～(点击放大，导弹太小，难以察觉，不如调整一下参数啊～)</p>

<p><a href="/images/uploads/zb/2009-07-08_runtime.jpg"><img src="/images/uploads/zb/2009-07-08_runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=162"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>之前说过，处理输入的那一步存在的一些疑问。（其实2D里也一样吧～）为什么要记录上一步的操作状态。究竟起到了什么作用，那么这一段解释非常非常的清楚。</p>

<p>（以下文字翻译自XNA Create Club网站，未经允许禁止转载。由于本人水平有限，所以有任何错误希望高手更正。）</p>

<p><strong>什么是上一步操作状态，为什么需要记录它？</strong></p>

<blockquote><p>要理解对应游戏的输入，很有必要退一步看看更加普通的输入。控制器的输入信号一般只是简单的电流信号，它被一种称为驱动软件的低级软件系统分析解释。信号以一定的频率传入分析它们的软件。</p>

<p>有些软件把输入的解析表现出来，反映出很多用户使用这个输入设备做出的动作，并且把这些动作存入缓冲记忆体中等待被读取或释放。这种类型的输入处理被称为&#8221;缓冲模式输入&#8221;(buffered-mode input)。</p>

<p>另一种输入处理不使用缓冲。取而代之的，是提供索取信号是的当前状态。没有提供参数来标识一定时间内所做出的特定动作。取而代之的，是程序员可以在任何时间自由的访问控制器的当前状态，包括所有的轴的位置以及按键的情况。程序员可以自由存储和操作相关的信息。这种输入处理被称为&#8221;立即模式输入&#8221;( immediate-mode input)。</p>

<p>XNA Framework使用立即模式输入，并且支持全部三种输入方式&#8212;-Xbox360控制器，键盘以及鼠标。这意味着，对于任意一种输入设备，你都可以在任何时间查询输入设备的当前状态信息。然而，你却不能查询任何过去的设备状态，除非你明确的把它存储在其他地方。</p>

<p>为什么要查询过去的输入状态呢？举个强烈依赖玩家快速按键的游戏作为例子。在这样的游戏中，长按按键不会有什么效果，只有重复的连打才能奏效。</p>

<p>由于立即模式输入处理的这一特性，每一次输入状态被查询，一个长按的按钮表现为&#8221;被按下&#8221;（Pressed）。不检查过去的状态是否是&#8221;被释放&#8221;（Released），就没有办法来区分按键是刚刚被按下还是长按了一段时间。</p>

<p>存储上一次状态缓解了这个问题。每一次循环到达更新（Update），正常的处理输入，但是在循环的末尾，存储当前状态为一个变量。这个变量就成为上一次状态。要检查按键是否是被一次按下还不是长按着，检查当前按键状态为&#8221;已按下&#8221;(Pressed)，并且上一次按键状态为&#8221;已释放&#8221;（Released）。</p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-08T23:38:32+08:00" pubdate data-updated="true">Jul 8<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch6-finish-missile-launcher/">
		
			XNA教程-3D游戏-06-完成炮台</a>
	</h2>
	<div class="entry-content">
		<p>之前完成了GameObject类的一些基础工作，也因此，我们可以使得terrain和missle launcher base利用GameObject绘制在了屏幕上。应该记得，我们添加发射塔的时候说明了，这只是一个基座（base），至于炮塔部分其实是没有被添加的，而这就是我们这次要完成的工作。不但要完成这个发射塔，还要使得它可以被用户控制，对用户输入产生反应，那么现在开始吧。</p>

<p><strong>第一步、绘制炮塔的GameObject</strong></p>

<p>这一步的当然是非常的简单，我们只是把没有画上去的那一半处理好就可以了，添加一个新的GameObject，步骤还是声明和初始化。</p>

<p><strong>1、声明。</strong>找到声明部分，在已经添加的两个GameObject下面添加一个新的GameObject的声明，代码如下：</p>

<pre><code>GameObject missileLauncherHead = new GameObject();
</code></pre>

<p>代码很简单。</p>

<p><strong>2、初始化。</strong>找到LoadContent方法，在初始化另外两个GameObject的代码下面添加以下代码：</p>

<pre><code>missileLauncherHead.model = Content.Load&lt;Model&gt;(
    @"Modelslauncher_head");
missileLauncherHead.scale = 0.2f;
missileLauncherHead.position = missileLauncherBase.position +
    new Vector3(0.0f, 20.0f, 0.0f);
</code></pre>

<p>讲解一下：</p>

<ol>
<li><p>首先是载入asset，没有什么问题。</p></li>
<li><p>定义比例为0.2f，即和base一样。</p></li>
<li><p>下面初始化position的位置，实在原有的Base位置上加了(0, 20, 0)这样一个向量，意味着炮塔比基座升高了20。</p></li>
</ol>


<p>这里不妨先完成第三步，看看效果。不过按照之前的习惯，都是完成了逻辑代码之后再绘制的。（微软的工程师都是天才，囧）</p>

<p><img src="/images/uploads/zb/2009-07-07_151248.jpg" alt="" /><img src="/images/uploads/zb/2009-07-07_151225.jpg" alt="" /></p>

<p>不难看出变化吧～</p>

<hr />

<p><strong>第二步、加入输入控制</strong></p>

<p>这一步我们要让这个炮台可以被我们控制，方法很简单，和2D的非常的类似，如果你有2D基础那么就非常容易理解这个部分的内容了，如果没有我下面可能还会讲一下，你也可以回顾一下<a href="http://arthraim.cn/post/2009/06/65.html">2D教程</a>中相似的内容，讲解对应XBOX360手柄GamePad类的一些坐标系的说明。</p>

<p><strong>1、添加XBOX360的控制代码。</strong></p>

<pre><code>GamePadState gamePadState = GamePad.GetState(PlayerIndex.One);
missileLauncherHead.rotation.Y -=
    gamePadState.ThumbSticks.Left.X * 0.1f;
missileLauncherHead.rotation.X +=
    gamePadState.ThumbSticks.Left.Y * 0.1f;
</code></pre>

<p>GamePadState类用来获取手柄的操作情况，GamePad.GetState方法来决定获取哪个手柄的操作。因为XBOX360可以连接多个最多4个手柄，所以PlayerIndex这个枚举中分别由One,Two,Three,Four四个值，对应1P 2P 3P 4P手柄。</p>

<p>gamePadState.ThumbSticks.Left对应XBOX360手柄的左边的类比摇杆（传统游戏机上的方向键，microsoft用摇杆替代了方向键，顺应欧美玩家的习惯）。另外相对还有一个Right，当然是在右边。X轴决定左右，Y轴决定上下。</p>

<p>那么手柄的左右，决定了围绕Y轴（纵向轴）的旋转；上下决定了围绕X轴（横向轴）的旋转。还有个Z轴的旋转我们没有用到，如果是飞行模拟游戏里，一般左右控制Z轴，而另外L,R键来控制X轴。</p>

<p><strong>2、添加键盘的控制代码。</strong></p>

<pre><code>#if !XBOX
KeyboardState keyboardState = Keyboard.GetState();
if(keyboardState.IsKeyDown(Keys.Left))
{
    missileLauncherHead.rotation.Y += 0.05f;
}
if(keyboardState.IsKeyDown(Keys.Right))
{
    missileLauncherHead.rotation.Y -= 0.05f;
}
if(keyboardState.IsKeyDown(Keys.Up))
{
    missileLauncherHead.rotation.X += 0.05f;
}
if(keyboardState.IsKeyDown(Keys.Down))
{
    missileLauncherHead.rotation.X -= 0.05f;
}
#endif
</code></pre>

<h1>if和#endif之间表示如果不在XBOX情况下。</h1>

<p>其他代码非常的相似，0.05f是个幻数，其实表示了增加量。 这个值是固定的，使得用键盘操作和手柄操作产生了一些差别。</p>

<p>上下左右分别控制两个轴的变化，比手柄更易理解。</p>

<p><strong>3、限定旋转角度。</strong></p>

<p>炮塔的旋转不能任意，不太符合逻辑，所以要把它限定一下，使用MathHelper类，一样在2D教程中详细的讲解了这个类，从3D开始看教程的可以看一下<a href="http://arthraim.cn/post/2009/06/65.html">这篇文章</a>的第二步第3小节和末尾对角度的讲解。</p>

<p>这里要写的代码如下：</p>

<pre><code>missileLauncherHead.rotation.Y = MathHelper.Clamp(
    missileLauncherHead.rotation.Y,
    -MathHelper.PiOver4,
    MathHelper.PiOver4);
missileLauncherHead.rotation.X = MathHelper.Clamp(
    missileLauncherHead.rotation.X,
    0,
    MathHelper.PiOver4);
</code></pre>

<ul>
<li><p>第一次调用限定了rotation的Y轴，也就是左右的范围在-45度到45度之间。</p></li>
<li><p>第二次调用限定了rotation的X轴，也就是上下的范围在0度到45度之间。</p></li>
</ul>


<p>如果你添加了Draw部分的代码，那么现在已经完成了，没有添加，那就是我们下面要做的工作。</p>

<hr />

<p><strong>第三步、绘制炮台</strong></p>

<p>正如之前所说，非常简单的第三步，就是在Draw方法中插入一行代码，和之前的terrain和missleLauncherBase类似的代码。如果你是从第一步跳跃过来的，那么也一样，马上会有效果。</p>

<p>在另外两个GameObject的操作的下面插入代码：</p>

<pre><code>DrawGameObject(missileLauncherHead);
</code></pre>

<p>OK，编译、运行～</p>

<p><a href="/images/uploads/zb/2009-07-07_Runtime.jpg"><img src="/images/uploads/zb/2009-07-07_Runtime.jpg" alt="" /></a></p>

<p>大功告成，炮台可以旋转，并且在一定的范围之内了，试着变化这个范围DIY一下。</p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=161"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>特别说明：</strong>这段翻译，讲解了3D物体在游戏空间中的旋转情况，也就是pitch, yaw, roll三种情况。一样的，在翻译这三个单词的时候带来了一些困扰，权衡后决定翻译成您现在看到的样子，尤其是pitch不太贴切。</p>

<p>（以下文字翻译自XNA Creator Club网站，未经允许禁止转载。由于本人水平有限，所以有任何错误希望高手更正。）</p>

<p><strong>3D空间中的旋转：欧拉旋转</strong></p>

<blockquote><p>任意世界变换矩阵的一个重要组成部分就是旋转。旋转对应了一个对象相对于特定的轴的角度方向。</p>

<p>最终，一个物体的旋转将使用一个级联了&#8221;转换&#8221;（translation）矩阵和&#8221;比例&#8221;（scale）矩阵而约束的世界变化矩阵来决定。</p>

<p>我们在这个教程中使用的方法包括了一系列被叫做欧拉旋转的中间旋转。想象欧拉旋转为一系列的3个不同弧度的角，从0到2π，分别在不同的三个轴上。这些轴（X轴,Y轴,Z轴）可以被想象为低头、偏转、翻转轴（pitch, yaw and roll axes）。</p>

<p><a href="/images/uploads/zb/BG_4.6.2.1pd.png"><img src="/images/uploads/zb/BG_4.6.2.1pd.png" alt="" /></a></p>

<p>低头（picth），根据X轴测量，可以被想象为飞机头的方向向上或向下。</p></blockquote>

<pre><code>    偏转（yaw），根据Y轴测量，使得飞机从一边摆向（swing）另一边。

    翻转（roll），根据Z轴测量，可以想象为飞机翻向（banking）左边或右边。

    （英文中中西表述方式不同，难以理解，图片非常说明问题）
</code></pre>

<blockquote><p>在XNA Framework中使用欧拉旋转来创建世界变换矩阵中的旋转部分，使用Matrix.CreateFromYawPitchRoll方法，传入适当的旋转角度。它确定了一个你可以用来级联&#8221;转换矩阵&#8221;和&#8221;比例矩阵&#8221;的&#8221;旋转矩阵&#8221;，来确定最终&#8221;世界变换矩阵&#8221;。</p></blockquote>

<p><strong>补充说明：</strong>中西方人在操作上存在一些不同的习惯，（当然这不全是因为中西差异决定的，个别人之间也存在习惯的问题。）旋转的控制上也许会不同，所以很多游戏都设置了&#8221;反转X轴&#8221;，&#8221;反转Y轴&#8221;这样的选项。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-08T00:20:07+08:00" pubdate data-updated="true">Jul 8<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch5-render-gameobject/">
		
			XNA教程-3D游戏-05-绘制GameObject</a>
	</h2>
	<div class="entry-content">
		<p>从2D的意识转换到3D游戏的意识之后（也许还有直接接触3D的），之后的工作就和2D一样简单了，想想教程的例子要有什么——加农炮、UFO、炮弹，就是全部了。我们要一个一个的添加到游戏中，但是和2D一样，我们一定会有大量重复的工作，所以我们需要把这些代码封装，所以我们将创建一个具有一般性的类GameObject，来代替所有的加农炮、UFO等等物件的凌乱的代码。</p>

<p><strong>第一步、创建GameObject类</strong></p>

<p>GameObject类究竟有什么好处，烦请大家看下<a href="http://arthraim.cn/view.asp?id=65">这里</a>的末尾《为什么要创建自己的类》这一部分，当然，有过任何OO语言基础的人也知道为什么要封装一个类。</p>

<p>写这个类和2D的如出一辙，一样的我们需要有他的模型Model（sprite）、位置Position、旋转rotation。再加上一个scale属性。至于scale是哪一种，我们这里只是用来缩放模型大小的最最简单的。</p>

<blockquote><p>右键单击工程 -> Add -> New Class -> 命名为GameObject.cs</p></blockquote>

<p>然后修改类为如下代码：</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using Microsoft.Xna.Framework.Net;
using Microsoft.Xna.Framework.Storage;
namespace YourNamespace // 注意修改
{
    class GameObject
    {
        public Model model = null;
        public Vector3 position = Vector3.Zero;
        public Vector3 rotation = Vector3.Zero;
        public float scale = 1.0f;
    }
}
</code></pre>

<p>这样一个通用的GameObject类就简简单单写完了。</p>

<ul>
<li><p>Model为null，防止没有被实例化的情况。</p></li>
<li><p>两个Vector3都为Zero，位置在原点，没有方向。</p></li>
<li><p>scale为1.0f，表示1.0倍的大小。</p></li>
</ul>


<hr />

<p><strong>第二步、应用GameObject到terrain</strong></p>

<p>既然有了GameObject类，我们就应该把它应用到所有的要加入我们的3D世界的模型中，那么terrain也不例外。所以这一步我们稍稍花点时间，把之前写的terrain的代码修改一下，应用GameObject类。之前有3处地方要写，那么现在就有3处地方要改，声明、初始化、绘制。因为绘制还要做其他的修改，所以我们这里先修改声明和初始化部分。</p>

<p>（注释为原先的代码，其他为新编写的代码）</p>

<p><strong>1、声明。</strong>Game1类刚刚开始的地方，声明很多变量的地方。</p>

<pre><code>//Model terrainModel;
//Vector3 terrainPosition = Vector3.Zero;
GameObject terrain = new GameObject();
</code></pre>

<p><strong>2、初始化 。</strong>找到LoadContent()中和terrain有关的部分。</p>

<pre><code>//terrainModel = Content.Load&lt;Model&gt;(@"Modelsterrain");
terrain.model = Content.Load&lt;Model&gt;(@"Modelsterrain");
</code></pre>

<p>这样，terrain就成为了第一个GameObject的应用。接下去。</p>

<hr />

<p><strong>第三步、创建新GameObject，MissleLauncherBase</strong></p>

<p>MissleLauncherBase就是指加农炮的基座，基座是不动的，放在一个固定的位置，我们还是要使用GameObject类来创建他，和terrain是一样的。</p>

<p><strong>1、声明</strong>。Game1类刚刚开始的地方，声明很多变量的地方。</p>

<pre><code>GameObject missleLauncherBase = new GameObject();
</code></pre>

<p><strong>2、初始化 。</strong>找到LoadContent()中和terrain有关的部分。</p>

<pre><code>missleLauncherBase.model = Content.Load&lt;Model&gt;(@"Modelslauncher_base");
missileLauncherBase.scale = 0.2f;
</code></pre>

<p>加上scale的属性，确定缩放。一样把绘制部分交给最后一步统一完成。</p>

<hr />

<p><strong>第四步、绘制GameObject</strong></p>

<p>之前我们绘制过terrain，但是我们使用的是terrainModel这个Model类，和terrainPosition这个Vector3类。现在我们已经将GameObject引入了我们的游戏中，所以我们要重新修改DrawModel方法，我们不需要一个模型一个模型的画，只需要把GameObject这样一个通用的对象，采用一种通用的方法画就可以了。</p>

<p>所以找到DrawModel方法，我们重新写一个DrawGameObject方法（DrawModel方法当然一定用不着了，删掉也行），入参为GameObject。很好，代码如下。</p>

<pre><code>void DrawGameObject(GameObject gameobject)
{
    foreach (ModelMesh mesh in gameobject.model.Meshes)
    {
         foreach (BasicEffect effect in mesh.Effects)
         {
             effect.EnableDefaultLighting();
             effect.PreferPerPixelLighting = true;
             effect.World =
                 Matrix.CreateFromYawPitchRoll(
                     gameobject.rotation.Y,
                     gameobject.rotation.X,
                     gameobject.rotation.Z) *
                 Matrix.CreateScale(gameobject.scale) *
                 Matrix.CreateTranslation(gameobject.position);
             effect.Projection = cameraProjectionMatrix;
             effect.View = cameraViewMatrix;
         }
         mesh.Draw();
    }
}
</code></pre>

<p>不难发现我们对effect.World的初始化发生了一些变化，原本我们只是使用了Matrix.CreateTranslation方法，而现在还添加了两个方法，并且取了三个方法的乘积。这其实就像我<a href="http://arthraim.cn/post/2009/07/74.html">上一章</a>提到过的所有的变化都可以转换为多个变换矩阵的乘积。于是在代码里我们把表示旋转、缩放、位移的三个矩阵相乘，来完成所有这样三个的变化（下面资料中将详细讲解，这三个矩阵被翻译成旋转、比例、转换，其实旋转、缩放、位移更加易于理解）。另外，下一章中，加入加农炮的发射塔，这些参数将变得可控（虽然当前的terrain和missleLauncherBase都是不变的），所以这里依然使用了这样的方式，为了这个方法的通用性。（之后关于此内容还将有官方说明内容）</p>

<p>完成对这个方法的修改，只需要修改Draw方法中的代码就可以了。</p>

<pre><code>DrawGameObject(terrain);
DrawGameObject(missileLauncherBase);
</code></pre>

<p>就这样取代之前的DrawModel的调用，加上两行，每一个GameObject只需要一行的调用。这样绘制工作就算完成了。</p>

<p>运行一下，看看实际效果吧！</p>

<p><a href="/images/uploads/zb/2009-07-05_Runtime.jpg"><img src="/images/uploads/zb/2009-07-05_Runtime.jpg" alt="" /></a></p>

<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=160"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p><strong>特别说明</strong>：这段翻译，其实讲的就是世界变换的3个矩阵的情况，因为rotation scale translation这三个词中文的叫法是什么我不太清楚，所以这里权且翻译成旋转、比例、转换这样子，尤其是转换这个词不太好，不过因为translation真正完成的工作其实就是平移矩阵，相当于坐标轴的转换，所以只取了转换两个字，希望不会对大家理解上产生困扰。</p>

<p>（以下文字翻译自这里，未经允许禁止转载。由于本人水平有限，所以有任何错误希望高手更正。）</p>

<p><strong>翻译：构造世界的变换</strong></p>

<blockquote><p>3D模型由3D建模软件创建。在这些软件包中，美工们创建了3D世界中的模型。这个世界有一个中心，叫做原点，并且模型根据它来创建。位置、旋转和比例都和相对原点相关联，并且当游戏载入一个模型，会保留他的位置、旋转和比例关系。这样，这个模型被称作在“对象空间”或“模型空间”中。</p>

<p>当一个游戏绘制一个模型时，它连接了模型空间中的原点和游戏世界中的原点。如果这个模型在3D建模软件中存储的中心位置正好是模型空间的原点，那在游戏中绘制的时候他就会出现在游戏世界的原点。</p>

<p>当在你的游戏中绘制一个3D模型，你需要把3个变换应用到你的3D模型上。三者中的第一个，“世界转换”，定义如何转换你的模型的初始位置、方向和比例（对象空间）到游戏世界中的某个位置、方向和比例。</p>

<p>一个标准的世界转换分别由三个矩阵组成（旋转、比例和转换），所有的都将被整合成一个世界变换矩阵。</p>

<p>  *</p>

<p>&#8211; “旋转”（rotatiton）变化模型角度的方向——你可以把它想象成在空间中根据一点朝不同的方向旋转模型。有很多计算和存储旋转数值的方法，一种最常用的就是欧拉角，围绕三个轴旋转一个对象，X轴、Y轴和Z轴。（下一节会解释和说明欧拉角）。创建一个旋转矩阵，你可以使用Matrix.CreateFromYawPitchRoll方法，传入围绕各个轴的旋转角度。要存储游戏对象的这些角度，Vector3类是一个很好的选择。</p>

<p>  *</p>

<p>&#8211; “比例”（scale）变化模型的尺寸，使它能更大或更小。因为它可以让模型沿着任意轴拉伸，它更多的被应用到统一的比例，使得整个模型缩小或放大。要创建一个比例矩阵，使用Matrix.CreateScale方法，传入你要缩小或放大模型的因数。你可以存储游戏对象的比例因数为一个简单的float类型。</p>

<p>  *</p>

<p>&#8211; “转换”（translatiton）沿着3D世界的3个轴移动整个模型。想象成到处平移模型：左右移动（X轴），上下移动（Y轴），前后移动（Z轴）。创建一个转换矩阵，使用Matrix.CreateTranslation方法，传入你要沿着各个轴移动的数据。存储转换的数值可以使用Vector3。</p>

<p>一旦你创建了这些矩阵，你必须把它们组合成为一个单独的世界变换矩阵。这个工作被称为级联（concatenation）。在XNA Game Studio中，级联一个矩阵和另一个矩阵，使用乘法符号（*）。你必须使用正确的顺序级联这些矩阵。</p>

<p><em>世界变换 = 旋转 × 比例 × 转换。</em></p></blockquote>

<pre><code>    _World Transformation = Rotation * Scale * Translation_
</code></pre>

<blockquote><p>级联的顺序十分重要。因为矩阵惩罚是没有交换律的，所以用错误的顺序相乘会产生预期之外的结果——比如意外的在旋转之前转换坐标系，相对世界原点旋转了坐标系转换后的模型，使模型到了比起简单的正常旋转后的世界空间中的位置非常非常遥远的其他位置，</p>

<p>修改几次每个独立的变换矩阵传入的数值，你可以是物体在世界中穿过（转换），在空间中旋转（旋转），平滑的缩小或放大，或者三个的组合效果。</p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-05T19:48:03+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>


    <article class="post">
	<h2 class="title">
		
		<a href="/xna-tutorial-3d-ch4-render-3d-titan/">
		
			XNA教程-3D游戏-04-绘制3D地表</a>
	</h2>
	<div class="entry-content">
		<p>安装好环境、建立了XNA工程、添加了要用到的模型以及贴图，那么接下来要做的就是实际的代码了，而一上来就和2D大为不同的是，我们要直接创建我们的&#8221;宇宙环境&#8221;。要知道，在2D游戏中，我们游戏的&#8221;世界&#8221;是整个一张图，就是背景，简单的2D游戏就是这样。而3D则不然，即便是这个环境，那么也是需要我们用模型自己创建的，而这将会是一个非常复杂的工作，究竟如何复杂，看到下面的所有内容你就明白了。</p>

<p>从2D到3D，应该说当前我们在做的是一个非常困难的转换时期，我们要完成第一个3D的绘制，那么就必须了解很多很多只有在3D游戏中才会出现的概念。但是，简单的说，在代码上我们要完成的工作还是类似的，比如2D中，我们先声明了sprite；然后loadContent，或者load确定它的位置等信息；最后我们draw把它绘制出来。那么一样的，3D也是声明、初始化、绘制三个工作。只是2D中无论是初始化还是绘制都是相对简单的，3D就要复杂的多的多，跟着步骤走吧。</p>

<hr />

<p><strong>第一步、创建模型，确定视角</strong></p>

<p>似乎看了标题就有些茫然，有很多的概念要讲，不过和2D教程一样，先直接说代码怎么写，回头再讲大道理。（本文后面将会有官方解释的翻译内容）</p>

<p><strong>1、声明场景模型</strong></p>

<p>代码找到Game1类中最前面，SpriteBatch spriteBatch;这一行的下方，在这里我们先插入这样两行代码。</p>

<pre><code>Model terrainModel;
Vector3 terrainPosition = Vector3.Zero;
</code></pre>

<p>这里用到了XNA Framework提供的Model类，以及Vector类。</p>

<p>显然，terrainModel这样的命名让人比较容易理解，就是场景模型，这是我们的场景或者说是地面模型，都一样，就是我们的大环境。</p>

<p>而terrainPostision就更加容易理解了，是terrain的位置，究竟整个地表是怎样的一个位置。这里我们用Vector3这个类来描述。Vector3是一个3维的向量，就像Vector2是X,Y两个轴的向量一样，Vector3实质上就是把Vector2扩展到X,Y,Z，3个轴的向量。初始化为Vector3.Zero，即在整个3维坐标系的原点上。</p>

<p>和2D游戏不同，我们2D游戏所有涉及到的坐标都是在屏幕范围内的。我们知道屏幕向右是X轴正方向，向下是Y轴正方向，所以所有的坐标都是在这样一个坐标系上想象的。而3D游戏则不同，我们必须把这些位置都想象在自己的脑海中，因为屏幕看见的什么只是你3D世界的一角，你必须在整个思维中存在你的自己的一个三维世界，它所在的一个三维坐标系和它的所有坐标。然后我们再讨论从什么视角（什么坐标）去看这个世界。</p>

<p><strong>2、声明镜头</strong></p>

<p>说明一下，这里的镜头英文应当是camera，翻译成相机这样子比较好。不过也许很多像我一样的游戏玩家会知道，一般我们评价一个游戏，会说镜头能控制不能控制等等，所以我想这个词会更加容易被接受。我的文章里的镜头，指的就是camera。可以想象你的眼睛就是你看这个现实世界的camera。</p>

<p>在刚才两行代码下面，继续写以下内容。</p>

<pre><code>Vector3 cameraPosition = new Vector3(0.0f, 60.0f, 160.0f);
Vector3 cameraLookAt= new Vector3(0.0f, 50.0f, 0.0f);
Matrix cameraProjectionMatrix;
Matrix cameraViewMatrix;
</code></pre>

<p>详细说一下我们做了什么。</p>

<ul>
<li><p>cameraPosition：这是镜头所在的位置，比如我们的眼睛在脸上这样的描述。这里是(0, 60, 160)这样一个位置。</p></li>
<li><p>cameraLookAt：镜头的焦点。可以想象一下terrain被放在Y轴也就是高度轴的0上，镜头被放在Z轴也就是深度轴的160的位置，高度是60的位置，而它看着Y轴上50的那点，连成的直线就是你的视线了。</p></li>
<li><p>cameraProjectionMatrix：镜头投影矩阵。</p></li>
<li><p>cameraViewMatrix：镜头视角矩阵。关于两个矩阵，先不详细讲了。图形学中涉及到了任意点的变换可以使用矩阵，矩阵变换是一个图形学非常重要的概念。稍微讲一下。</p></li>
</ul>


<p>矩阵变换一般情况下有平移、缩放、旋转。各种复杂的变化都可以由很多这样的操作完成。其他还有诸如投影、切割等等。所有的变化都可以最终表示成为一个矩阵，这就是变换矩阵。不详细讲，举3个例子。</p>

<p><strong>例一</strong>：平移 W(wx,wy,wz)</p>

<p><img src="/images/uploads/zb/2009-07-03_Matrix1.jpg" alt="" /></p>

<p><strong>例二</strong>：缩放 T(tx,ty,tz)</p>

<p><img src="/images/uploads/zb/2009-07-03_Matrix2.jpg" alt="" /></p>

<p><strong>例三</strong>：绕X轴旋转alpha度</p>

<p><img src="/images/uploads/zb/2009-07-03_Matrix3.jpg" alt="" /></p>

<p>当然在XNA framework里封装的Matrix类不是一个简单的矩阵的实现了，还加上了很多智能的功能，当然也包括变换，至于如何使用这样一个Matrix，以及我们声明的Matrix是做什么样的变换的，看下去。</p>

<p><strong>3、初始化变换矩阵</strong></p>

<p>我们要初始化声明的资源，那么就要找到LoadContent()方法，在其中TODO的位置加上这样两句。</p>

<pre><code>cameraViewMatrix = Matrix.CreateLookAt(
    cameraPosition,
    cameraLookAt,
    Vector3.Up);
cameraProjectionMatrix = Matrix.CreatePerspectiveFieldOfView(
    MathHelper.ToRadians(45.0f),
    graphics.GraphicsDevice.Viewport.AspectRatio,
    1.0f,
    10000.0f);
</code></pre>

<p>这里做的工作是实例化两个Matrix，但是这里用到了Matrix类中的CreateLookAt和CreatePerspectiveFieldOfView方法。说下参数的意思。</p>

<ul>
<li><p>CreateLookAt：</p>

<ul>
<li><p>cameraPosition：Vector3，镜头所在位置</p></li>
<li><p>cameraLookAt：Vector3，镜头焦点坐标</p></li>
<li><p>Vector3.Up：Vector3，按照MSDN所说传入&#8221;上&#8221;就好，当然你可以试一下其他方向……</p></li>
</ul>
</li>
<li><p>CreatePerspectiveFieldView：</p>

<ul>
<li><p>MathHelper.ToRadians(45.0f)：float，视角大小</p></li>
<li><p>graphics.GraphicsDevice.Viewport.AspectRatio：float，窗口的比率，&#8221;宽&#8221;比上&#8221;长&#8221;的比率</p></li>
<li><p>1.0f：float，镜头最小深度（近处）</p></li>
<li><p>10000.0f：float，镜头最大深度（远处）（恐怕真三国无双和GTA这样的游戏里面这个参数的体会会比较深刻）</p></li>
</ul>
</li>
</ul>


<p>初始化完毕，就可以接下去继续了。</p>

<hr />

<p><strong>第二步、编写模型绘制方法</strong></p>

<p>因为游戏中将会出现很多很多的模型，虽然每一个模型都有其特殊的地方，但是每一个模型都将拥有一个默认的绘制方式。而，即便采用默认的方式，绘制模型也将会涉及到很多操作，所以将本来可以在draw方法中完成的内容单独的写一个方法来完成。方法传入的参数为模型和其所在的位置，这样我们的方法就可以把它用一样的操作绘制出来。</p>

<p>这里涉及到一个ModelMesh的类，每一个Model都一个很多的ModelMesh的集合，因此我们需要单独绘制每一个mesh。至于ModelMesh和Model的概念，在后面会加上说明。（本文后面将会有官方解释的翻译内容）</p>

<p>具体方法是，在Game1类中重新写一个方法，当然是任意位置的，代码具体如下。</p>

<pre><code>void DrawModel(Model model, Vector3 modelPosition)
{
    foreach (ModelMesh mesh in model.Meshes)
    {
        foreach (BasicEffect effect in mesh.Effects)
        {
            effect.EnableDefaultLighting();
            effect.PreferPerPixelLighting = true;
            effect.World = Matrix.CreateTranslation(modelPosition);
            effect.Projection = cameraProjectionMatrix;
            effect.View = cameraViewMatrix;
        }
        mesh.Draw();
    }
}
</code></pre>

<p>如参正如之前所说，一个是Model类，一个是Vector3类，分别表示要绘制的模型和其所在的位置。</p>

<ul>
<li><p>第一个foreach循环是遍历Model中所有的ModelMesh，单独处理每一个。</p></li>
<li><p>第二个foreach循环是遍历ModelMesh中的Effects，单独处理每一个效果的处理。具体看看做了一些什么</p>

<ul>
<li><p>EnableDefaultLighting()：设定光源为默认光源。</p></li>
<li><p>effect.PreferPerPixelLighting = true;：在支持Pixel Shader Model 2.0的情况下，开启每个像素按光源渲染的效果。</p></li>
<li><p>effect.World = Matrix.CreateTranslation(modelPosition);：创建传入模型的矩阵变换</p></li>
<li><p>effect.Projection = cameraProjectionMatrix;：设定投影变换矩阵。</p></li>
<li><p>effect.View = cameraViewMatrix;：设定视角变换矩阵。</p></li>
</ul>
</li>
</ul>


<p>这样，我们就完成了绘制方法的编写。但是不要忘了，我们还没有加载需要绘制的模型，也没有在draw方法中调用这个方法，所以看接下去的两步，完成这两个工作。</p>

<hr />

<p><strong>第三步、加载模型</strong></p>

<p>载入模型才能画，载入模型的方法和2D的一模一样，只是一个操作的是Sprite，一个操作的是Model，但是我们知道LoadContent方法是支持范型的，那么显然我们的工作就变得非常的简单了。</p>

<p>找到LoadContent方法，在之前添加的代码下面加上如下代码。</p>

<pre><code>terrainModel = Content.Load&lt;Model&gt;(@"Modelsterrain");
</code></pre>

<p>这样，这一步就简简单单的完成了。</p>

<hr />

<p><strong>第四步、绘制模型</strong></p>

<p>之前第二步完成的工作就大大简化了这一步我们的代码了。而这一步我们就只要调用之前我们写的drawModel方法，并且传入我们的模型和位置就可以了。</p>

<p>在Draw方法的TODO处，加入以下代码：</p>

<pre><code>DrawModel(terrainModel, terrainPosition);
</code></pre>

<p>还等什么呢？现在就是编译运行的时候了！效果图。</p>

<p><a href="/images/uploads/zb/2009-07-03_Runtime.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime.jpg" alt="" /></a></p>

<p>下面加了4张修改了参数之后的图，方便理解一些参数。[点击放大]</p>

<p><a href="/images/uploads/zb/2009-07-03_Runtime_Down.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_Down.jpg" alt="" /></a> <a href="/images/uploads/zb/2009-07-03_Runtime_100CameraHeight.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_100CameraHeight.jpg" alt="" /></a> <a href="/images/uploads/zb/2009-07-03_Runtime_95Radians.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_95Radians.jpg" alt="" /></a> <a href="/images/uploads/zb/2009-07-03_Runtime_5000Depth.jpg"><img src="/images/uploads/zb/2009-07-03_Runtime_5000Depth.jpg" alt="" /></a></p>

<ul>
<li><p>cameraViewMatrix实例化，CreateLookAt时，修改第三个参数为Vector3.Down</p></li>
<li><p>cameraPosition声明并实例化时，修改为Vector3(0.0f, 100.0f, 160.0f)</p></li>
<li><p>cameraProjectionMatrix实例化，CreatePerspectiveFieldOfView时，修改第一个参数为90.0f</p></li>
<li><p>cameraProjectionMatrix实例化，CreatePerspectiveFieldOfView时，修改第四个参数为5000.0f</p></li>
</ul>


<p>【官方源代码下载】</p>

<p><a href="http://creators.xna.com/downloads/?id=159"><img src="/images/uploads/zb/2009-06-12_download_XNA.png" alt="" /></a></p>

<hr />

<p>那么下面就贴翻译的内容，也算是比较重要的东西了，2D和3D游戏的概念上的区别。</p>

<p>（以下翻译为本人原传，未经允许严禁转载。另外，因本人能力有限难免出错，请高手指正。原址点击<a href="http://creators.xna.com/en-US/education/gettingstarted/bg3d/details/4_1">这里</a>。）</p>

<p><strong>1、3D世界：2D游戏和3D游戏之间的区别</strong></p>

<blockquote><p>如果你学习过第一个教程（创建2D游戏），那么你已经变得习惯用2D空间来思维了。位置、方向和动作可以全都用Vector2和一个单独的旋转角度来表示。</p>

<p>这个教程介绍了在三维的概念，和其一系列的新的对象。从根本上，3D世界区别于2D世界的就是新增的第三个坐标轴&#8212;-Z轴，或者说是深度。在XNA Game Studio中，2D世界实质上是一个特殊的，受限制的3D世界的版本&#8212;-你将会在本教程读到的计算也同样在2D中可以读到。</p>

<p>在XNA Game Studio这哦你，3D的变化意味着，取代在平面世界中画静态的Texture2D对象的是绘制用Model类表示的3D模型。Model类是被叫做网络（mesh）的许多有联系的3D点的集合，在整个世界中，最终渲染在屏幕上的对象，取决于对象的位置和方向，和镜头的位置和方向。</p>

<p><a href="/images/uploads/zb/BG_4.4.1.1pd.png"><img src="/images/uploads/zb/BG_4.4.1.1pd.png" alt="" /></a>这过程也许初看十分复杂，但其实在3D世界编程，只依靠一些非常基本的元素。想象一个点在3D空间中，一个点有一个X坐标,一个Y坐标,和一个Z坐标。非常类似2D空间中的一个点，3D空间中的一个点也可以使用一个向量来移动，但是在3D空间中，我们使用包含Z坐标的Vector3类。</p>

<p>然而，使用一个叫做矩阵的数学结构体，可以使3D点做更多的事情。这些结构体，在XNA Framework中表示为Matrix类，它描述了一系列可以应用于点的变换、点的集合、或一个响亮。使用矩阵，3D对象可以移动、旋转、切割、以及（通过使用被叫做视点矩阵和投影矩阵的特殊的矩阵）绘制成一个可以显示在屏幕上的2D图像。</p>

<p>想象有一系列我们想画在屏幕上的3D世界中的点。它们拥有相对于被叫做原点的中心点的位置和方向信息。如果没有任何的变换，这些点只是存在于他们自己的空间，被叫做&#8221;对象空间&#8221;。</p>

<p>当你加载一系列的点，并且把它们添加到你的3D世界中，你可能会想给他们一个在3D世界中的位置，用来旋转或切割他们。这些行动的产物被叫做世界变换矩阵。应用了这样的矩阵的点，就被想象成在&#8221;世界空间&#8221;中（而不是对象空间中）了。</p>

<p>来渲染在用户屏幕上的点，需要一些附加的信息。没有要绘制的2D场景的角度和位置，是不可能把整个3D常见转换到2D图像的。使用一个视点是必要的，也被称作镜头，只需绘制它所看到的3D场景。在准备这次绘制时，镜头信息会被计算到一个视角矩阵中，把3D点的方向和位置都和镜头联系起来。之后，这些3D点就被想象成在&#8221;视觉空间&#8221;中了。</p>

<p>用2D绘制一个3D场景最后还需要一些其他信息。像视点的视角和领域的信息，控制着3D点如何绘制在2D计算机屏幕上。这些信息存储在一个投影矩阵中，应用之后，把3D坐标的系统中的点转换到2D坐标系统中，2D坐标系统被成为&#8221;屏幕空间&#8221;，这样点被绘制成像素。</p>

<p><a href="/images/uploads/zb/BG_4.4.1.2pd.png"><img src="/images/uploads/zb/BG_4.4.1.2pd.png" alt="" /></a></p>

<p>如果要套用这个概念到3D点的集合所组成的网络（mesh）上（可以是3D表示的任何东西，一个飞船、一个人、或一只恐龙），你只需用到一些在XNA Framework中的基本的对象来制作你的游戏&#8212;-Mesh类，Matrix类和Vector类。</p></blockquote>

<p><strong> 2、创建一个模型绘制方法</strong></p>

<blockquote><p>绘制一个3D模型到屏幕上是一个复杂的工作。它包括了庞大数据量的多边形的绘制，而它们经常被构造成许多不同的方式。有些可能是基于艺术效果的，而有些也许是倾向于程序化的。绘制同时也是必要的工作。每个游戏中可见的3D对象都是需要经过一个绘制过程的。</p>

<p>毫无悬念的，不是只有一种组织一个模型绘制方法的方式。参数、界限以及绘制算法对每个游戏来说都是不同的，取决于游戏的需求和涉及的技术。在这样的情况下，XNA Framewrok没有尝试去提供一个单独的模型绘制方法。取而代之的是提供一些元素，而把组织它们的工作留给了程序员来做。</p>

<p>一个Model类是XNA Framework中表示3D模型的一个基本对象，但是它比最初的模型要复杂许多。一个模型由一个或多个ModelMesh对象以一个集合的形式组成。每个ModelMesh对象是一系列组成网络（mesh）的顶点的集合，它们可以在同一个模型中被单独的移动。</p>

<p>一个坦克的模型是一个很好的例子。坦克的身体也许是一个ModelMesh，坦克的炮台也许是另外一个。虽然你绘制的是整个坦克，但是你可能需要分开移动坦克的不同部分。你可以使用ModelMesh对象的集合来移动不同的部分。</p>

<p>ModelMesh包含了一个绘制方法。每绘制一个ModelMesh到屏幕上需要调用这个方法一次。然而如果你没有实现设定变换和MedelMesh上的光的属性，那么你什么也看不到。</p>

<p>变换（决定了ModelMesh在世界中的定向，并且最终，物体是否出现或是出现在屏幕的哪里）和光（）没有被应用到ModelMesh层面。相对的，每个ModelMesh有一些Effect和它联系在一起。一个Effect对象可以想成提供给可视设备的说明，关于如何绘制一个ModelMesh。</p>

<p>在很多游戏中，Effect对象是由很多复杂的顶点和像素遮罩（shader）组成的。在XNA Game Studio中也可以实现，并且对于高级图形效果来说十分重要。但是在简单的渲染中，XNA Framework Content Pipline（内容管道）提供了一个简单的机制来完成基本的光和绘制效果 &#8212;- BasicEffect类。</p>

<p>每个通过content pipline加载的ModelMesh接受了一个或多个BasicEffect对象，它们可以在不处理像素或顶点遮罩（shader）的情况下简单的处理变换和光源效果。所有这些BasicEffect类需要一系列表示世界（World）矩阵，视点（View）矩阵和投影（Projection）矩阵的Matrix类，和一些光照的参数。可以调用BasicEffect.EnableDefaultLighting()方法获得默认的参数。</p>

<p>在BasicEffect的参数被设置后，剩下的就只有调用ModelMesh.Draw方法，使用之前为BasicEffect设置的参数，来绘制ModelMesh到屏幕上了。</p>

<p><a href="/images/uploads/zb/BG_4.4.2.1pd.png"><img src="/images/uploads/zb/BG_4.4.2.1pd.png" alt="" /></a></p></blockquote>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2009-07-04T03:50:05+08:00" pubdate data-updated="true">Jul 4<span>th</span>, 2009</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/programing/'>Programing</a>


</div>
	
</div></article>

<nav id="pagenavi">
    
        <a href="/blog/page/14/" class="prev">Prev</a>
    
    
        <a href="/blog/page/16/" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
	<footer id="footer" class="inner">Copyright &copy; 2013

    Arthur Wang

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'artorius';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-8352384-7']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>