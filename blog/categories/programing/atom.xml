<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programing | Artoirus]]></title>
  <link href="http://artori.us/blog/categories/programing/atom.xml" rel="self"/>
  <link href="http://artori.us/"/>
  <updated>2013-06-19T09:34:27+08:00</updated>
  <id>http://artori.us/</id>
  <author>
    <name><![CDATA[Arthur Wang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[WWDC: 2013 session 404 advances in objective-c]]></title>
    <link href="http://artori.us/wwdc-2013-session-404-advances-in-objective-c/"/>
    <updated>2013-06-18T10:27:00+08:00</updated>
    <id>http://artori.us/wwdc-2013-session-404-advances-in-objective-c</id>
    <content type="html"><![CDATA[<p>看了几个WWDC的session，做了一些笔记，简单贴在博客上吧。</p>

<p>404这个session大概说了objective-c的一些变化，和去年比起来改动实在是不多。</p>

<h3>module</h3>

<p>这个改动比较引人瞩目，简单说就是写#import的时候改成@import。#include是复制粘帖，#import是#define保护下复制粘帖，@import则用了一个结构去维护。</p>

<p>在工程设置里，把「Enable Modules (C and Objective-C)」设为YES，不用改代码就能自动生效。会提高编译和索引的速度。</p>

<p>有一句话很刺眼叫「not available for user frameworks」，呵呵。</p>

<p>另外随之而来的Auto Linking特性，你不用自己去加那些依赖了。</p>

<h3>refactor tools</h3>

<p>重构工具什么的，然后又提了提literals的语法什么的。说起后者今天看到<a href="http://nshipster.com/object-subscripting/">一篇文章</a>，把object subscripting（这货就是比如说array[@3], dictionary[@"key"]这样）扩展成一门DSL。</p>

<h3>instancetype</h3>

<p>这个改动我觉得挺重要。以前方法（尤其init）返回一个指针的时候用<code>id</code>作为类型。编译器其实很难（几乎不能）对它的类型作出判断。新增这个instancetype来声明返回值类型，可以避免很多不安全的问题。</p>

<p>比如Foo的init方法返回一个NSArray，调用的时候写成<code>NSDictionary *dict = [[Foo alloc] init];</code>。如果init方法是<code>-(id)init</code>，那编译器啥也不知道。如果改写成<code>-(instancetype)init</code>，xcode会警告你这里类型有问题了。</p>

<h3>explicitly-typed enums</h3>

<p><code>cell.selectionStyle = UITableViewCellAccessoryCheckmark</code>这种不同枚举类型的赋值会得到一个警告了。另外xcode的自动完成也更智能了。别忘了用<code>NS_ENUM</code>这个宏来写枚举哟。</p>

<h3>runtime</h3>

<p>有一些改动，比如新的tagged pointer，以及使用isa的警告等等。下一节还提到了一些retain环的警告等等等等。</p>

<h3>GC -> ARC</h3>

<p>苹果不要GC了，都用ARC了，包括Xcode 5在内的一些工程都放弃GC了。</p>

<p>另外ARC还有些进化。<code>__weak</code>更快了，说是x2快。dubug的<code>autorelease</code>处理更接近release build了。</p>

<h3>CF bridge</h3>

<p>CoreFoundation框架的桥也全都优化了，提到implicit bridging的时候全场掌声，本人level太低不理解什么意思。</p>

<p>笔记大概就是这些，感觉很多都没怎么听懂，还需要补课。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速使用uwsgi部署]]></title>
    <link href="http://artori.us/easy-deploy-with-uwsgi/"/>
    <updated>2013-04-14T01:02:00+08:00</updated>
    <id>http://artori.us/easy-deploy-with-uwsgi</id>
    <content type="html"><![CDATA[<p>之前尝试在阿里云部署一个bottle.py写的web服务，选择了unbuntu12.04，一穷二白的ubuntu上用uwsgi部署还挺简单的。这里简单记录一下。</p>

<p>先要改一改程序代码，声明一个application</p>

<p><code>py
application = bottle.app()
</code></p>

<p>然后安装uwsgi，demo.py就是修改过的bottle的代码。</p>

<p>这里我遇到了<code>— unavailable modifier requested: 0 --</code>，要安装uwsgi-plugin-python，并且uwsgi启动时候添加<code>--plugin python</code></p>

<p>一些uwsgi的操作看<a href="http://uwsgi-docs.readthedocs.org/en/latest/Management.html">这里</a></p>

<p><code>sh
apt-get install uwsgi uwsgi-plugin-python
uwsgi --socket :8000 --plugin python --file demo.py --processes 4 --pidfile /tmp/demo.pid --touch-reload=/tmp/restart -d uwsgi.log
</code></p>

<p>安装nginx</p>

<p><code>sh
apt-get install libpcre3 libpcre3-dbg libpcre3-dev
apt-get install zlib1g zlib1g-dbg zlib1g-dev
apt-get install make
cd /path/to/nginx
./configure
make
make install
</code></p>

<p>最后配置nginx。默认安装路径在<code>/usr/local/nginx/conf/nginx.conf</code></p>

<p>```js
server {</p>

<pre><code>listen       80;
server_name  demo.artori.us;

location /static/ { alias /home/root/demo/static/; }

location / {
    uwsgi_pass      127.0.0.1:8000;
    include         uwsgi_params;
}
</code></pre>

<p>}
```</p>

<p>自此搞定</p>

<p>via:</p>

<ul>
<li><a href="http://stackoverflow.com/questions/10748108/nginx-uwsgi-unavailable-modifier-requested-0">http://stackoverflow.com/questions/10748108/nginx-uwsgi-unavailable-modifier-requested-0</a></li>
<li><a href="http://lists.unbit.it/pipermail/uwsgi/2011-November/002923.html">http://lists.unbit.it/pipermail/uwsgi/2011-November/002923.html</a></li>
<li><a href="http://aaronsnow.tumblr.com/post/11560674160/nginx-uwsgi-bottle-py">http://aaronsnow.tumblr.com/post/11560674160/nginx-uwsgi-bottle-py</a></li>
<li><a href="https://groups.google.com/forum/?fromgroups=#!topic/bottlepy/wRfgm4obLXk">https://groups.google.com/forum/?fromgroups=#!topic/bottlepy/wRfgm4obLXk</a></li>
<li><a href="http://blog.felixc.at/2011/01/ubuntu-uwsgi-nginx-bottle-configuration/">http://blog.felixc.at/2011/01/ubuntu-uwsgi-nginx-bottle-configuration/</a></li>
<li><a href="http://apt-blog.net/moinmoin-on-nginx-via-fastcgi-and-uwgi">http://apt-blog.net/moinmoin-on-nginx-via-fastcgi-and-uwgi</a></li>
<li><a href="http://down.chinaz.com/server/201112/1467_1.htm">http://down.chinaz.com/server/201112/1467_1.htm</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIWebView加载本地资源]]></title>
    <link href="http://artori.us/uiwebview-load-local-javascript/"/>
    <updated>2013-03-27T18:19:00+08:00</updated>
    <id>http://artori.us/uiwebview-load-local-javascript</id>
    <content type="html"><![CDATA[<p>作为一个不会javascript只会jQuery的程序员，我在做<a href="https://github.com/Arthraim/objs">Objective-c和HTML5页面交互的demo</a>的时候需要HTML至少依赖一个jQuery，放在本地咋整？</p>

<h2>创建UIWebView的时候</h2>

<p>```objective-c
_webView = [[UIWebView alloc] initWithFrame:CGRectMake(0,0,self.view.bounds.size.width,self.view.bounds.size.height)];
NSString <em>htmlFile = [[NSBundle mainBundle] pathForResource:@"index" ofType:@"html"];
NSString</em> htmlString = [NSString stringWithContentsOfFile:htmlFile encoding:NSUTF8StringEncoding error:nil];</p>

<p>NSString <em>path = [[NSBundle mainBundle] bundlePath];
NSURL </em>baseURL = [NSURL fileURLWithPath:path];</p>

<p>[<em>webView loadHTMLString:htmlString baseURL:baseURL];
// 把baseURL知道bundle的Url，就能调用bundle里的其他文件了，图片音乐什么的
[self.view addSubview:</em>webView];
[_webView release];
```</p>

<h2>添加.js文件的时候</h2>

<p>添加js文件有点特殊，xcode会以为js是可以编译的代码。要在Xcode的target里，把.js文件从 "Compile Sources" 移到 "Copy Bundle Resources" .</p>

<h2>写HTML的时候</h2>

<p>可以直接写相对路径了。<code>&lt;script src="jquery.min.js"&gt;&lt;/script&gt;</code></p>

<p><strong>题外话1</strong>: 有个基友要做一个HTML5播放视频的东东，想把视频缓存到本地，但是UIWebView无视HTML5 mainifest里指定的音频视频文件，还有5M的限制。其实也可以存下来本地加载撒。</p>

<p><strong>题外话2</strong>: objc可以用stringByEvaluatingJavaScriptFromString:在webview里执行脚本。js要调用objective-c就比较麻烦。iOS可行的办法是利用custom URL scheme，跳转到应用之后应用或从path或从querystring来判断js要调用什么类什么方法，比较蛋疼。最理想的方式应该是<a href="https://developer.apple.com/library/mac/#documentation/AppleApplications/Conceptual/SafariJSProgTopics/Tasks/ObjCFromJavaScript.html">safari插件支持的方式</a>，可惜iOS没有。</p>

<p>via:</p>

<ul>
<li><a href="https://devforums.apple.com/message/32282">https://devforums.apple.com/message/32282</a></li>
<li><a href="http://mentormate.com/blog/iphone-uiwebview-class-local-css-javascript-resources/">http://mentormate.com/blog/iphone-uiwebview-class-local-css-javascript-resources/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bottle直接返回pymongo查询结果]]></title>
    <link href="http://artori.us/bottle-autojson-with-pymongo/"/>
    <updated>2012-12-19T10:32:00+08:00</updated>
    <id>http://artori.us/bottle-autojson-with-pymongo</id>
    <content type="html"><![CDATA[<p>以前提到过<a href="/bottle-i-love-this-framework/">bottle</a>，也写过在<a href="/use-mongodb-with-django/">django里使用pymongo</a>，这次是在bottle里用pymongo。</p>

<p>bottle有类似ROR的一些特性，比如处理请求的时候直接return一个字典，框架会自动把它parse成json（autojson）。</p>

<p>我是想偷个懒来着，把代码写成了下面这样。</p>

<p>```py
@get('/api/today')
def api_today():</p>

<pre><code>udid = request.GET.get('udid')
return self.coll.find_one({'udid':udid, 'date':today})
</code></pre>

<p>```</p>

<p>这会有问题，因为find_one返回的bson没办法直接parse。伟大的发明都是在偷懒的时候诞生的，看起来我要做的事情也很简单，只要能让我改一改parser就行了。</p>

<ol>
<li>写一个dump方法替换原来JSONPlugin里的</li>
<li>设置Bottle app的autojson为False。<code>Bottle(autojson=False)</code></li>
<li>把有自己dump方法的JSONPlugin给install到app里</li>
</ol>


<p>```py
class MongoEncoder(JSONEncoder):</p>

<pre><code>def mongo_dumps(obj):
    # convert all iterables to lists
    if hasattr(obj, '__iter__'):
        return list(obj)
    # convert cursors to lists
    elif isinstance(obj, pymongo.cursor.Cursor):
        return list(obj)
    # convert ObjectId to string
    elif isinstance(obj, bson.objectid.ObjectId):
        return unicode(obj)
    # dereference DBRef
    elif isinstance(obj, bson.dbref.DBRef):
        return db.dereference(obj) # db is the incetance database
    # convert dates to strings
    elif isinstance(obj, datetime.datetime) or isinstance(obj, datetime.date) or isinstance(obj, datetime.time):
        return unicode(obj)
    return json.JSONEncoder.default(self, obj)
</code></pre>

<p>app = app()
app.autojson = False
m_encoder = MongoEncoder()
app.install(JSONPlugin(json_dumps=lambda s: dumps(s, default=m_encoder.mongo_dumps)))
```</p>

<p>via:</p>

<ul>
<li><a href="https://github.com/defnull/bottle/issues/287">https://github.com/defnull/bottle/issues/287</a></li>
<li><a href="https://gist.github.com/2779820">https://gist.github.com/2779820</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异或]]></title>
    <link href="http://artori.us/exclusive-or/"/>
    <updated>2012-12-13T12:36:00+08:00</updated>
    <id>http://artori.us/exclusive-or</id>
    <content type="html"><![CDATA[<p>不介绍什么是异或了，有人叫半加、数学系的叫按位模2加</p>

<p>下文用得到的一些简单的性质</p>

<ul>
<li><p><code>x^0 = x</code> 且 <code>x^x = 0</code></p></li>
<li><p>交换律：<code>x^y = y^x</code></p></li>
<li><p>结合律：<code>(x^y)^z = x^(y^z)</code></p></li>
<li><p>自反性：<code>x^y^y = x</code></p></li>
</ul>


<p>下面是几个小题目，可以用异或解决，挺有技巧性</p>

<h2>交换两个数ab</h2>

<p><code>ruby
a = a^b
b = a^b
a = a^b
</code></p>

<p>有意思的是搜索其他异或例子的时候，发现了<a href="http://blog.chinaunix.net/uid-1844931-id-3034714.html">这篇</a>文章，文章里实现了一个异或交换的算法，和本文主题无关，不过很有意思，函数更多的时候应该只操作值而不是变量。</p>

<p><strong>UPDATE_2013-05-06</strong>: 这个，看到云风写了一个利用这个特性做的<a href="http://blog.codingnow.com/2013/05/xor_linked_list.html">双向链表</a>，挺好玩，忍不住写过来。</p>

<h2>A集合里拿掉数x得到B集合，求x</h2>

<p>令<code>XOR(X)</code>表示将X集合内所有的数做异或</p>

<p><code>XOR(B)^XOR(A) = XOR(B)^XOR(B)^x = 0^x = x</code></p>

<p><code>ruby
A = (1..10000).to_a
B = A - [1234]
x = (A + B).reduce(&amp;:^)
puts x #1234
</code></p>

<p>via: <a href="http://www.javaeye.com/topic/420487">http://www.javaeye.com/topic/420487</a></p>

<h2>A集合里拿掉数x、y得到B集合，求x和y</h2>

<p>首先按上一个的办法可以推导出<code>xor(A)^xor(B) = xor(B)^xor(B)^x^y = 0^x^y = x^y</code></p>

<p><code>x^y</code>的二进制结果，第n位为1，说明x和y的第n位不相同</p>

<p>根据第n位是否为0把A里所有的数分成A1和A0两个数组（A1里的数的二进制第n位都是1，A0都是0）</p>

<p>A1和A0应该各包含了a或者b（这样第n位才能异或出1）</p>

<p>同理可以把B分成B1和B0两个数组</p>

<p>可以得到第一个数 <code>x = A1^B1</code></p>

<p>第二个数可以<code>y = A0^B0</code>，当然也可以用<code>x^y^x</code>求得</p>

<p>另外如果<code>x^y</code>为0，即<code>x == y</code>，令<code>SUM(X)</code>为X集合内所有数求和</p>

<p><code>(SUM(A) - SUM(B)) / 2 = x</code></p>

<p>via: <a href="http://blog.chinaunix.net/uid-12453618-id-2935334.html">http://blog.chinaunix.net/uid-12453618-id-2935334.html</a></p>

<h2>集合A里只有数x出现1次，其余数全都重复出现2次，求x</h2>

<p><code>xor(A) = x^y^y^…^z^z = x^(y^y^…^z^z) = x^0 = x</code></p>

<p><code>ruby
x = A.reduce(&amp;:^)
</code></p>

<h2>集合A里只有数x出现1次，其余数全都重复出现3次，求x</h2>

<p>xor的本质相当于“按位模2加”（adding modulo 2），令p1,p2…pn为布尔值，true为1、false为0，(+)表示异或操作。</p>

<p><code>p1 (+) p2 (+) ... (+) pn == ( p1 + p2 + ... + pn ) % 2</code></p>

<p>所以只需要实现按位模3加</p>

<p><code>( p1 + p2 + ... + pn ) % 3</code></p>

<p>将集合中所有数二进制表示的同一位的0或1相加，最终的和对3去摸，得到的数即是x</p>

<p>如 <code>A = {5, 7, 7, 7}</code>，二进制表示两个数</p>

<p>```ruby
  101
  111
  111</p>

<h2>+ 111</h2>

<p>  434</p>

<h2>%   3</h2>

<p>  101
```
但愿这坨东西能让人看懂</p>

<p>via: <a href="http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/xor.html">http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/xor.html</a></p>

<h2>没有<code>^</code>操作时候实现异或，只用<code>&amp;</code>与 <code>|</code>或 <code>~</code>非</h2>

<p>这里的转换有很多，比如下面这个</p>

<p><code>x ^ y == (~x &amp; y) | (x &amp; ~y)</code></p>

<p>具体查看<a href="http://en.wikipedia.org/wiki/Exclusive_or">维基百科</a> 《Equivalencies, elimination, and introduction》部分，各种公式</p>
]]></content>
  </entry>
  
</feed>
