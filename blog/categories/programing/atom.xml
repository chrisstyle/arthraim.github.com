<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programing | Artoirus]]></title>
  <link href="http://artori.us/blog/categories/programing/atom.xml" rel="self"/>
  <link href="http://artori.us/"/>
  <updated>2013-05-06T09:33:03+08:00</updated>
  <id>http://artori.us/</id>
  <author>
    <name><![CDATA[Arthur Wang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[快速使用uwsgi部署]]></title>
    <link href="http://artori.us/easy-deploy-with-uwsgi/"/>
    <updated>2013-04-14T01:02:00+08:00</updated>
    <id>http://artori.us/easy-deploy-with-uwsgi</id>
    <content type="html"><![CDATA[<p>之前尝试在阿里云部署一个bottle.py写的web服务，选择了unbuntu12.04，一穷二白的ubuntu上用uwsgi部署还挺简单的。这里简单记录一下。</p>

<p>先要改一改程序代码，声明一个application</p>

<p><code>py
application = bottle.app()
</code></p>

<p>然后安装uwsgi，demo.py就是修改过的bottle的代码。</p>

<p>这里我遇到了<code>— unavailable modifier requested: 0 --</code>，要安装uwsgi-plugin-python，并且uwsgi启动时候添加<code>--plugin python</code></p>

<p>一些uwsgi的操作看<a href="http://uwsgi-docs.readthedocs.org/en/latest/Management.html">这里</a></p>

<p><code>sh
apt-get install uwsgi uwsgi-plugin-python
uwsgi --socket :8000 --plugin python --file demo.py --processes 4 --pidfile /tmp/demo.pid --touch-reload=/tmp/restart -d uwsgi.log
</code></p>

<p>安装nginx</p>

<p><code>sh
apt-get install libpcre3 libpcre3-dbg libpcre3-dev
apt-get install zlib1g zlib1g-dbg zlib1g-dev
apt-get install make
cd /path/to/nginx
./configure
make
make install
</code></p>

<p>最后配置nginx。默认安装路径在<code>/usr/local/nginx/conf/nginx.conf</code></p>

<p>```js
server {</p>

<pre><code>listen       80;
server_name  demo.artori.us;

location /static/ { alias /home/root/demo/static/; }

location / {
    uwsgi_pass      127.0.0.1:8000;
    include         uwsgi_params;
}
</code></pre>

<p>}
```</p>

<p>自此搞定</p>

<p>via:</p>

<ul>
<li><a href="http://stackoverflow.com/questions/10748108/nginx-uwsgi-unavailable-modifier-requested-0">http://stackoverflow.com/questions/10748108/nginx-uwsgi-unavailable-modifier-requested-0</a></li>
<li><a href="http://lists.unbit.it/pipermail/uwsgi/2011-November/002923.html">http://lists.unbit.it/pipermail/uwsgi/2011-November/002923.html</a></li>
<li><a href="http://aaronsnow.tumblr.com/post/11560674160/nginx-uwsgi-bottle-py">http://aaronsnow.tumblr.com/post/11560674160/nginx-uwsgi-bottle-py</a></li>
<li><a href="https://groups.google.com/forum/?fromgroups=#!topic/bottlepy/wRfgm4obLXk">https://groups.google.com/forum/?fromgroups=#!topic/bottlepy/wRfgm4obLXk</a></li>
<li><a href="http://blog.felixc.at/2011/01/ubuntu-uwsgi-nginx-bottle-configuration/">http://blog.felixc.at/2011/01/ubuntu-uwsgi-nginx-bottle-configuration/</a></li>
<li><a href="http://apt-blog.net/moinmoin-on-nginx-via-fastcgi-and-uwgi">http://apt-blog.net/moinmoin-on-nginx-via-fastcgi-and-uwgi</a></li>
<li><a href="http://down.chinaz.com/server/201112/1467_1.htm">http://down.chinaz.com/server/201112/1467_1.htm</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIWebView加载本地资源]]></title>
    <link href="http://artori.us/uiwebview-load-local-javascript/"/>
    <updated>2013-03-27T18:19:00+08:00</updated>
    <id>http://artori.us/uiwebview-load-local-javascript</id>
    <content type="html"><![CDATA[<p>作为一个不会javascript只会jQuery的程序员，我在做<a href="https://github.com/Arthraim/objs">Objective-c和HTML5页面交互的demo</a>的时候需要HTML至少依赖一个jQuery，放在本地咋整？</p>

<h2>创建UIWebView的时候</h2>

<p>```objective-c
_webView = [[UIWebView alloc] initWithFrame:CGRectMake(0,0,self.view.bounds.size.width,self.view.bounds.size.height)];
NSString <em>htmlFile = [[NSBundle mainBundle] pathForResource:@"index" ofType:@"html"];
NSString</em> htmlString = [NSString stringWithContentsOfFile:htmlFile encoding:NSUTF8StringEncoding error:nil];</p>

<p>NSString <em>path = [[NSBundle mainBundle] bundlePath];
NSURL </em>baseURL = [NSURL fileURLWithPath:path];</p>

<p>[<em>webView loadHTMLString:htmlString baseURL:baseURL];
// 把baseURL知道bundle的Url，就能调用bundle里的其他文件了，图片音乐什么的
[self.view addSubview:</em>webView];
[_webView release];
```</p>

<h2>添加.js文件的时候</h2>

<p>添加js文件有点特殊，xcode会以为js是可以编译的代码。要在Xcode的target里，把.js文件从 "Compile Sources" 移到 "Copy Bundle Resources" .</p>

<h2>写HTML的时候</h2>

<p>可以直接写相对路径了。<code>&lt;script src="jquery.min.js"&gt;&lt;/script&gt;</code></p>

<p><strong>题外话1</strong>: 有个基友要做一个HTML5播放视频的东东，想把视频缓存到本地，但是UIWebView无视HTML5 mainifest里指定的音频视频文件，还有5M的限制。其实也可以存下来本地加载撒。</p>

<p><strong>题外话2</strong>: objc可以用stringByEvaluatingJavaScriptFromString:在webview里执行脚本。js要调用objective-c就比较麻烦。iOS可行的办法是利用custom URL scheme，跳转到应用之后应用或从path或从querystring来判断js要调用什么类什么方法，比较蛋疼。最理想的方式应该是<a href="https://developer.apple.com/library/mac/#documentation/AppleApplications/Conceptual/SafariJSProgTopics/Tasks/ObjCFromJavaScript.html">safari插件支持的方式</a>，可惜iOS没有。</p>

<p>via:</p>

<ul>
<li><a href="https://devforums.apple.com/message/32282">https://devforums.apple.com/message/32282</a></li>
<li><a href="http://mentormate.com/blog/iphone-uiwebview-class-local-css-javascript-resources/">http://mentormate.com/blog/iphone-uiwebview-class-local-css-javascript-resources/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[bottle直接返回pymongo查询结果]]></title>
    <link href="http://artori.us/bottle-autojson-with-pymongo/"/>
    <updated>2012-12-19T10:32:00+08:00</updated>
    <id>http://artori.us/bottle-autojson-with-pymongo</id>
    <content type="html"><![CDATA[<p>以前提到过<a href="/bottle-i-love-this-framework/">bottle</a>，也写过在<a href="/use-mongodb-with-django/">django里使用pymongo</a>，这次是在bottle里用pymongo。</p>

<p>bottle有类似ROR的一些特性，比如处理请求的时候直接return一个字典，框架会自动把它parse成json（autojson）。</p>

<p>我是想偷个懒来着，把代码写成了下面这样。</p>

<p>```py
@get('/api/today')
def api_today():</p>

<pre><code>udid = request.GET.get('udid')
return self.coll.find_one({'udid':udid, 'date':today})
</code></pre>

<p>```</p>

<p>这会有问题，因为find_one返回的bson没办法直接parse。伟大的发明都是在偷懒的时候诞生的，看起来我要做的事情也很简单，只要能让我改一改parser就行了。</p>

<ol>
<li>写一个dump方法替换原来JSONPlugin里的</li>
<li>设置Bottle app的autojson为False。<code>Bottle(autojson=False)</code></li>
<li>把有自己dump方法的JSONPlugin给install到app里</li>
</ol>


<p>```py
class MongoEncoder(JSONEncoder):</p>

<pre><code>def mongo_dumps(obj):
    # convert all iterables to lists
    if hasattr(obj, '__iter__'):
        return list(obj)
    # convert cursors to lists
    elif isinstance(obj, pymongo.cursor.Cursor):
        return list(obj)
    # convert ObjectId to string
    elif isinstance(obj, bson.objectid.ObjectId):
        return unicode(obj)
    # dereference DBRef
    elif isinstance(obj, bson.dbref.DBRef):
        return db.dereference(obj) # db is the incetance database
    # convert dates to strings
    elif isinstance(obj, datetime.datetime) or isinstance(obj, datetime.date) or isinstance(obj, datetime.time):
        return unicode(obj)
    return json.JSONEncoder.default(self, obj)
</code></pre>

<p>app = app()
app.autojson = False
m_encoder = MongoEncoder()
app.install(JSONPlugin(json_dumps=lambda s: dumps(s, default=m_encoder.mongo_dumps)))
```</p>

<p>via:</p>

<ul>
<li><a href="https://github.com/defnull/bottle/issues/287">https://github.com/defnull/bottle/issues/287</a></li>
<li><a href="https://gist.github.com/2779820">https://gist.github.com/2779820</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[异或]]></title>
    <link href="http://artori.us/exclusive-or/"/>
    <updated>2012-12-13T12:36:00+08:00</updated>
    <id>http://artori.us/exclusive-or</id>
    <content type="html"><![CDATA[<p>不介绍什么是异或了，有人叫半加、数学系的叫按位模2加</p>

<p>下文用得到的一些简单的性质</p>

<ul>
<li><p><code>x^0 = x</code> 且 <code>x^x = 0</code></p></li>
<li><p>交换律：<code>x^y = y^x</code></p></li>
<li><p>结合律：<code>(x^y)^z = x^(y^z)</code></p></li>
<li><p>自反性：<code>x^y^y = x</code></p></li>
</ul>


<p>下面是几个小题目，可以用异或解决，挺有技巧性</p>

<h2>交换两个数ab</h2>

<p><code>ruby
a = a^b
b = a^b
a = a^b
</code></p>

<p>有意思的是搜索其他异或例子的时候，发现了<a href="http://blog.chinaunix.net/uid-1844931-id-3034714.html">这篇</a>文章，文章里实现了一个异或交换的算法，和本文主题无关，不过很有意思，函数更多的时候应该只操作值而不是变量。</p>

<p><strong>UPDATE_2013-05-06</strong>: 这个，看到云风写了一个利用这个特性做的<a href="http://blog.codingnow.com/2013/05/xor_linked_list.html">双向链表</a>，挺好玩，忍不住写过来。</p>

<h2>A集合里拿掉数x得到B集合，求x</h2>

<p>令<code>XOR(X)</code>表示将X集合内所有的数做异或</p>

<p><code>XOR(B)^XOR(A) = XOR(B)^XOR(B)^x = 0^x = x</code></p>

<p><code>ruby
A = (1..10000).to_a
B = A - [1234]
x = (A + B).reduce(&amp;:^)
puts x #1234
</code></p>

<p>via: <a href="http://www.javaeye.com/topic/420487">http://www.javaeye.com/topic/420487</a></p>

<h2>A集合里拿掉数x、y得到B集合，求x和y</h2>

<p>首先按上一个的办法可以推导出<code>xor(A)^xor(B) = xor(B)^xor(B)^x^y = 0^x^y = x^y</code></p>

<p><code>x^y</code>的二进制结果，第n位为1，说明x和y的第n位不相同</p>

<p>根据第n位是否为0把A里所有的数分成A1和A0两个数组（A1里的数的二进制第n位都是1，A0都是0）</p>

<p>A1和A0应该各包含了a或者b（这样第n位才能异或出1）</p>

<p>同理可以把B分成B1和B0两个数组</p>

<p>可以得到第一个数 <code>x = A1^B1</code></p>

<p>第二个数可以<code>y = A0^B0</code>，当然也可以用<code>x^y^x</code>求得</p>

<p>另外如果<code>x^y</code>为0，即<code>x == y</code>，令<code>SUM(X)</code>为X集合内所有数求和</p>

<p><code>(SUM(A) - SUM(B)) / 2 = x</code></p>

<p>via: <a href="http://blog.chinaunix.net/uid-12453618-id-2935334.html">http://blog.chinaunix.net/uid-12453618-id-2935334.html</a></p>

<h2>集合A里只有数x出现1次，其余数全都重复出现2次，求x</h2>

<p><code>xor(A) = x^y^y^…^z^z = x^(y^y^…^z^z) = x^0 = x</code></p>

<p><code>ruby
x = A.reduce(&amp;:^)
</code></p>

<h2>集合A里只有数x出现1次，其余数全都重复出现3次，求x</h2>

<p>xor的本质相当于“按位模2加”（adding modulo 2），令p1,p2…pn为布尔值，true为1、false为0，(+)表示异或操作。</p>

<p><code>p1 (+) p2 (+) ... (+) pn == ( p1 + p2 + ... + pn ) % 2</code></p>

<p>所以只需要实现按位模3加</p>

<p><code>( p1 + p2 + ... + pn ) % 3</code></p>

<p>将集合中所有数二进制表示的同一位的0或1相加，最终的和对3去摸，得到的数即是x</p>

<p>如 <code>A = {5, 7, 7, 7}</code>，二进制表示两个数</p>

<p>```ruby
  101
  111
  111</p>

<h2>+ 111</h2>

<p>  434</p>

<h2>%   3</h2>

<p>  101
```
但愿这坨东西能让人看懂</p>

<p>via: <a href="http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/xor.html">http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/xor.html</a></p>

<h2>没有<code>^</code>操作时候实现异或，只用<code>&amp;</code>与 <code>|</code>或 <code>~</code>非</h2>

<p>这里的转换有很多，比如下面这个</p>

<p><code>x ^ y == (~x &amp; y) | (x &amp; ~y)</code></p>

<p>具体查看<a href="http://en.wikipedia.org/wiki/Exclusive_or">维基百科</a> 《Equivalencies, elimination, and introduction》部分，各种公式</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode优化过的PNG]]></title>
    <link href="http://artori.us/optimized-png-in-xcode/"/>
    <updated>2012-12-12T00:07:00+08:00</updated>
    <id>http://artori.us/optimized-png-in-xcode</id>
    <content type="html"><![CDATA[<p>开始做iOS应用就有一个“公理”，<strong>图片素材要使用png格式</strong>，至于公理是怎么形成的完全不知道，只是听说在官方文档里提到过一句：苹果会对png进行优化。</p>

<p>为什么优化？谁优化的？什么时候优化的？怎么优化的？</p>

<p>和所有的魔术一样，说穿了就不好玩了。一切的根源是iPhone的显存。iPhone的vRAM在存放单个像素的颜色的时候，并不是按照传统的“红-绿-蓝”这样的顺序排列的，而是“蓝-绿-红”，即我们常说的RGB，在iPhone的显存里是BGR。并且，没有alpha通道。</p>

<p>另一边，png格式按照“红-绿-蓝”的顺序描述颜色，并且支持alpha通道的半透明，RGBA四个通道各占1个字节。</p>

<ul>
<li>为什么优化？
因为一边RGB一边BGR，一边有alpha一边没有alpha。</li>
<li>谁优化的？
文章标题已经剧透了，Xcode优化的。</li>
<li>什么时候优化的？
Xcode在编译时，会对png资源进行优化。</li>
<li>怎么优化的？
优化做了两件事：

<ol>
<li>把png里所有的RGB颜色转成BGR顺序</li>
<li>把png里所有的alpha通道先和RGB三通道先乘好（比如R:1 G:1 B:1 A:0.5的颜色直接转成 R:0.5 G:0.5 B:0.5）</li>
</ol>
</li>
</ul>


<p>这样最终设备在运行时渲染这些颜色的时候，不需要任何处理，一个汇编语句就把数据丢尽显存里了。</p>

<p>PS: <a href="http://developer.apple.com/library/ios/#qa/qa1681/_index.html">这里</a>还有一个手动转换，和还原的办法</p>

<p>via: <a href="http://iphonedevelopment.blogspot.jp/2008/10/iphone-optimized-pngs.html">http://iphonedevelopment.blogspot.jp/2008/10/iphone-optimized-pngs.html</a></p>
]]></content>
  </entry>
  
</feed>
